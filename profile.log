SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/telescope.nvim/ftplugin/TelescopePrompt.lua
Sourced 21 times
Total time:   0.006394
 Self time:   0.006394

count  total (s)   self (s)
                            -- Don't wrap textwidth things
                            vim.opt_local.formatoptions:remove "t"
                            vim.opt_local.formatoptions:remove "c"
                            
                            -- Don't include `showbreak` when calculating strdisplaywidth
                            vim.opt_local.wrap = false
                            
                            -- There's also no reason to enable textwidth here anyway
                            vim.opt_local.textwidth = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/telescope.nvim/ftplugin/TelescopeResults.lua
Sourced 21 times
Total time:   0.002149
 Self time:   0.002149

count  total (s)   self (s)
                            -- Don't have scrolloff, it makes things weird.
                            vim.opt_local.scrolloff = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/gitignore.vim
Sourced 9 times
Total time:   0.001442
 Self time:   0.001442

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	git ignore
                            " Maintainer:	ObserverOfTime <chronobserver@disroot.org>
                            " Filenames:	.gitignore, *.git/info/exclude
                            " Last Change:	2022 Sep 10
                            
    9              0.000096 if exists('b:current_syntax')
                                finish
    9              0.000009 endif
                            
                            " Comment
    9              0.000071 syn keyword gitignoreTodo contained TODO FIXME XXX
    9              0.000102 syn match gitignoreComment /^#.*/ contains=gitignoreTodo
                            
                            " Pattern
    9              0.000096 syn match gitignorePattern /^#\@!.*$/ contains=gitignoreNegation,gitignoreGlob,gitignoreRange,gitignoreSeparator
    9              0.000033 syn match gitignoreNegation /^!/ contained
    9              0.000052 syn match gitignoreGlob /\\\@1<![?*]/ contained
    9              0.000047 syn match gitignoreRange /\\\@1<!\[.\{-}\]/ contained
    9              0.000033 syn match gitignoreSeparator '/' contained
                            
    9              0.000025 hi def link gitignoreComment Comment
    9              0.000013 hi def link gitignoreGlob Special
    9              0.000012 hi def link gitignoreNegation SpecialChar
    9              0.000011 hi def link gitignoreRange Special
    9              0.000012 hi def link gitignoreSeparator Delimiter
    9              0.000012 hi def link gitignoreTodo Todo
                            
    9              0.000056 let b:current_syntax = 'gitignore'

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/ruby.vim
Sourced 6 times
Total time:   0.157555
 Self time:   0.059256

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:		2021 Nov 03
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
                            " Prelude {{{1
    6              0.000096 if exists("b:current_syntax")
                              finish
    6              0.000007 endif
                            
                            " this file uses line continuations
    6              0.000115 let s:cpo_sav = &cpo
    6              0.000115 set cpo&vim
                            
                            " eRuby Config {{{1
    6              0.000037 if exists('main_syntax') && main_syntax == 'eruby'
                              let b:ruby_no_expensive = 1
    6              0.000007 endif
                            
                            " Folding Config {{{1
    6              0.000058 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
    6              0.000005 endif
                            
    6              0.000185 let s:foldable_groups = split(
                                  \	  get(
                                  \	    b:,
                                  \	    'ruby_foldable_groups',
                                  \	    get(g:, 'ruby_foldable_groups', 'ALL')
                                  \	  )
                                  \	)
                            
    6              0.000036 function! s:foldable(...) abort
                              if index(s:foldable_groups, 'NONE') > -1
                                return 0
                              endif
                            
                              if index(s:foldable_groups, 'ALL') > -1
                                return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
    6              0.000030 function! s:run_syntax_fold(args) abort
                              let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
                              if call('s:foldable', split(groups))
                                let cmd .= ' fold'
                              endif
                              exe cmd
                            endfunction
                            
    6              0.000111 com! -nargs=* SynFold call s:run_syntax_fold(<q-args>)
                            
                            " Not-Top Cluster {{{1
    6              0.000156 syn cluster rubyNotTop contains=@rubyCommentNotTop,@rubyStringNotTop,@rubyRegexpSpecial,@rubyDeclaration,@rubyExceptionHandler,@rubyClassOperator,rubyConditional,rubyModuleName,rubyClassName,rubySymbolDelimiter,rubyDoubleQuoteSymbolDelimiter,rubySingleQuoteSymbolDelimiter,rubyParentheses,@Spell
                            
                            " Whitespace Errors {{{1
    6              0.000033 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
    6              0.000006 endif
                            
                            " Operators {{{1
                            
    6              0.000060 syn match rubyEnglishBooleanOperator "\<\%(and\|or\|not\)\>"
                            
    6              0.000053 if exists("ruby_operators") || exists("ruby_pseudo_operators")
                              syn match rubyDotOperator	   "\.\|&\."
                            
                              syn match rubyTernaryOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!?\|:"
                              syn match rubyArithmeticOperator "\*\*\|[*/%+]\|->\@!"
                              syn match rubyComparisonOperator "<=>\|<=\|<\|>=\|[-=]\@1<!>"
                              syn match rubyBitwiseOperator    "[~^|]\|&\.\@!\|<<\|>>"
                              syn match rubyBooleanOperator    "\%(\w\|[^\x00-\x7F]\)\@1<!!\|&&\|||"
                              syn match rubyRangeOperator	   "\.\.\.\="
                              syn match rubyAssignmentOperator "=>\@!\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|||=\||=\|%=\|+=\|>>=\|<<=\|\^="
                              syn match rubyAssignmentOperator "=>\@!" contained containedin=rubyBlockParameterList " TODO: this is inelegant
                              syn match rubyEqualityOperator   "===\|==\|!=\|!\~\|=\~"
                            
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<=\[" end="]" contains=ALLBUT,@rubyNotTop
                            
                              syn match rubyScopeOperator	    "::"
                              syn match rubySuperClassOperator  "<"	 contained
                              syn match rubyEigenClassOperator  "<<" contained
                              syn match rubyLambdaOperator	    "->"
                              syn match rubySplatOperator	    "\%([[{(|,=]\_s*\)\@<=\*"
                              syn match rubySplatOperator	    "\%(^\|\s\)\@1<=\*\%(\h\|[^\x00-\x7F]\|[:$@[]\)\@="
                              syn match rubyDoubleSplatOperator "\%([{(|,]\_s*\)\@<=\*\*"
                              syn match rubyDoubleSplatOperator "\s\@1<=\*\*\%(\h\|[^\x00-\x7F]\|[:$@{]\)\@="
                              syn match rubyProcOperator	    "\%([[(|,]\_s*\)\@<=&"
                              syn match rubyProcOperator	    "\s\@1<=&\%(\h\|[^\x00-\x7F]\|[:$@]\|->\)\@="
                            
                              syn cluster rubyProperOperator contains=rubyTernaryOperator,rubyArithmeticOperator,rubyComparisonOperator,rubyBitwiseOperator,rubyBooleanOperator,rubyRangeOperator,rubyAssignmentOperator,rubyEqualityOperator,rubyDefinedOperator,rubyEnglishBooleanOperator
                              syn cluster rubyClassOperator  contains=rubyEigenClassOperator,rubySuperClassOperator
                              syn cluster rubyPseudoOperator contains=rubyDotOperator,rubyScopeOperator,rubyEigenClassOperator,rubySuperClassOperator,rubyLambdaOperator,rubySplatOperator,rubyDoubleSplatOperator,rubyProcOperator
                              syn cluster rubyOperator	 contains=ruby.*Operator
    6              0.000007 endif
                            
                            " String Interpolation and Backslash Notation {{{1
    6              0.000078 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    6              0.000092 syn match  rubyInterpolation	      "#\$\%(-\w\|[!$&"'*+,./0:;<>?@\`~_]\|\w\+\)" display contained contains=rubyInterpolationDelimiter,@rubyGlobalVariable
    6              0.000064 syn match  rubyInterpolation	      "#@@\=\w\+"				   display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable
    6              0.000038 syn match  rubyInterpolationDelimiter "#\ze[$@]"				   display contained
                            
    6              0.000036 syn match rubyStringEscape "\\\_."											   contained display
    6              0.000060 syn match rubyStringEscape "\\\o\{1,3}\|\\x\x\{1,2}"									   contained display
    6              0.000077 syn match rubyStringEscape "\\u\%(\x\{4}\|{\x\{1,6}\%(\s\+\x\{1,6}\)*}\)"						   contained display
    6              0.000095 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=.\)" contained display
                            
    6              0.000055 syn match rubyBackslashEscape "\\\\" contained display
    6              0.000034 syn match rubyQuoteEscape     "\\'"  contained display
    6              0.000050 syn match rubySpaceEscape     "\\ "  contained display
                            
    6              0.000034 syn match rubyParenthesisEscape	  "\\[()]"  contained display
    6              0.000035 syn match rubyCurlyBraceEscape	  "\\[{}]"  contained display
    6              0.000031 syn match rubyAngleBracketEscape  "\\[<>]"  contained display
    6              0.000036 syn match rubySquareBracketEscape "\\[[\]]" contained display
                            
    6              0.000079 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  end=")"	transparent contained
    6              0.000074 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  end="}"	transparent contained
    6              0.000072 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  end=">"	transparent contained
    6              0.000067 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" end="\]"	transparent contained
                            
    6              0.000065 syn cluster rubySingleCharEscape contains=rubyBackslashEscape,rubyQuoteEscape,rubySpaceEscape,rubyParenthesisEscape,rubyCurlyBraceEscape,rubyAngleBracketEscape,rubySquareBracketEscape
    6              0.007713 syn cluster rubyNestedBrackets	 contains=rubyNested.\+
    6              0.000053 syn cluster rubyStringSpecial	 contains=rubyInterpolation,rubyStringEscape
    6              0.000042 syn cluster rubyStringNotTop	 contains=@rubyStringSpecial,@rubyNestedBrackets,@rubySingleCharEscape
                            
                            " Regular Expression Metacharacters {{{1
    6              0.000093 syn region rubyRegexpComment	  matchgroup=rubyRegexpSpecial	 start="(?#"								    skip="\\\\\|\\)"  end=")"  contained
    6              0.000162 syn region rubyRegexpParens	  matchgroup=rubyRegexpSpecial	 start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\\\\|\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
    6              0.000128 syn region rubyRegexpBrackets	  matchgroup=rubyRegexpCharClass start="\[\^\="								    skip="\\\\\|\\\]" end="\]" contained transparent contains=rubyRegexpBrackets,rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass,rubyRegexpIntersection oneline
    6              0.000045 syn match  rubyRegexpCharClass	  "\\[DdHhRSsWw]"	 contained display
    6              0.000118 syn match  rubyRegexpCharClass	  "\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|word\|xdigit\):\]" contained
    6              0.000057 syn match  rubyRegexpCharClass	  "\\[pP]{^\=.\{-}}"	 contained display
    6              0.000045 syn match  rubyRegexpEscape	  "\\[].*?+^$|\\/(){}[]" contained " see commit e477f10
    6              0.000042 syn match  rubyRegexpQuantifier	  "[*?+][?+]\="		 contained display
    6              0.000060 syn match  rubyRegexpQuantifier	  "{\d\+\%(,\d*\)\=}?\=" contained display
    6              0.000040 syn match  rubyRegexpAnchor	  "[$^]\|\\[ABbGZz]"	 contained display
    6              0.000033 syn match  rubyRegexpDot	  "\.\|\\X"		 contained display
    6              0.000030 syn match  rubyRegexpIntersection "&&"			 contained display
    6              0.000032 syn match  rubyRegexpSpecial	  "\\K"			 contained display
    6              0.000026 syn match  rubyRegexpSpecial	  "|"			 contained display
    6              0.000045 syn match  rubyRegexpSpecial	  "\\[1-9]\d\=\d\@!"	 contained display
    6              0.000064 syn match  rubyRegexpSpecial	  "\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    6              0.000092 syn match  rubyRegexpSpecial	  "\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    6              0.000044 syn match  rubyRegexpSpecial	  "\\g<\%([a-z_]\w*\|-\=\d\+\)>"		contained display
    6              0.000046 syn match  rubyRegexpSpecial	  "\\g'\%([a-z_]\w*\|-\=\d\+\)'"		contained display
                            
    6              0.000088 syn cluster rubyRegexpSpecial contains=@rubyStringSpecial,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment,rubyRegexpIntersection
                            
                            " Numbers {{{1
    6              0.000102 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*r\=i\=\>"							       display
    6              0.000096 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)r\=i\=\>"					       display
    6              0.000076 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*r\=i\=\>"							       display
    6              0.000087 syn match rubyInteger "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*r\=i\=\>"						       display
    6              0.000105 syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*r\=i\=\>"				       display
    6              0.000114 syn match rubyFloat   "\%(\%(\w\|[^\x00-\x7F]\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)i\=\>" display
                            
                            " Identifiers {{{1
    6              0.000094 syn match rubyClassName	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
    6              0.000083 syn match rubyModuleName       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!" contained
    6              0.000072 syn match rubyConstant	       "\%(\%(^\|[^.]\)\.\s*\)\@<!\<[[:upper:]]\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
    6              0.000061 syn match rubyClassVariable    "@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    6              0.000071 syn match rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  display
    6              0.000065 syn match rubyGlobalVariable   "$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    6              0.000031 syn match rubySymbolDelimiter  ":" contained
    6              0.000144 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\^\|\~@\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!@\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)" contains=rubySymbolDelimiter
    6              0.000079 syn match rubySymbol	       "[]})\"':]\@1<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"			    contains=rubySymbolDelimiter
    6              0.000081 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  contains=rubySymbolDelimiter
    6              0.000077 syn match rubySymbol	       "[]})\"':]\@1<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\=" contains=rubySymbolDelimiter
                            
    6   0.001147   0.000218 SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape,rubyBackslashEscape
    6   0.000918   0.000174 SynFold ':' syn region rubySymbol matchgroup=rubySymbolDelimiter start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial
                            
    6              0.000085 syn match rubyCapitalizedMethod "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@="
                            
    6              0.000077 syn region rubyParentheses	  start="("				 end=")" contains=ALLBUT,@rubyNotTop contained containedin=rubyBlockParameterList
    6              0.000098 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\_s*\)\@32<=|" end="|" contains=ALLBUT,@rubyNotTop,@rubyProperOperator
                            
    6              0.000038 if exists('ruby_global_variable_error')
                              syn match rubyGlobalVariableError "$[^A-Za-z_]"	display
                              syn match rubyGlobalVariableError "$-[^0FIKWadilpvw]" display
    6              0.000011 endif
                            
    6              0.000071 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<>?@\`~]#
    6              0.000037 syn match rubyPredefinedVariable "$\d\+"									    display
    6              0.000029 syn match rubyPredefinedVariable "$_\>"										    display
    6              0.000041 syn match rubyPredefinedVariable "$-[0FIWadilpvw]\>"								    display
    6              0.000048 syn match rubyPredefinedVariable "$\%(stderr\|stdin\|stdout\)\>"						    display
    6              0.000097 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    6              0.000110 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\)\>\%(\s*(\)\@!"
    6              0.000135 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Deprecated/removed in 1.9
    6              0.000030 syn match rubyPredefinedVariable "$="
    6              0.000033 syn match rubyPredefinedVariable "$-K\>"		  display
    6              0.000049 syn match rubyPredefinedVariable "$\%(deferr\|defout\)\>" display
    6              0.000038 syn match rubyPredefinedVariable "$KCODE\>"		  display
                            " Deprecated/removed in 2.4
    6              0.000064 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(FALSE\|NIL\|TRUE\)\>\%(\s*(\)\@!"
                            
    6              0.000045 syn cluster rubyGlobalVariable contains=rubyGlobalVariable,rubyPredefinedVariable,rubyGlobalVariableError
                            
                            " Normal Regular Expressions {{{1
    6   0.001249   0.000207 SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
    6   0.001110   0.000196 SynFold '/' syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\s\+\)\@<=/\%(=\|\_s\)\@!"					   end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
                            
                            " Generalized Regular Expressions {{{1
    6   0.000977   0.000187 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial nextgroup=@rubyModifier skipwhite
    6   0.000861   0.000163 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r{"				   end="}[iomxneus]*"	skip="\\\\\|\\}"   contains=@rubyRegexpSpecial
    6   0.000919   0.000163 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r<"				   end=">[iomxneus]*"	skip="\\\\\|\\>"   contains=@rubyRegexpSpecial,rubyNestedAngleBrackets
    6   0.000827   0.000160 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\["				   end="\][iomxneus]*"	skip="\\\\\|\\\]"  contains=@rubyRegexpSpecial
    6   0.000816   0.000151 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r("				   end=")[iomxneus]*"	skip="\\\\\|\\)"   contains=@rubyRegexpSpecial
    6   0.000829   0.000157 SynFold '%' syn region rubyRegexp matchgroup=rubyPercentRegexpDelimiter start="%r\z(\s\)"			   end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                            
                            " Characters {{{1
    6              0.000163 syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\[[:space:]]\|\\\=[^[:space:]]\)\)"
    6              0.000081 syn match rubyCharacter "\%(\w\|[^\x00-\x7F]\|[]})\"'/]\)\@1<!?\\u\%(\x\{4}\|{\x\{1,6}}\)"
                            
                            " Normal Strings {{{1
    6              0.000058 let s:spell_cluster = exists('ruby_spellcheck_strings') ? ',@Spell' : ''
    6   0.000198   0.000100 let s:fold_arg	    = s:foldable('string')		? ' fold'   : ''
    6              0.000148 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\""  contains=@rubyStringSpecial'		       . s:spell_cluster . s:fold_arg
    6              0.000133 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="''" end="''" skip="\\\\\|\\''"  contains=rubyQuoteEscape,rubyBackslashEscape' . s:spell_cluster . s:fold_arg
    6              0.000030 unlet s:spell_cluster s:fold_arg
                            
                            " Shell Command Output {{{1
    6   0.000779   0.000141 SynFold 'string' syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial
                            
                            " Generalized Single Quoted Strings, Symbols, Array of Strings and Array of Symbols {{{1
                            
                            " Non-bracket punctuation delimiters {{{2
    6              0.000183 let s:names = { '~': 'Tilde', '`': 'BackQuote', '!': 'Bang', '@': 'At', '#': 'Hash', '$': 'Dollar', '%': 'Percent', '^': 'Caret',
                                  \		'&': 'Ampersand', '*': 'Asterix', '_': 'Underscore', '-': 'Dash', '+': 'Plus', '=': 'Equals', '|': 'Bar',
                                  \		'\': 'Backslash', ':': 'Colon', ';': 'Semicolon', '"': 'DoubleQuote', "'": 'Quote', ',': 'Comma', '.': 'Period',
                                  \		'?': 'QuestionMark', '/': 'ForwardSlash' }
                            
  150              0.000383 for s:delimiter in keys(s:names)
  144              0.000753   let s:group = 'ruby' . s:names[s:delimiter] . 'Escape'
                            
  144              0.000980   if s:delimiter =~ '[\"]'
   12              0.000049     let s:delimiter = '\' . s:delimiter
  144              0.000141   endif
                            
  144              0.001402   exe 'syn match ' . s:group . ' "\V\\' . s:delimiter . '" contained display'
  144              0.001333   exe 'syn cluster rubySingleCharEscape add=' . s:group
  144   0.019243   0.004401   exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%q' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
  144   0.019478   0.004710   exe 'SynFold ''%'' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\V%w' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
  144   0.018670   0.004496   exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%s' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,'		 . s:group . ' nextgroup=@rubyModifier skipwhite'
  144   0.019251   0.004591   exe 'SynFold ''%'' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="\V%i' . s:delimiter . '" end="\V' . s:delimiter . '" skip="\V\\\\\|\\' . s:delimiter . '" contains=rubyBackslashEscape,rubySpaceEscape,' . s:group . ' nextgroup=@rubyModifier skipwhite'
  144              0.001004   exe 'hi def link ' . s:group . ' rubyStringEscape'
  150              0.000185 endfor
                            
    6              0.000051 unlet s:delimiter s:group s:names
                            " }}}2
                            
    6   0.000796   0.000158 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    6   0.000769   0.000142 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    6   0.000754   0.000140 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    6   0.000762   0.000147 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
    6   0.000745   0.000139 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%q\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
                            
    6   0.000765   0.000142 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    6   0.000792   0.000142 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    6   0.000802   0.000145 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    6   0.000757   0.000137 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%w("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
                            
    6   0.000880   0.000139 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    6   0.000800   0.000132 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    6   0.000728   0.000136 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    6   0.000721   0.000134 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%s("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubyParenthesisEscape,rubyNestedParentheses
    6   0.000742   0.000132 SynFold '%' syn region rubyString matchgroup=rubyPercentSymbolDelimiter start="%s\z(\s\)" end="\z1" skip="\\\\\|\\\z1" contains=rubyBackslashEscape,rubySpaceEscape
                            
    6   0.000724   0.000132 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i{"	  end="}"   skip="\\\\\|\\}"   contains=rubyBackslashEscape,rubySpaceEscape,rubyCurlyBraceEscape,rubyNestedCurlyBraces
    6   0.000709   0.000141 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i<"	  end=">"   skip="\\\\\|\\>"   contains=rubyBackslashEscape,rubySpaceEscape,rubyAngleBracketEscape,rubyNestedAngleBrackets
    6   0.000739   0.000132 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i\["	  end="\]"  skip="\\\\\|\\\]"  contains=rubyBackslashEscape,rubySpaceEscape,rubySquareBracketEscape,rubyNestedSquareBrackets
    6   0.000735   0.000131 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%i("	  end=")"   skip="\\\\\|\\)"   contains=rubyBackslashEscape,rubySpaceEscape,rubyParenthesisEscape,rubyNestedParentheses
                            
                            " Generalized Double Quoted Strings, Array of Strings, Array of Symbols and Shell Command Output {{{1
    6   0.000780   0.000136 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="\%(\%(\w\|[^\x00-\x7F]\|]\)\s*\)\@<!%=" end="="	 skip="\\\\\|\\="   contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    6   0.000777   0.000143 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    6   0.000776   0.000138 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    6   0.000726   0.000136 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\={"			       end="}"	 skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces
    6   0.000719   0.000131 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=<"			       end=">"	 skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets
    6   0.000738   0.000142 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=\["			       end="\]"  skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets
    6   0.000722   0.000133 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[QWx]\=("			       end=")"	 skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses
    6   0.000684   0.000131 SynFold '%' syn region rubyString matchgroup=rubyPercentStringDelimiter start="%[Qx]\z(\s\)"			       end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                            
    6   0.000734   0.000130 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial nextgroup=@rubyModifier skipwhite
    6   0.000711   0.000132 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I{"				   end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces
    6   0.000647   0.000133 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I<"				   end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets
    6   0.000703   0.000131 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I\["				   end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets
    6   0.000662   0.000124 SynFold '%' syn region rubySymbol matchgroup=rubyPercentSymbolDelimiter start="%I("				   end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses
                            
                            " Here Documents {{{1
    6              0.000155 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    6              0.000112 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs"\%([^"]*\)"+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
    6              0.000108 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs'\%([^']*\)'+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
    6              0.000104 syn region rubyHeredocStart matchgroup=rubyHeredocDelimiter start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<[-~]\=\zs`\%([^`]*\)`+					   end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    6   0.000995   0.000211 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2  matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
    6   0.000874   0.000166 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
    6   0.000863   0.000169 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart		     keepend
    6   0.000892   0.000152 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})"'`]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2				      matchgroup=rubyHeredocDelimiter end=+^\z1$+	contains=rubyHeredocStart,@rubyStringSpecial keepend
                            
    6   0.000987   0.000184 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3 matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
    6   0.000825   0.000150 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
    6   0.000833   0.000152 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		     keepend
    6   0.000880   0.000157 SynFold '<<' syn region rubyString start=+\%(\%(class\|::\|\.\@1<!\.\)\_s*\|\%([]})]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3				      matchgroup=rubyHeredocDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                            
                            " Module, Class, Method and Alias Declarations {{{1
    6              0.000079 syn match rubyAliasDeclaration	"[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable nextgroup=rubyAliasDeclaration2 skipwhite
    6              0.000055 syn match rubyAliasDeclaration2 "[^[:space:];#.()]\+" contained contains=rubySymbol,@rubyGlobalVariable
    6              0.000082 syn match rubyMethodDeclaration "[^[:space:];#(]\+"   contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    6              0.000067 syn match rubyClassDeclaration	"[^[:space:];#<]\+"   contained contains=rubyClassName,rubyScopeOperator nextgroup=rubySuperClassOperator skipwhite
    6              0.000051 syn match rubyModuleDeclaration "[^[:space:];#<]\+"   contained contains=rubyModuleName,rubyScopeOperator
                            
    6              0.000083 syn match rubyMethodName "\<\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%([[:alnum:]_.:?!=]\|[^\x00-\x7F]\)\@!"			      contained containedin=rubyMethodDeclaration
    6              0.000095 syn match rubyMethodName "\%(\s\|^\)\@1<=\%([_[:alpha:]]\|[^\x00-\x7F]\)\%([_[:alnum:]]\|[^\x00-\x7F]\)*[?!=]\=\%(\s\|$\)\@="					      contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    6              0.000125 syn match rubyMethodName "\%([[:space:].]\|^\)\@1<=\%(\[\]=\=\|\*\*\|[-+!~]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    6              0.000050 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyMethodName
                            
                            " Keywords {{{1
                            " TODO: reorganise
    6              0.000080 syn match rubyControl	     "\%#=1\<\%(break\|in\|next\|redo\|retry\|return\)\>"
    6              0.000039 syn match rubyKeyword	     "\%#=1\<\%(super\|yield\)\>"
    6              0.000045 syn match rubyBoolean	     "\%#=1\<\%(true\|false\)\>[?!]\@!"
    6              0.000040 syn match rubyPseudoVariable "\%#=1\<\(self\|nil\)\>[?!]\@!"
    6              0.000064 syn match rubyPseudoVariable "\%#=1\<__\%(ENCODING\|dir\|FILE\|LINE\|callee\|method\)__\>"
    6              0.000041 syn match rubyBeginEnd	     "\%#=1\<\%(BEGIN\|END\)\>"
                            
                            " Expensive Mode {{{1
                            " Match 'end' with the appropriate opening keyword for syntax based folding
                            " and special highlighting of module/class/method definitions
    6              0.000048 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
    6              0.000043   syn match rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration			  skipwhite skipnl
    6              0.000034   syn match rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration			  skipwhite skipnl
    6              0.000042   syn match rubyDefine "\<undef\>"  nextgroup=rubyMethodName				  skipwhite skipnl
    6              0.000043   syn match rubyClass  "\<class\>"  nextgroup=rubyClassDeclaration,rubyEigenClassOperator skipwhite skipnl
    6              0.000044   syn match rubyModule "\<module\>" nextgroup=rubyModuleDeclaration			  skipwhite skipnl
                            
    6   0.000801   0.000137   SynFold 'def'    syn region rubyMethodBlock start="\<def\>"	 matchgroup=rubyDefine skip="\<end:\|\%(\<def\_s\+\)\@<=end\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
    6   0.000698   0.000129   SynFold 'class'  syn region rubyClassBlock  start="\<class\>"  matchgroup=rubyClass  skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
    6   0.000627   0.000116   SynFold 'module' syn region rubyModuleBlock start="\<module\>" matchgroup=rubyModule skip="\<end:"			       end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
                              " endless def
    6              0.000082   syn match rubyDefine "\<def\s\+\ze[^[:space:];#(]\+\%(\s\+\|\s*(.*)\s*\)=" nextgroup=rubyMethodDeclaration skipwhite
                            
                              " modifiers
    6              0.000036   syn match rubyLineContinuation    "\\$" nextgroup=@rubyModifier skipwhite skipnl
    6              0.000035   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"
    6              0.000032   syn match rubyRepeatModifier	    "\<\%(while\|until\)\>"
    6              0.000026   syn match rubyRescueModifier	    "\<rescue\>"
                            
    6              0.000035   syn cluster rubyModifier contains=rubyConditionalModifier,rubyRepeatModifier,rubyRescueModifier
                            
    6   0.000649   0.000116   SynFold 'do' syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
                              " curly bracket block or hash literal
    6   0.000625   0.000106   SynFold '{' syn region rubyCurlyBlock   matchgroup=rubyCurlyBlockDelimiter start="{"						    end="}" contains=ALLBUT,@rubyNotTop
    6   0.000669   0.000125   SynFold '[' syn region rubyArrayLiteral matchgroup=rubyArrayDelimiter      start="\%(\%(\w\|[^\x00-\x7F]\)[?!]\=\|[]})]\)\@2<!\[" end="]" contains=ALLBUT,@rubyNotTop
                            
                              " statements without 'do'
    6   0.000655   0.000120   SynFold 'begin' syn region rubyBlockExpression matchgroup=rubyControl     start="\<begin\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
    6   0.000649   0.000120   SynFold 'case'  syn region rubyCaseExpression  matchgroup=rubyConditional start="\<case\>"  skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
    6   0.000878   0.000161   SynFold 'if' syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\<then\s\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop
                            
    6              0.000053   syn match rubyConditional "\<\%(then\|else\|when\)\>"	 contained containedin=rubyCaseExpression
    6              0.000043   syn match rubyConditional "\<\%(then\|else\|elsif\)\>" contained containedin=rubyConditionalExpression
                            
    6              0.000070   syn match   rubyExceptionHandler  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyBlockExpression,rubyDoBlock
    6              0.000065   syn match   rubyExceptionHandler2 "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>" contained containedin=rubyModuleBlock,rubyClassBlock,rubyMethodBlock
    6              0.000029   syn cluster rubyExceptionHandler  contains=rubyExceptionHandler,rubyExceptionHandler2
                            
                              " statements with optional 'do'
    6              0.000166   syn region rubyOptionalDoLine matchgroup=rubyRepeat start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\<do\>" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
                            
    6   0.001008   0.000180   SynFold 'for' syn region rubyRepeatExpression start="\<for\>" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\@<![!?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat skip="\<end:" end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine
                            
    6              0.000031   if !exists("ruby_minlines")
    1              0.000004     let ruby_minlines = 500
    6              0.000007   endif
    6              0.000042   exe "syn sync minlines=" . ruby_minlines
                            
                            else
                              syn match rubyControl "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
                              syn match rubyControl "\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
                              syn match rubyControl "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                              syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|rescue\|ensure\|then\|when\|end\)\>"
                              syn match rubyKeyword "\<\%(alias\|undef\)\>"
    6              0.000009 endif
                            
                            " Special Methods {{{1
    6              0.000030 if !exists("ruby_no_special_methods")
    6              0.000048   syn match rubyAccess	  "\<\%(public\|protected\|private\)\>" " use re=2
    6              0.000059   syn match rubyAccess	  "\%#=1\<\%(public\|private\)_class_method\>"
    6              0.000043   syn match rubyAccess	  "\%#=1\<\%(public\|private\)_constant\>"
    6              0.000031   syn match rubyAccess	  "\%#=1\<module_function\>"
    6              0.000062   syn match rubyAttribute "\%#=1\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!" " attr is a common variable name
    6              0.000050   syn match rubyAttribute "\%#=1\<attr_\%(accessor\|reader\|writer\)\>"
    6              0.000053   syn match rubyControl   "\%#=1\<\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>"
    6              0.000022   syn match rubyEval	  "\%#=1\<eval\>"
    6              0.000044   syn match rubyEval	  "\%#=1\<\%(class\|instance\|module\)_eval\>"
    6              0.000042   syn match rubyException "\%#=1\<\%(raise\|fail\|catch\|throw\)\>"
    6              0.000058   syn match rubyInclude   "\%#=1\<\%(autoload\|gem\|load\|require\%(_relative\)\=\)\>"
    6              0.000043   syn match rubyKeyword   "\%#=1\<\%(callcc\|caller\|lambda\|proc\)\>"
    6              0.000051   syn match rubyMacro	  "\%#=1\<\%(extend\|include\|prepend\|refine\|using\)\>"
    6              0.000061   syn match rubyMacro	  "\%#=1\<\%(alias\|define\|define_singleton\|remove\|undef\)_method\>"
    6              0.000007 endif
                            
                            " Comments and Documentation {{{1
    6              0.000027 syn match   rubySharpBang    "\%^#!.*" display
    6              0.000038 syn keyword rubyTodo	     FIXME NOTE TODO OPTIMIZE HACK REVIEW XXX todo contained
    6              0.000035 syn match   rubyEncoding     "[[:alnum:]-_]\+" contained display
    6              0.000061 syn match   rubyMagicComment "\c\%<3l#\s*\zs\%(coding\|encoding\):"					contained nextgroup=rubyEncoding skipwhite
    6              0.000076 syn match   rubyMagicComment "\c\%<10l#\s*\zs\%(frozen_string_literal\|warn_indent\|warn_past_scope\):" contained nextgroup=rubyBoolean  skipwhite
    6              0.000058 syn match   rubyMagicComment "\c\%<10l#\s*\zs\%(shareable_constant_value\):"				contained nextgroup=rubyEncoding  skipwhite
    6              0.000053 syn match   rubyComment	     "#.*" contains=@rubyCommentSpecial,rubySpaceError,@Spell
                            
    6              0.000028 syn cluster rubyCommentSpecial contains=rubySharpBang,rubyTodo,rubyMagicComment
    6              0.000026 syn cluster rubyCommentNotTop  contains=@rubyCommentSpecial,rubyEncoding
                            
    6   0.000174   0.000086 if !exists("ruby_no_comment_fold") && s:foldable('#')
    6              0.000103   syn region rubyMultilineComment start="^\s*#.*\n\%(^\s*#\)\@=" end="^\s*#.*\n\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    6              0.000082   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$"      contains=rubySpaceError,rubyTodo,@Spell fold
                            else
                              syn region rubyDocumentation	  start="^=begin\s*$"		 end="^=end\s*$"              contains=rubySpaceError,rubyTodo,@Spell
    6              0.000009 endif
                            
                            " {{{1 Useless Line Continuations
    6              0.000081 syn match rubyUselessLineContinuation "\%([.:,;{([<>~\*%&^|+=-]\|%(\%(\w\|[^\x00-\x7F]\)\@1<![?!]\)\s*\zs\\$" nextgroup=rubyUselessLineContinuation skipwhite skipempty
    6              0.000031 syn match rubyUselessLineContinuation "\\$"								      nextgroup=rubyUselessLineContinuation skipwhite skipempty contained
                            
                            " Keyword Nobbling {{{1
                            " prevent methods with keyword names being highlighted as keywords when called
    6              0.000075 syn match rubyKeywordAsMethod "\%(\%(\.\@1<!\.\)\|&\.\|::\)\_s*\%([_[:lower:]][_[:alnum:]]*\|\%(BEGIN\|END\)\>\)" transparent contains=rubyDotOperator,rubyScopeOperator
                            
                            " Bang and Predicate Methods and Operators {{{1
    6              0.000043 syn match rubyBangPredicateMethod "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]"
                            
    6              0.000030 if !exists("ruby_no_special_methods")
    6              0.000032   syn match rubyControl "\%#=1\<exit!" display
    6              0.000007 endif
    6              0.000023 syn match rubyDefinedOperator "\%#=1\<defined?" display
                            
                            " 1.9-style Hash Keys and Keyword Parameters {{{1
    6              0.000058 syn match rubySymbol "\%(\w\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[?!]\=::\@!"he=e-1 contained containedin=rubyBlockParameterList,rubyCurlyBlock
    6              0.000063 syn match rubySymbol "[]})\"':]\@1<!\<\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="he=e-1
    6              0.000066 syn match rubySymbol "[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],;]\@="hs=s+1,he=e-1
    6              0.000026 syn match rubySingleQuoteSymbolDelimiter "'" contained
    6              0.000059 syn match rubySymbol "'\%(\\.\|[^']\)*'::\@!"he=e-1 contains=rubyQuoteEscape,rubyBackslashEscape,rubySingleQuoteSymbolDelimiter
    6              0.000023 syn match rubyDoubleQuoteSymbolDelimiter "\"" contained
    6              0.000050 syn match rubySymbol "\"\%(\\.\|[^\"]\)*\"::\@!"he=e-1 contains=@rubyStringSpecial,rubyDoubleQuoteSymbolDelimiter
                            
                            " __END__ Directive {{{1
    6   0.000666   0.000125 SynFold '__END__' syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$"
                            
                            " Default Highlighting {{{1
    6              0.000018 hi def link rubyClass			rubyDefine
    6              0.000011 hi def link rubyModule			rubyDefine
    6              0.000011 hi def link rubyExceptionHandler2	rubyDefine
    6              0.000009 hi def link rubyDefine			Define
    6              0.000009 hi def link rubyAccess			rubyMacro
    6              0.000009 hi def link rubyAttribute		rubyMacro
    6              0.000009 hi def link rubyMacro			Macro
    6              0.000010 hi def link rubyMethodName		rubyFunction
    6              0.000009 hi def link rubyFunction		Function
    6              0.000010 hi def link rubyConditional		Conditional
    6              0.000011 hi def link rubyConditionalModifier	rubyConditional
    6              0.000010 hi def link rubyExceptionHandler	rubyConditional
    6              0.000010 hi def link rubyRescueModifier		rubyExceptionHandler
    6              0.000009 hi def link rubyRepeat			Repeat
    6              0.000010 hi def link rubyRepeatModifier		rubyRepeat
    6              0.000009 hi def link rubyOptionalDo		rubyRepeat
    6              0.000009 hi def link rubyControl			Statement
    6              0.000009 hi def link rubyInclude			Include
    6              0.000010 hi def link rubyInteger			Number
    6              0.000010 hi def link rubyCharacter		Character
    6              0.000009 hi def link rubyFloat			Float
    6              0.000009 hi def link rubyBoolean			Boolean
    6              0.000009 hi def link rubyException		Exception
    6              0.000035 if !exists("ruby_no_identifiers")
    6              0.000014   hi def link rubyIdentifier		Identifier
                            else
                              hi def link rubyIdentifier		NONE
    6              0.000005 endif
    6              0.000010 hi def link rubyClassVariable		rubyIdentifier
    6              0.000008 hi def link rubyConstant		Type
    6              0.000009 hi def link rubyClassName		rubyConstant
    6              0.000009 hi def link rubyModuleName		rubyConstant
    6              0.000010 hi def link rubyGlobalVariable		rubyIdentifier
    6              0.000009 hi def link rubyInstanceVariable	rubyIdentifier
    6              0.000011 hi def link rubyPredefinedIdentifier	rubyIdentifier
    6              0.000011 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    6              0.000010 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    6              0.000009 hi def link rubySymbol			Constant
    6              0.000008 hi def link rubyKeyword			Keyword
                            
    6              0.000009 hi def link rubyOperator		Operator
    6              0.000009 hi def link rubyDefinedOperator		rubyOperator
    6              0.000010 hi def link rubyEnglishBooleanOperator	rubyOperator
    6              0.000028 if exists("ruby_operators")
                              hi def link rubyTernaryOperator	rubyOperator
                              hi def link rubyArithmeticOperator	rubyOperator
                              hi def link rubyComparisonOperator	rubyOperator
                              hi def link rubyBitwiseOperator	rubyOperator
                              hi def link rubyBooleanOperator	rubyOperator
                              hi def link rubyRangeOperator		rubyOperator
                              hi def link rubyAssignmentOperator	rubyOperator
                              hi def link rubyEqualityOperator	rubyOperator
    6              0.000005 endif
                            
    6              0.000020 if exists("ruby_pseudo_operators")
                              hi def link rubyPseudoOperator	Special
                              hi def link rubyDotOperator		rubyPseudoOperator
                              hi def link rubyScopeOperator		rubyPseudoOperator
                              hi def link rubySuperClassOperator	rubyPseudoOperator
                              hi def link rubyEigenClassOperator	rubyPseudoOperator
                              hi def link rubyLambdaOperator	rubyPseudoOperator
                              hi def link rubyDoubleSplatOperator	rubyPseudoOperator
                              hi def link rubySplatOperator		rubyPseudoOperator
                              hi def link rubyProcOperator		rubyPseudoOperator
    6              0.000005 endif
                            
    6              0.000010 hi def link rubyBeginEnd		Statement
    6              0.000009 hi def link rubyEval			Statement
    6              0.000010 hi def link rubyPseudoVariable		Constant
    6              0.000020 hi def link rubyCapitalizedMethod	NONE
                            
    6              0.000009 hi def link rubyComment			Comment
    6              0.000009 hi def link rubyEncoding		Constant
    6              0.000011 hi def link rubyMagicComment		SpecialComment
    6              0.000009 hi def link rubyData			Comment
    6              0.000010 hi def link rubyDataDirective		Delimiter
    6              0.000009 hi def link rubyDocumentation		Comment
    6              0.000010 hi def link rubyTodo			Todo
                            
    6              0.000012 hi def link rubyBackslashEscape		rubyStringEscape
    6              0.000010 hi def link rubyQuoteEscape		rubyStringEscape
    6              0.000010 hi def link rubySpaceEscape		rubyStringEscape
    6              0.000011 hi def link rubyParenthesisEscape	rubyStringEscape
    6              0.000011 hi def link rubyCurlyBraceEscape	rubyStringEscape
    6              0.000010 hi def link rubyAngleBracketEscape	rubyStringEscape
    6              0.000010 hi def link rubySquareBracketEscape	rubyStringEscape
    6              0.000009 hi def link rubyStringEscape		Special
                            
    6              0.000010 hi def link rubyInterpolationDelimiter	Delimiter
    6              0.000009 hi def link rubySharpBang		PreProc
    6              0.000010 hi def link rubyStringDelimiter		Delimiter
    6              0.000011 hi def link rubyHeredocDelimiter	rubyStringDelimiter
    6              0.000011 hi def link rubyPercentRegexpDelimiter	rubyRegexpDelimiter
    6              0.000010 hi def link rubyPercentStringDelimiter	rubyStringDelimiter
    6              0.000010 hi def link rubyPercentSymbolDelimiter	rubySymbolDelimiter
    6              0.000035 hi def link rubyDoubleQuoteSymbolDelimiter rubySymbolDelimiter
    6              0.000011 hi def link rubySingleQuoteSymbolDelimiter rubySymbolDelimiter
    6              0.000010 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    6              0.000010 hi def link rubySymbolDelimiter		rubySymbol
    6              0.000009 hi def link rubyString			String
    6              0.000011 hi def link rubyRegexpEscape		rubyRegexpSpecial
    6              0.000010 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    6              0.000009 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    6              0.000010 hi def link rubyRegexpDot		rubyRegexpCharClass
    6              0.000010 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    6              0.000010 hi def link rubyRegexpIntersection	rubyRegexpSpecial
    6              0.000009 hi def link rubyRegexpSpecial		Special
    6              0.000009 hi def link rubyRegexpComment		Comment
    6              0.000009 hi def link rubyRegexp			rubyString
                            
    6              0.000011 hi def link rubyError			Error
    6              0.000025 if exists("ruby_line_continuation_error")
                              hi def link rubyUselessLineContinuation rubyError
    6              0.000005 endif
    6              0.000012 hi def link rubyGlobalVariableError	rubyError
    6              0.000010 hi def link rubySpaceError		rubyError
                            
                            " Postscript {{{1
    6              0.000021 let b:current_syntax = "ruby"
                            
    6              0.000163 let &cpo = s:cpo_sav
    6              0.000018 unlet! s:cpo_sav
                            
    6              0.000020 delc SynFold
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/markdown.vim
Sourced 5 times
Total time:   0.136233
 Self time:   0.011866

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Markdown
                            " Maintainer:   Tim Pope <https://github.com/tpope/vim-markdown>
                            " Filenames:    *.markdown
                            " Last Change:  2022 Oct 13
                            
    5              0.000070 if exists("b:current_syntax")
                              finish
    5              0.000004 endif
                            
    5              0.000017 if !exists('main_syntax')
    5              0.000026   let main_syntax = 'markdown'
    5              0.000004 endif
                            
    5              0.000026 if has('folding')
    5              0.000024   let s:foldmethod = &l:foldmethod
    5              0.000018   let s:foldtext = &l:foldtext
    5              0.000004 endif
    5              0.000014 let s:iskeyword = &l:iskeyword
                            
    5   0.122060   0.003748 runtime! syntax/html.vim
    5              0.000027 unlet! b:current_syntax
                            
    5              0.000035 if !exists('g:markdown_fenced_languages')
    1              0.000005   let g:markdown_fenced_languages = []
    5              0.000005 endif
    5              0.000020 let s:done_include = {}
    5              0.000049 for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
                              if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                continue
                              endif
                              if s:type =~ '\.'
                                let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
                              endif
                              syn case match
                              exe 'syn include @markdownHighlight_'.tr(s:type,'.','_').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
                              unlet! b:current_syntax
                              let s:done_include[matchstr(s:type,'[^.]*')] = 1
    5              0.000007 endfor
    5              0.000007 unlet! s:type
    5              0.000017 unlet! s:done_include
                            
    5              0.000008 syn spell toplevel
    5              0.000028 if exists('s:foldmethod') && s:foldmethod !=# &l:foldmethod
                              let &l:foldmethod = s:foldmethod
                              unlet s:foldmethod
    5              0.000006 endif
    5              0.000022 if exists('s:foldtext') && s:foldtext !=# &l:foldtext
                              let &l:foldtext = s:foldtext
                              unlet s:foldtext
    5              0.000003 endif
    5              0.000012 if s:iskeyword !=# &l:iskeyword
                              let &l:iskeyword = s:iskeyword
    5              0.000003 endif
    5              0.000006 unlet s:iskeyword
                            
    5              0.000014 if !exists('g:markdown_minlines')
    1              0.000002   let g:markdown_minlines = 50
    5              0.000003 endif
    5              0.000040 execute 'syn sync minlines=' . g:markdown_minlines
    5              0.000009 syn sync linebreaks=1
    5              0.000006 syn case ignore
                            
    5              0.000044 syn match markdownValid '[<>]\c[a-z/$!]\@!' transparent contains=NONE
    5              0.000028 syn match markdownValid '&\%(#\=\w*;\)\@!' transparent contains=NONE
                            
    5              0.000030 syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
                            
    5              0.000041 syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
    5              0.000039 syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError,markdownValid
                            
    5              0.000034 syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
    5              0.000027 syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            
    5              0.000026 syn match markdownHeadingRule "^[=-]\+$" contained
                            
    5              0.000052 syn region markdownH1 matchgroup=markdownH1Delimiter start=" \{,3}#\s"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    5              0.000042 syn region markdownH2 matchgroup=markdownH2Delimiter start=" \{,3}##\s"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    5              0.000189 syn region markdownH3 matchgroup=markdownH3Delimiter start=" \{,3}###\s"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    5              0.000043 syn region markdownH4 matchgroup=markdownH4Delimiter start=" \{,3}####\s"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    5              0.000038 syn region markdownH5 matchgroup=markdownH5Delimiter start=" \{,3}#####\s"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    5              0.000038 syn region markdownH6 matchgroup=markdownH6Delimiter start=" \{,3}######\s" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            
    5              0.000023 syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
                            
    5              0.000040 syn region markdownCodeBlock start="^\n\( \{4,}\|\t\)" end="^\ze \{,3}\S.*$" keepend
                            
                            " TODO: real nesting
    5              0.000031 syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
    5              0.000028 syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
                            
    5              0.000020 syn match markdownRule "\* *\* *\*[ *]*$" contained
    5              0.000017 syn match markdownRule "- *- *-[ -]*$" contained
                            
    5              0.000016 syn match markdownLineBreak " \{2,\}$"
                            
    5              0.000040 syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
    5              0.000020 syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
    5              0.000030 syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
    5              0.000024 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
    5              0.000022 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
    5              0.000021 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
                            
    5              0.000080 syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\_[^][]*\%(\[\_[^][]*\]\_[^][]*\)*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
    5              0.000037 syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
    5              0.000045 syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
    5              0.000040 syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
                            
    5              0.000021 let s:concealends = ''
    5              0.000042 if has('conceal') && get(g:, 'markdown_syntax_conceal', 1) == 1
    5              0.000012   let s:concealends = ' concealends'
    5              0.000005 endif
    5              0.000082 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\*\S\@=" end="\S\@<=\*\|^$" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    5              0.000084 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\w\@<!_\S\@=" end="\S\@<=_\w\@!\|^$" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
    5              0.000078 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\*\*\S\@=" end="\S\@<=\*\*\|^$" skip="\\\*" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    5              0.000074 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\w\@<!__\S\@=" end="\S\@<=__\w\@!\|^$" skip="\\_" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    5              0.000069 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\*\*\*\S\@=" end="\S\@<=\*\*\*\|^$" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    5              0.000070 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\w\@<!___\S\@=" end="\S\@<=___\w\@!\|^$" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
    5              0.000078 exe 'syn region markdownStrike matchgroup=markdownStrikeDelimiter start="\~\~\S\@=" end="\S\@<=\~\~\|^$" contains=markdownLineStart,@Spell' . s:concealends
                            
    5              0.000028 syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
    5              0.000030 syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
    5              0.000049 syn region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(`\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend
    5              0.000035 syn region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(\~\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend
                            
    5              0.000021 syn match markdownFootnote "\[^[^\]]\+\]"
    5              0.000019 syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
                            
    5              0.000017 let s:done_include = {}
    5              0.000022 for s:type in g:markdown_fenced_languages
                              if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                continue
                              endif
                              exe 'syn region markdownHighlight_'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*\z(`\{3,\}\)\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*\z1\ze\s*$" keepend contains=@markdownHighlight_'.tr(matchstr(s:type,'[^=]*$'),'.','_') . s:concealends
                              exe 'syn region markdownHighlight_'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*\z(\~\{3,\}\)\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*\z1\ze\s*$" keepend contains=@markdownHighlight_'.tr(matchstr(s:type,'[^=]*$'),'.','_') . s:concealends
                              let s:done_include[matchstr(s:type,'[^.]*')] = 1
    5              0.000006 endfor
    5              0.000007 unlet! s:type
    5              0.000008 unlet! s:done_include
                            
    5              0.000037 if get(b:, 'markdown_yaml_head', get(g:, 'markdown_yaml_head', main_syntax ==# 'markdown'))
    5   0.009981   0.003925   syn include @markdownYamlTop syntax/yaml.vim
    5              0.000044   unlet! b:current_syntax
    5              0.000094   syn region markdownYamlHead start="\%^---$" end="^\%(---\|\.\.\.\)\s*$" keepend contains=@markdownYamlTop,@Spell
    5              0.000008 endif
                            
    5              0.000029 syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
    5              0.000020 syn match markdownError "\w\@<=_\w\@="
                            
    5              0.000010 hi def link markdownH1                    htmlH1
    5              0.000006 hi def link markdownH2                    htmlH2
    5              0.000005 hi def link markdownH3                    htmlH3
    5              0.000006 hi def link markdownH4                    htmlH4
    5              0.000005 hi def link markdownH5                    htmlH5
    5              0.000005 hi def link markdownH6                    htmlH6
    5              0.000007 hi def link markdownHeadingRule           markdownRule
    5              0.000008 hi def link markdownH1Delimiter           markdownHeadingDelimiter
    5              0.000007 hi def link markdownH2Delimiter           markdownHeadingDelimiter
    5              0.000006 hi def link markdownH3Delimiter           markdownHeadingDelimiter
    5              0.000006 hi def link markdownH4Delimiter           markdownHeadingDelimiter
    5              0.000006 hi def link markdownH5Delimiter           markdownHeadingDelimiter
    5              0.000015 hi def link markdownH6Delimiter           markdownHeadingDelimiter
    5              0.000007 hi def link markdownHeadingDelimiter      Delimiter
    5              0.000007 hi def link markdownOrderedListMarker     markdownListMarker
    5              0.000006 hi def link markdownListMarker            htmlTagName
    5              0.000006 hi def link markdownBlockquote            Comment
    5              0.000006 hi def link markdownRule                  PreProc
                            
    5              0.000007 hi def link markdownFootnote              Typedef
    5              0.000006 hi def link markdownFootnoteDefinition    Typedef
                            
    5              0.000015 hi def link markdownLinkText              htmlLink
    5              0.000006 hi def link markdownIdDeclaration         Typedef
    5              0.000006 hi def link markdownId                    Type
    5              0.000006 hi def link markdownAutomaticLink         markdownUrl
    5              0.000006 hi def link markdownUrl                   Float
    5              0.000006 hi def link markdownUrlTitle              String
    5              0.000007 hi def link markdownIdDelimiter           markdownLinkDelimiter
    5              0.000006 hi def link markdownUrlDelimiter          htmlTag
    5              0.000006 hi def link markdownUrlTitleDelimiter     Delimiter
                            
    5              0.000006 hi def link markdownItalic                htmlItalic
    5              0.000006 hi def link markdownItalicDelimiter       markdownItalic
    5              0.000006 hi def link markdownBold                  htmlBold
    5              0.000012 hi def link markdownBoldDelimiter         markdownBold
    5              0.000007 hi def link markdownBoldItalic            htmlBoldItalic
    5              0.000007 hi def link markdownBoldItalicDelimiter   markdownBoldItalic
    5              0.000006 hi def link markdownStrike                htmlStrike
    5              0.000006 hi def link markdownStrikeDelimiter       markdownStrike
    5              0.000014 hi def link markdownCodeDelimiter         Delimiter
                            
    5              0.000006 hi def link markdownEscape                Special
    5              0.000006 hi def link markdownError                 Error
                            
    5              0.000020 let b:current_syntax = "markdown"
    5              0.000015 if main_syntax ==# 'markdown'
    5              0.000009   unlet main_syntax
    5              0.000004 endif
                            
                            " vim:set sw=2:

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/html.vim
Sourced 5 times
Total time:   0.118268
 Self time:   0.033942

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		HTML
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainers: Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            "			Claudio Fleiner <claudio@fleiner.com>
                            " Last Change:		2022 Nov 18
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    5              0.000074 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
    5              0.000005 endif
                            
    5              0.000068 let s:cpo_save = &cpo
    5              0.000077 set cpo&vim
                            
    5              0.000010 syntax spell toplevel
                            
    5   0.010869   0.003529 syn include @htmlXml syntax/xml.vim
    5              0.000021 unlet b:current_syntax
                            
    5              0.000009 syn case ignore
                            
                            " mark illegal characters
    5              0.000032 syn match htmlError "[<>&]"
                            
                            
                            " tags
    5              0.000046 syn region  htmlString	 contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    5              0.000035 syn region  htmlString	 contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    5              0.000037 syn match   htmlValue	 contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    5              0.000041 syn region  htmlEndTag		   start=+</+	   end=+>+ contains=htmlTagN,htmlTagError
    5              0.000059 syn region  htmlTag		   start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    5              0.000046 syn match   htmlTagN	 contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    5              0.000037 syn match   htmlTagN	 contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    5              0.000020 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    5              0.000022 syn keyword htmlTagName contained address applet area a base basefont
    5              0.000017 syn keyword htmlTagName contained big blockquote br caption center
    5              0.000024 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    5              0.000013 syn keyword htmlTagName contained form hr html img
    5              0.000016 syn keyword htmlTagName contained input isindex kbd li link map menu
    5              0.000026 syn keyword htmlTagName contained meta ol option param pre p samp span
    5              0.000019 syn keyword htmlTagName contained select small strike sub sup
    5              0.000019 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    5              0.000039 syn match   htmlTagName contained "\<\%(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    5              0.000018 syn keyword htmlTagName contained abbr acronym bdo button col colgroup
    5              0.000016 syn keyword htmlTagName contained del fieldset iframe ins label legend
    5              0.000018 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    5              0.000015 syn keyword htmlTagName contained article aside audio bdi canvas data
    5              0.000015 syn keyword htmlTagName contained datalist details dialog embed figcaption
    5              0.000015 syn keyword htmlTagName contained figure footer header hgroup keygen main
    5              0.000015 syn keyword htmlTagName contained mark menuitem meter nav output picture
    5              0.000015 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    5              0.000016 syn keyword htmlTagName contained slot source summary template time track
    5              0.000009 syn keyword htmlTagName contained video wbr
                            
                            " svg and math tags
    5              0.000008 syn keyword htmlMathTagName contained math
    5              0.000010 syn keyword htmlSvgTagName  contained svg
                            
    5              0.000043 syn region  htmlMath start="<math>" end="</math>" contains=@htmlXml transparent keepend
    5              0.000035 syn region  htmlSvg  start="<svg>"  end="</svg>"  contains=@htmlXml transparent keepend
                            
    5              0.000017 syn cluster xmlTagHook	add=htmlMathTagName,htmlSvgTagName
                            
                            " legal arg names
    5              0.000010 syn keyword htmlArg contained action
    5              0.000017 syn keyword htmlArg contained align alink alt archive background bgcolor
    5              0.000012 syn keyword htmlArg contained border bordercolor cellpadding
    5              0.000020 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    5              0.000017 syn keyword htmlArg contained cols colspan content coords enctype face
    5              0.000012 syn keyword htmlArg contained gutter height hspace id
    5              0.000011 syn keyword htmlArg contained link lowsrc marginheight
    5              0.000014 syn keyword htmlArg contained marginwidth maxlength method name prompt
    5              0.000017 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    5              0.000017 syn keyword htmlArg contained size src start target text type url
    5              0.000017 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    5              0.000029 syn match   htmlArg contained "\<\%(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    5              0.000414 exe 'syn match htmlArg contained "\<aria-\%(' . join([
                                \ 'activedescendant', 'atomic', 'autocomplete', 'busy', 'checked', 'colcount',
                                \ 'colindex', 'colspan', 'controls', 'current', 'describedby', 'details',
                                \ 'disabled', 'dropeffect', 'errormessage', 'expanded', 'flowto', 'grabbed',
                                \ 'haspopup', 'hidden', 'invalid', 'keyshortcuts', 'label', 'labelledby', 'level',
                                \ 'live', 'modal', 'multiline', 'multiselectable', 'orientation', 'owns',
                                \ 'placeholder', 'posinset', 'pressed', 'readonly', 'relevant', 'required',
                                \ 'roledescription', 'rowcount', 'rowindex', 'rowspan', 'selected', 'setsize',
                                \ 'sort', 'valuemax', 'valuemin', 'valuenow', 'valuetext'
                                \ ], '\|') . '\)\>"'
    5              0.000013 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    5              0.000035 syn keyword htmlTagName contained frame noframes frameset nobr blink
    5              0.000015 syn keyword htmlTagName contained layer ilayer nolayer spacer
    5              0.000016 syn keyword htmlArg	contained frameborder noresize pagex pagey above below
    5              0.000016 syn keyword htmlArg	contained left top visibility clip id noshade
    5              0.000021 syn match   htmlArg	contained "\<z-index\>"
                            
                            " Microsoft extensions
    5              0.000009 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    5              0.000023 syn match   htmlArg contained "\<\%(accept-charset\|label\)\>"
    5              0.000019 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    5              0.000019 syn keyword htmlArg contained cite classid codetype compact data datetime
    5              0.000017 syn keyword htmlArg contained declare defer dir disabled for frame
    5              0.000014 syn keyword htmlArg contained headers hreflang lang language longdesc
    5              0.000016 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    5              0.000015 syn keyword htmlArg contained rules scheme scope span standby style
    5              0.000013 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    5              0.000014 syn keyword htmlArg contained allow autocapitalize as blocking decoding
    5              0.000013 syn keyword htmlArg contained enterkeyhint imagesizes imagesrcset inert
    5              0.000020 syn keyword htmlArg contained integrity is itemid itemprop itemref itemscope
    5              0.000015 syn keyword htmlArg contained itemtype loading nomodule ping playsinline
    5              0.000014 syn keyword htmlArg contained referrerpolicy slot allowfullscreen async
    5              0.000013 syn keyword htmlArg contained autocomplete autofocus autoplay challenge
    5              0.000016 syn keyword htmlArg contained contenteditable contextmenu controls crossorigin
    5              0.000018 syn keyword htmlArg contained default dirname download draggable dropzone form
    5              0.000015 syn keyword htmlArg contained formaction formenctype formmethod formnovalidate
    5              0.000015 syn keyword htmlArg contained formtarget hidden high icon inputmode keytype
    5              0.000018 syn keyword htmlArg contained kind list loop low max min minlength muted nonce
    5              0.000015 syn keyword htmlArg contained novalidate open optimum pattern placeholder
    5              0.000016 syn keyword htmlArg contained poster preload radiogroup required reversed
    5              0.000017 syn keyword htmlArg contained sandbox spellcheck sizes srcset srcdoc srclang
    5              0.000015 syn keyword htmlArg contained step title translate typemustmatch
    5              0.000040 syn match   htmlArg contained "\<data-\h\%(\w\|[-.]\)*\%(\_s*=\)\@="
                            
                            " special characters
    5              0.000063 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    5              0.000022 if exists("html_wrong_comments")
                              syn region htmlComment	start=+<!--+	end=+--\s*>+	contains=@Spell
    5              0.000014 else
                              " The HTML 5.2 syntax 8.2.4.41: bogus comment is parser error; browser skips until next &gt
    5              0.000035   syn region htmlComment	start=+<!+	end=+>+		contains=htmlCommentError keepend
                              " Idem 8.2.4.42,51: Comment starts with <!-- and ends with -->
                              " Idem 8.2.4.43,44: Except <!--> and <!---> are parser errors
                              " Idem 8.2.4.52: dash-dash-bang (--!>) is error ignored by parser, also closes comment
    5              0.000053   syn region htmlComment matchgroup=htmlComment start=+<!--\%(-\?>\)\@!+	end=+--!\?>+	contains=htmlCommentNested,@htmlPreProc,@Spell keepend
                              " Idem 8.2.4.49: nested comment is parser error, except <!--> is all right
    5              0.000019   syn match htmlCommentNested contained "<!-->\@!"
    5              0.000041   syn match htmlCommentError  contained "[^><!]"
    5              0.000006 endif
    5              0.000029 syn region htmlComment	start=+<!DOCTYPE+	end=+>+ keepend
                            
                            " server-parsed commands
    5              0.000058 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    5              0.000055 syn match htmlPreStmt contained "<!--#\%(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    5              0.000022 syn match htmlPreError contained "<!--#\S*"ms=s+4
    5              0.000032 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    5              0.000042 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    5              0.000017 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    5              0.000045 syn match htmlPreProcAttrName contained "\%(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    5              0.000021 if !exists("html_no_rendering")
                              " rendering
    5              0.000043   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    5              0.000042   syn region htmlStrike start="<del\>" end="</del\_s*>"me=s-1 contains=@htmlTop
    5              0.000033   syn region htmlStrike start="<s\>" end="</s\_s*>"me=s-1 contains=@htmlTop
    5              0.000036   syn region htmlStrike start="<strike\>" end="</strike\_s*>"me=s-1 contains=@htmlTop
                            
    5              0.000039   syn region htmlBold start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    5              0.000041   syn region htmlBold start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    5              0.000038   syn region htmlBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
    5              0.000034   syn region htmlBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    5              0.000034   syn region htmlBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    5              0.000031   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    5              0.000031   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    5              0.000045   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    5              0.000036   syn region htmlUnderline start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    5              0.000034   syn region htmlUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    5              0.000040   syn region htmlUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    5              0.000033   syn region htmlUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    5              0.000038   syn region htmlUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    5              0.000031   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    5              0.000037   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
    5              0.000069   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    5              0.000034   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
                            
    5              0.000036   syn region htmlItalic start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    5              0.000031   syn region htmlItalic start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    5              0.000033   syn region htmlItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    5              0.000039   syn region htmlItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    5              0.000031   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop
    5              0.000034   syn region htmlItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlItalicUnderlineBold
    5              0.000032   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    5              0.000036   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
                            
    5              0.000019   syn match htmlLeadingSpace "^\s\+" contained
    5              0.000066   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a\_s*>"me=s-1 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    5              0.000034   syn region htmlH1 start="<h1\>" end="</h1\_s*>"me=s-1 contains=@htmlTop
    5              0.000032   syn region htmlH2 start="<h2\>" end="</h2\_s*>"me=s-1 contains=@htmlTop
    5              0.000030   syn region htmlH3 start="<h3\>" end="</h3\_s*>"me=s-1 contains=@htmlTop
    5              0.000038   syn region htmlH4 start="<h4\>" end="</h4\_s*>"me=s-1 contains=@htmlTop
    5              0.000029   syn region htmlH5 start="<h5\>" end="</h5\_s*>"me=s-1 contains=@htmlTop
    5              0.000029   syn region htmlH6 start="<h6\>" end="</h6\_s*>"me=s-1 contains=@htmlTop
    5              0.000087   syn region htmlHead start="<head\>" end="</head\_s*>"me=s-1 end="<body\>"me=s-1 end="<h[1-6]\>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    5              0.000050   syn region htmlTitle start="<title\>" end="</title\_s*>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    5              0.000006 endif
                            
    5              0.000012 syn keyword htmlTagName		contained noscript
    5              0.000012 syn keyword htmlSpecialTagName	contained script style
    5              0.000021 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    5   0.006937   0.003858   syn include @htmlJavaScript syntax/javascript.vim
    5              0.000022   unlet b:current_syntax
    5              0.000146   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    5              0.000051   syn region  htmlScriptTag	contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    5              0.000011   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    5              0.000024   if exists("html_extended_events")
                                syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
    5              0.000007   else
    5              0.000035     syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    5              0.000035     syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    5              0.000006   endif
    5              0.000031   syn region htmlEventSQ	contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    5              0.000027   syn region htmlEventDQ	contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    5              0.000009   hi def link htmlEventSQ htmlEvent
    5              0.000006   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    5              0.000031   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    5              0.000005 endif
                            
    5              0.000018 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    5   0.010302   0.003671   syn include @htmlVbScript syntax/vb.vim
    5              0.000024   unlet b:current_syntax
    5              0.000095   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    5              0.000007 endif
                            
    5              0.000021 syn cluster htmlJavaScript	add=@htmlPreproc
                            
    5              0.000024 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    5              0.000013   syn keyword htmlArg		contained media
    5   0.070895   0.003618   syn include @htmlCss syntax/css.vim
    5              0.000027   unlet b:current_syntax
    5              0.000080   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    5              0.000026   syn match htmlCssStyleComment contained "\%(<!--\|-->\)"
    5              0.010133   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    5              0.000017   hi def link htmlStyleArg htmlString
    5              0.000005 endif
                            
    5              0.000018 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
    5              0.000005 endif
                            
                            " Folding
                            " Originally by Ingo Karkat and Marcus Zanona
    5              0.000039 if get(g:, "html_syntax_folding", 0)
                              syn region htmlFold start="<\z(\<\%(area\|base\|br\|col\|command\|embed\|hr\|img\|input\|keygen\|link\|meta\|param\|source\|track\|wbr\>\)\@![a-z-]\+\>\)\%(\_s*\_[^/]\?>\|\_s\_[^>]*\_[^>/]>\)" end="</\z1\_s*>" fold transparent keepend extend containedin=htmlHead,htmlH\d
                              " fold comments (the real ones and the old Netscape ones)
                              if exists("html_wrong_comments")
                                syn region htmlComment start=+<!--+ end=+--\s*>\%(\n\s*<!--\)\@!+ contains=@Spell fold
                              endif
    5              0.000004 endif
                            
                            " The default highlighting.
    5              0.000009 hi def link htmlTag			Function
    5              0.000006 hi def link htmlEndTag			Identifier
    5              0.000005 hi def link htmlArg			Type
    5              0.000007 hi def link htmlTagName			htmlStatement
    5              0.000006 hi def link htmlSpecialTagName		Exception
    5              0.000006 hi def link htmlMathTagName		htmlTagName
    5              0.000006 hi def link htmlSvgTagName		htmlTagName
    5              0.000005 hi def link htmlValue			String
    5              0.000006 hi def link htmlSpecialChar		Special
                            
    5              0.000020 if !exists("html_no_rendering")
    5              0.000008   hi def link htmlH1			  Title
    5              0.000007   hi def link htmlH2			  htmlH1
    5              0.000005   hi def link htmlH3			  htmlH2
    5              0.000005   hi def link htmlH4			  htmlH3
    5              0.000005   hi def link htmlH5			  htmlH4
    5              0.000005   hi def link htmlH6			  htmlH5
    5              0.000006   hi def link htmlHead			  PreProc
    5              0.000006   hi def link htmlTitle			  Title
    5              0.000008   hi def link htmlBoldItalicUnderline	  htmlBoldUnderlineItalic
    5              0.000007   hi def link htmlUnderlineBold		  htmlBoldUnderline
    5              0.000007   hi def link htmlUnderlineItalicBold	  htmlBoldUnderlineItalic
    5              0.000007   hi def link htmlUnderlineBoldItalic	  htmlBoldUnderlineItalic
    5              0.000007   hi def link htmlItalicUnderline	  htmlUnderlineItalic
    5              0.000006   hi def link htmlItalicBold		  htmlBoldItalic
    5              0.000007   hi def link htmlItalicBoldUnderline	  htmlBoldUnderlineItalic
    5              0.000007   hi def link htmlItalicUnderlineBold	  htmlBoldUnderlineItalic
    5              0.000006   hi def link htmlLink			  Underlined
    5              0.000006   hi def link htmlLeadingSpace		  None
    5              0.000013   if !exists("html_my_rendering")
    5              0.000012     hi def htmlBold		   term=bold cterm=bold gui=bold
    5              0.000015     hi def htmlBoldUnderline	   term=bold,underline cterm=bold,underline gui=bold,underline
    5              0.000009     hi def htmlBoldItalic	   term=bold,italic cterm=bold,italic gui=bold,italic
    5              0.000011     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    5              0.000008     hi def htmlUnderline	   term=underline cterm=underline gui=underline
    5              0.000009     hi def htmlUnderlineItalic	   term=italic,underline cterm=italic,underline gui=italic,underline
    5              0.000007     hi def htmlItalic		   term=italic cterm=italic gui=italic
    5              0.000019     if v:version > 800 || v:version == 800 && has("patch1038")
    5              0.000011 	hi def htmlStrike	       term=strikethrough cterm=strikethrough gui=strikethrough
                                else
                            	hi def htmlStrike	       term=underline cterm=underline gui=underline
    5              0.000004     endif
    5              0.000003   endif
    5              0.000003 endif
                            
    5              0.000006 hi def link htmlPreStmt		   PreProc
    5              0.000006 hi def link htmlPreError	   Error
    5              0.000005 hi def link htmlPreProc		   PreProc
    5              0.000005 hi def link htmlPreAttr		   String
    5              0.000006 hi def link htmlPreProcAttrName    PreProc
    5              0.000005 hi def link htmlPreProcAttrError   Error
    5              0.000005 hi def link htmlString		   String
    5              0.000005 hi def link htmlStatement	   Statement
    5              0.000005 hi def link htmlComment		   Comment
    5              0.000006 hi def link htmlCommentNested	   htmlError
    5              0.000005 hi def link htmlCommentError	   htmlError
    5              0.000005 hi def link htmlTagError	   htmlError
    5              0.000014 hi def link htmlEvent		   javaScript
    5              0.000005 hi def link htmlError		   Error
                            
    5              0.000005 hi def link javaScript		   Special
    5              0.000006 hi def link javaScriptExpression   javaScript
    5              0.000006 hi def link htmlCssStyleComment    Comment
    5              0.000005 hi def link htmlCssDefinition	   Special
                            
    5              0.000016 let b:current_syntax = "html"
                            
    5              0.000010 if main_syntax == 'html'
                              unlet main_syntax
    5              0.000003 endif
                            
    5              0.000076 let &cpo = s:cpo_save
    5              0.000011 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/xml.vim
Sourced 5 times
Total time:   0.007322
 Self time:   0.004496

count  total (s)   self (s)
                            " Vim syntax file
                            " Language: XML
                            " Maintainer: Christian Brabandt <cb@256bit.org>
                            " Repository: https://github.com/chrisbra/vim-xml-ftplugin
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Author: Paul Siegmann <pauls@euronet.nl>
                            " Last Changed:	Nov 03, 2019
                            " Filenames:	*.xml
                            " Last Change:
                            " 20190923 - Fix xmlEndTag to match xmlTag (vim/vim#884)
                            " 20190924 - Fix xmlAttribute property (amadeus/vim-xml@d8ce1c946)
                            " 20191103 - Enable spell checking globally
                            " 20210428 - Improve syntax synchronizing
                            
                            " CONFIGURATION:
                            "   syntax folding can be turned on by
                            "
                            "      let g:xml_syntax_folding = 1
                            "
                            "   before the syntax file gets loaded (e.g. in ~/.vimrc).
                            "   This might slow down syntax highlighting significantly,
                            "   especially for large files.
                            "
                            " CREDITS:
                            "   The original version was derived by Paul Siegmann from
                            "   Claudio Fleiner's html.vim.
                            "
                            " REFERENCES:
                            "   [1] http://www.w3.org/TR/2000/REC-xml-20001006
                            "   [2] http://www.w3.org/XML/1998/06/xmlspec-report-19980910.htm
                            "
                            "   as <hirauchi@kiwi.ne.jp> pointed out according to reference [1]
                            "
                            "   2.3 Common Syntactic Constructs
                            "   [4]    NameChar    ::=    Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender
                            "   [5]    Name        ::=    (Letter | '_' | ':') (NameChar)*
                            "
                            " NOTE:
                            "   1) empty tag delimiters "/>" inside attribute values (strings)
                            "      confuse syntax highlighting.
                            "   2) for large files, folding can be pretty slow, especially when
                            "      loading a file the first time and viewoptions contains 'folds'
                            "      so that folds of previous sessions are applied.
                            "      Don't use 'foldmethod=syntax' in this case.
                            
                            
                            " Quit when a syntax file was already loaded
    5              0.000055 if exists("b:current_syntax")
                                finish
    5              0.000005 endif
                            
    5              0.000060 let s:xml_cpo_save = &cpo
    5              0.000059 set cpo&vim
                            
    5              0.000008 syn case match
                            
                            " Allow spell checking in tag values,
                            " there is no syntax region for that,
                            " so enable spell checking in top-level elements
                            " <tag>This text is spell checked</tag>
    5              0.000006 syn spell toplevel
                            
                            " mark illegal characters
    5              0.000042 syn match xmlError "[<&]"
                            
                            " strings (inside tags) aka VALUES
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "                      ^^^^^^^
    5              0.000061 syn region  xmlString contained start=+"+ end=+"+ contains=xmlEntity,@Spell display
    5              0.000036 syn region  xmlString contained start=+'+ end=+'+ contains=xmlEntity,@Spell display
                            
                            
                            " punctuation (within attributes) e.g. <tag xml:foo.attribute ...>
                            "                                              ^   ^
                            " syn match   xmlAttribPunct +[-:._]+ contained display
    5              0.000019 syn match   xmlAttribPunct +[:.]+ contained display
                            
                            " no highlighting for xmlEqual (xmlEqual has no highlighting group)
    5              0.000018 syn match   xmlEqual +=+ display
                            
                            
                            " attribute, everything before the '='
                            "
                            " PROVIDES: @xmlAttribHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "      ^^^^^^^^^^^^^
                            "
    5              0.000069 syn match   xmlAttrib
                                \ +[-'"<]\@1<!\<[a-zA-Z:_][-.0-9a-zA-Z:_]*\>\%(['"]\@!\|$\)+
                                \ contained
                                \ contains=xmlAttribPunct,@xmlAttribHook
                                \ display
                            
                            
                            " namespace spec
                            "
                            " PROVIDES: @xmlNamespaceHook
                            "
                            " EXAMPLE:
                            "
                            " <xsl:for-each select = "lola">
                            "  ^^^
                            "
    5              0.000023 if exists("g:xml_namespace_transparent")
                            syn match   xmlNamespace
                                \ +\(<\|</\)\@2<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ transparent
                                \ display
    5              0.000007 else
    5              0.000040 syn match   xmlNamespace
                                \ +\(<\|</\)\@2<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ display
    5              0.000012 endif
                            
                            
                            " tag name
                            "
                            " PROVIDES: @xmlTagHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "  ^^^
                            "
    5              0.000046 syn match   xmlTagName
                                \ +\%(<\|</\)\@2<=[^ /!?<>"']\++
                                \ contained
                                \ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                                \ display
                            
                            
    5              0.000018 if exists('g:xml_syntax_folding')
                            
                                " start tag
                                " use matchgroup=xmlTag to skip over the leading '<'
                                "
                                " PROVIDES: @xmlStartTagHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                " s^^^^^^^^^^^^^^^e
                                "
                                syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contained
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
                            
                                " highlight the end tag
                                "
                                " PROVIDES: @xmlTagHook
                                " (should we provide a separate @xmlEndTagHook ?)
                                "
                                " EXAMPLE:
                                "
                                " </tag>
                                " ^^^^^^
                                "
                                syn region   xmlEndTag
                            	\ matchgroup=xmlTag start=+</[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contained
                            	\ contains=xmlTagName,xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
                                " tag elements with syntax-folding.
                                " NOTE: NO HIGHLIGHTING -- highlighting is done by contained elements
                                "
                                " PROVIDES: @xmlRegionHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                "   <!-- comment -->
                                "   <another.tag></another.tag>
                                "   <empty.tag/>
                                "   some data
                                " </tag>
                                "
                                syn region   xmlRegion
                            	\ start=+<\z([^ /!?<>"']\+\)+
                            	\ skip=+<!--\_.\{-}-->+
                            	\ end=+</\z1\_\s\{-}>+
                            	\ end=+/>+
                            	\ fold
                            	\ contains=xmlTag,xmlEndTag,xmlCdata,xmlRegion,xmlComment,xmlEntity,xmlProcessing,@xmlRegionHook,@Spell
                            	\ keepend
                            	\ extend
                            
    5              0.000005 else
                            
                                " no syntax folding:
                                " - contained attribute removed
                                " - xmlRegion not defined
                                "
    5              0.000064     syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
    5              0.000050     syn region   xmlEndTag
                            	\ matchgroup=xmlTag start=+</[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contains=xmlTagName,xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
    5              0.000005 endif
                            
                            
                            " &entities; compare with dtd
    5              0.000026 syn match   xmlEntity                 "&[^; \t]*;" contains=xmlEntityPunct
    5              0.000016 syn match   xmlEntityPunct  contained "[&.;]"
                            
    5              0.000019 if exists('g:xml_syntax_folding')
                            
                                " The real comments (this implements the comments as defined by xml,
                                " but not all xml pages actually conform to it. Errors are flagged.
                                syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            	\ fold
                            
    5              0.000005 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
    5              0.000036     syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            
    5              0.000004 endif
                            
    5              0.000019 syn match xmlCommentStart   contained "<!" nextgroup=xmlCommentPart
    5              0.000016 syn keyword xmlTodo         contained TODO FIXME XXX
    5              0.000015 syn match   xmlCommentError contained "[^><!]"
    5              0.000048 syn region  xmlCommentPart
                                \ start=+--+
                                \ end=+--+
                                \ contained
                                \ contains=xmlTodo,@xmlCommentHook,@Spell
                            
                            
                            " CData sections
                            "
                            " PROVIDES: @xmlCdataHook
                            "
    5              0.000061 syn region    xmlCdata
                                \ start=+<!\[CDATA\[+
                                \ end=+]]>+
                                \ contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook,@Spell
                                \ keepend
                                \ extend
                            
                            " using the following line instead leads to corrupt folding at CDATA regions
                            " syn match    xmlCdata      +<!\[CDATA\[\_.\{-}]]>+  contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook
    5              0.000026 syn match    xmlCdataStart +<!\[CDATA\[+  contained contains=xmlCdataCdata
    5              0.000013 syn keyword  xmlCdataCdata CDATA          contained
    5              0.000016 syn match    xmlCdataEnd   +]]>+          contained
                            
                            
                            " Processing instructions
                            " This allows "?>" inside strings -- good idea?
    5              0.000040 syn region  xmlProcessing matchgroup=xmlProcessingDelim start="<?" end="?>" contains=xmlAttrib,xmlEqual,xmlString
                            
                            
    5              0.000019 if exists('g:xml_syntax_folding')
                            
                                " DTD -- we use dtd.vim here
                                syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ fold
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
    5              0.000006 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
    5              0.000047     syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
                            
    5              0.000005 endif
                            
    5              0.000013 syn keyword xmlDocTypeKeyword contained DOCTYPE PUBLIC SYSTEM
    5              0.000035 syn region  xmlInlineDTD contained matchgroup=xmlDocTypeDecl start="\[" end="]" contains=@xmlDTD
    5   0.003797   0.000971 syn include @xmlDTD <sfile>:p:h/dtd.vim
    5              0.000020 unlet b:current_syntax
                            
                            
                            " synchronizing
                            
    5              0.000035 syn sync match xmlSyncComment grouphere xmlComment +<!--+
    5              0.000023 syn sync match xmlSyncComment groupthere NONE +-->+
                            
                            " The following is slow on large documents (and the doctype is optional
                            " syn sync match xmlSyncDT grouphere  xmlDocType +\_.\(<!DOCTYPE\)\@=+
                            " syn sync match xmlSyncDT groupthere  NONE       +]>+
                            
    5              0.000031 if exists('g:xml_syntax_folding')
                                syn sync match xmlSync grouphere   xmlRegion  +\_.\(<[^ /!?<>"']\+\)\@=+
                                " syn sync match xmlSync grouphere  xmlRegion "<[^ /!?<>"']*>"
                                syn sync match xmlSync groupthere  xmlRegion  +</[^ /!?<>"']\+>+
    5              0.000005 endif
                            
    5              0.000009 syn sync minlines=100 maxlines=200
                            
                            
                            " The default highlighting.
    5              0.000008 hi def link xmlTodo		Todo
    5              0.000006 hi def link xmlTag		Function
    5              0.000006 hi def link xmlTagName		Function
    5              0.000006 hi def link xmlEndTag		Identifier
    5              0.000016 if !exists("g:xml_namespace_transparent")
    5              0.000008     hi def link xmlNamespace	Tag
    5              0.000003 endif
    5              0.000006 hi def link xmlEntity		Statement
    5              0.000006 hi def link xmlEntityPunct	Type
                            
    5              0.000005 hi def link xmlAttribPunct	Comment
    5              0.000005 hi def link xmlAttrib		Type
                            
    5              0.000005 hi def link xmlString		String
    5              0.000005 hi def link xmlComment		Comment
    5              0.000006 hi def link xmlCommentStart	xmlComment
    5              0.000005 hi def link xmlCommentPart	Comment
    5              0.000013 hi def link xmlCommentError	Error
    5              0.000005 hi def link xmlError		Error
                            
    5              0.000006 hi def link xmlProcessingDelim	Comment
    5              0.000006 hi def link xmlProcessing	Type
                            
    5              0.000005 hi def link xmlCdata		String
    5              0.000006 hi def link xmlCdataCdata	Statement
    5              0.000005 hi def link xmlCdataStart	Type
    5              0.000005 hi def link xmlCdataEnd		Type
                            
    5              0.000006 hi def link xmlDocTypeDecl	Function
    5              0.000006 hi def link xmlDocTypeKeyword	Statement
    5              0.000005 hi def link xmlInlineDTD	Function
                            
    5              0.000012 let b:current_syntax = "xml"
                            
    5              0.000060 let &cpo = s:xml_cpo_save
    5              0.000010 unlet s:xml_cpo_save
                            
                            " vim: ts=4

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/dtd.vim
Sourced 5 times
Total time:   0.002793
 Self time:   0.002793

count  total (s)   self (s)
                            " Vim syntax file
                            " Language: DTD (Document Type Definition for XML)
                            " Maintainer: Christian Brabandt <cb@256bit.org>
                            " Repository: https://github.com/chrisbra/vim-xml-ftplugin
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Author: Daniel Amyot <damyot@site.uottawa.ca>
                            " Last Changed:	Sept 24, 2019
                            " Filenames: *.dtd
                            "
                            " REFERENCES:
                            "   http://www.w3.org/TR/html40/
                            "   http://www.w3.org/TR/NOTE-html-970421
                            "
                            " TODO:
                            "   - improve synchronizing.
                            
    5              0.000072 if exists("b:current_syntax")
                                finish
    5              0.000005 endif
    5              0.000071 let s:dtd_cpo_save = &cpo
    5              0.000070 set cpo&vim
                            
    5              0.000018 if !exists("dtd_ignore_case")
                                " I prefer having the case takes into consideration.
    5              0.000008     syn case match
                            else
                                syn case ignore
    5              0.000003 endif
                            
                            
                            " the following line makes the opening <! and
                            " closing > highlighted using 'dtdFunction'.
                            "
                            " PROVIDES: @dtdTagHook
                            "
    5              0.000097 syn region dtdTag matchgroup=dtdFunction
                                \ start=+<!+ end=+>+ matchgroup=NONE
                                \ contains=dtdTag,dtdTagName,dtdError,dtdComment,dtdString,dtdAttrType,dtdAttrDef,dtdEnum,dtdParamEntityInst,dtdParamEntityDecl,dtdCard,@dtdTagHook
                            
    5              0.000017 if !exists("dtd_no_tag_errors")
                                " mark everything as an error which starts with a <!
                                " and is not overridden later. If this is annoying,
                                " it can be switched off by setting the variable
                                " dtd_no_tag_errors.
    5              0.000028     syn region dtdError contained start=+<!+lc=2 end=+>+
    5              0.000005 endif
                            
                            " if this is a html like comment highlight also
                            " the opening <! and the closing > as Comment.
    5              0.000045 syn region dtdComment		start=+<![ \t]*--+ end=+-->+ contains=dtdTodo,@Spell
                            
                            
                            " proper DTD comment
    5              0.000031 syn region dtdComment contained start=+--+ end=+--+ contains=dtdTodo,@Spell
                            
                            
                            " Start tags (keywords). This is contained in dtdFunction.
                            " Note that everything not contained here will be marked
                            " as error.
    5              0.000045 syn match dtdTagName contained +<!\(ATTLIST\|DOCTYPE\|ELEMENT\|ENTITY\|NOTATION\|SHORTREF\|USEMAP\|\[\)+lc=2,hs=s+2
                            
                            
                            " wildcards and operators
    5              0.000014 syn match  dtdCard contained "|"
    5              0.000012 syn match  dtdCard contained ","
                            " evenutally overridden by dtdEntity
    5              0.000012 syn match  dtdCard contained "&"
    5              0.000012 syn match  dtdCard contained "?"
    5              0.000019 syn match  dtdCard contained "\*"
    5              0.000013 syn match  dtdCard contained "+"
                            
                            " ...and finally, special cases.
    5              0.000018 syn match  dtdCard      "ANY"
    5              0.000017 syn match  dtdCard      "EMPTY"
                            
    5              0.000018 if !exists("dtd_no_param_entities")
                            
                                " highlight parameter entity declarations
                                " and instances. Note that the closing `;'
                                " is optional.
                            
                                " instances
    5              0.000076     syn region dtdParamEntityInst oneline matchgroup=dtdParamEntityPunct
                            	\ start="%[-_a-zA-Z0-9.]\+"he=s+1,rs=s+1
                            	\ skip=+[-_a-zA-Z0-9.]+
                            	\ end=";\|\>"
                            	\ matchgroup=NONE contains=dtdParamEntityPunct
    5              0.000016     syn match  dtdParamEntityPunct contained "\."
                            
                                " declarations
                                " syn region dtdParamEntityDecl oneline matchgroup=dtdParamEntityDPunct start=+<!ENTITY % +lc=8 skip=+[-_a-zA-Z0-9.]+ matchgroup=NONE end="\>" contains=dtdParamEntityDPunct
    5              0.000039     syn match dtdParamEntityDecl +<!ENTITY % [-_a-zA-Z0-9.]*+lc=8 contains=dtdParamEntityDPunct
    5              0.000019     syn match  dtdParamEntityDPunct contained "%\|\."
                            
    5              0.000004 endif
                            
                            " &entities; compare with xml
    5              0.000027 syn match   dtdEntity		      "&[^; \t]*;" contains=dtdEntityPunct
    5              0.000016 syn match   dtdEntityPunct  contained "[&.;]"
                            
                            " Strings are between quotes
    5              0.000051 syn region dtdString    start=+"+ skip=+\\\\\|\\"+  end=+"+ contains=dtdAttrDef,dtdAttrType,dtdParamEntityInst,dtdEntity,dtdCard
    5              0.000045 syn region dtdString    start=+'+ skip=+\\\\\|\\'+  end=+'+ contains=dtdAttrDef,dtdAttrType,dtdParamEntityInst,dtdEntity,dtdCard
                            
                            " Enumeration of elements or data between parenthesis
                            "
                            " PROVIDES: @dtdEnumHook
                            "
    5              0.000047 syn region dtdEnum matchgroup=dtdType start="(" end=")" matchgroup=NONE contains=dtdEnum,dtdParamEntityInst,dtdCard,@dtdEnumHook
                            
                            "Attribute types
    5              0.000020 syn keyword dtdAttrType NMTOKEN  ENTITIES  NMTOKENS  ID  CDATA
    5              0.000012 syn keyword dtdAttrType IDREF  IDREFS
                            " ENTITY has to treated special for not overriding <!ENTITY
    5              0.000024 syn match   dtdAttrType +[^!]\<ENTITY+
                            
                            "Attribute Definitions
    5              0.000020 syn match  dtdAttrDef   "#REQUIRED"
    5              0.000033 syn match  dtdAttrDef   "#IMPLIED"
    5              0.000018 syn match  dtdAttrDef   "#FIXED"
                            
    5              0.000005 syn case match
                            " define some common keywords to mark TODO
                            " and important sections inside comments.
    5              0.000011 syn keyword dtdTodo contained TODO FIXME XXX
                            
    5              0.000008 syn sync lines=250
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            " The default highlighting.
    5              0.000012 hi def link dtdFunction		Function
    5              0.000006 hi def link dtdTag		Normal
    5              0.000006 hi def link dtdType		Type
    5              0.000006 hi def link dtdAttrType		dtdType
    5              0.000005 hi def link dtdAttrDef		dtdType
    5              0.000007 hi def link dtdConstant		Constant
    5              0.000006 hi def link dtdString		dtdConstant
    5              0.000005 hi def link dtdEnum		dtdConstant
    5              0.000005 hi def link dtdCard		dtdFunction
                            
    5              0.000006 hi def link dtdEntity		Statement
    5              0.000006 hi def link dtdEntityPunct	dtdType
    5              0.000006 hi def link dtdParamEntityInst	dtdConstant
    5              0.000006 hi def link dtdParamEntityPunct	dtdType
    5              0.000006 hi def link dtdParamEntityDecl	dtdType
    5              0.000006 hi def link dtdParamEntityDPunct dtdComment
                            
    5              0.000006 hi def link dtdComment		Comment
    5              0.000006 hi def link dtdTagName		Statement
    5              0.000006 hi def link dtdError		Error
    5              0.000005 hi def link dtdTodo		Todo
                            
                            
    5              0.000079 let &cpo = s:dtd_cpo_save
    5              0.000014 unlet s:dtd_cpo_save
                            
    5              0.000013 let b:current_syntax = "dtd"
                            
                            " vim: ts=8

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/javascript.vim
Sourced 5 times
Total time:   0.003055
 Self time:   0.003055

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2022 Jun 09
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    5              0.000050 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
    5              0.000026 elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
    5              0.000004 endif
                            
    5              0.000062 let s:cpo_save = &cpo
    5              0.000054 set cpo&vim
                            
                            
    5              0.000025 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    5              0.000039 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    5              0.000038 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    5              0.000045 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    5              0.000024 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    5              0.000049 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    5              0.000044 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
    5              0.000044 syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
    5              0.000033 syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
                            " number handling by Christopher Leonard chris.j.leonard@gmx.com
    5              0.000019 syn match   javaScriptSpecialCharacter "'\\.'"
    5              0.000032 syn match   javaScriptNumber           "\<0[bB][0-1]\+\(_[0-1]\+\)*\>"
    5              0.000028 syn match   javaScriptNumber           "\<0[oO][0-7]\+\(_[0-7]\+\)*\>"
    5              0.000030 syn match   javaScriptNumber           "\<0\([0-7]\+\(_[0-7]\+\)*\)\?\>"
    5              0.000031 syn match   javaScriptNumber           "\<0[xX][0-9a-fA-F]\+\(_[0-9a-fA-F]\+\)*\>"
    5              0.000028 syn match   javaScriptNumber           "\<\d\+\(_\d\+\)*[eE][+-]\?\d\+\>"
    5              0.000041 syn match   javaScriptNumber           "\<[1-9]\d*\(_\d\+\)*\(\.\(\d\+\(_\d\+\)*\([eE][+-]\?\d\+\)\?\)\?\)\?\>"
    5              0.000037 syn match   javaScriptNumber           "\<\(\d\+\(_\d\+\)*\)\?\.\d\+\(_\d\+\)*\([eE][+-]\?\d\+\)\?\>"
    5              0.000037 syn match   javaScriptNumber           "\<\d\+\(_\d\+\)*\.\(\d\+\(_\d\+\)*\([eE][+-]\?\d\+\)\?\)\?\>"
    5              0.000115 syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
    5              0.000020 syn keyword javaScriptConditional	if else switch
    5              0.000018 syn keyword javaScriptRepeat		while for do in
    5              0.000014 syn keyword javaScriptBranch		break continue
    5              0.000019 syn keyword javaScriptOperator		new delete instanceof typeof
    5              0.000026 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    5              0.000016 syn keyword javaScriptStatement		return with await
    5              0.000015 syn keyword javaScriptBoolean		true false
    5              0.000014 syn keyword javaScriptNull		null undefined
    5              0.000017 syn keyword javaScriptIdentifier	arguments this var let
    5              0.000014 syn keyword javaScriptLabel		case default
    5              0.000017 syn keyword javaScriptException		try catch finally throw
    5              0.000017 syn keyword javaScriptMessage		alert confirm prompt status
    5              0.000016 syn keyword javaScriptGlobal		self window top parent
    5              0.000016 syn keyword javaScriptMember		document event location 
    5              0.000018 syn keyword javaScriptDeprecated	escape unescape
    5              0.000065 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile async
                            
    5              0.000029 syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
    5              0.000020 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
    5              0.000004 else
    5              0.000017     syn keyword javaScriptFunction	function
    5              0.000025     syn match	javaScriptBraces	   "[{}\[\]]"
    5              0.000020     syn match	javaScriptParens	   "[()]"
    5              0.000005 endif
                            
    5              0.000013 if main_syntax == "javascript"
                              syn sync fromstart
                              syn sync maxlines=100
                            
                              syn sync ccomment javaScriptComment
    5              0.000004 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
    5              0.000010 hi def link javaScriptComment		Comment
    5              0.000006 hi def link javaScriptLineComment		Comment
    5              0.000006 hi def link javaScriptCommentTodo		Todo
    5              0.000006 hi def link javaScriptSpecial		Special
    5              0.000006 hi def link javaScriptStringS		String
    5              0.000006 hi def link javaScriptStringD		String
    5              0.000005 hi def link javaScriptStringT		String
    5              0.000007 hi def link javaScriptCharacter		Character
    5              0.000007 hi def link javaScriptSpecialCharacter	javaScriptSpecial
    5              0.000006 hi def link javaScriptNumber		javaScriptValue
    5              0.000006 hi def link javaScriptConditional		Conditional
    5              0.000006 hi def link javaScriptRepeat		Repeat
    5              0.000006 hi def link javaScriptBranch		Conditional
    5              0.000006 hi def link javaScriptOperator		Operator
    5              0.000005 hi def link javaScriptType			Type
    5              0.000006 hi def link javaScriptStatement		Statement
    5              0.000006 hi def link javaScriptFunction		Function
    5              0.000005 hi def link javaScriptBraces		Function
    5              0.000006 hi def link javaScriptError		Error
    5              0.000007 hi def link javaScrParenError		javaScriptError
    5              0.000006 hi def link javaScriptNull			Keyword
    5              0.000005 hi def link javaScriptBoolean		Boolean
    5              0.000006 hi def link javaScriptRegexpString		String
                            
    5              0.000006 hi def link javaScriptIdentifier		Identifier
    5              0.000005 hi def link javaScriptLabel		Label
    5              0.000006 hi def link javaScriptException		Exception
    5              0.000005 hi def link javaScriptMessage		Keyword
    5              0.000005 hi def link javaScriptGlobal		Keyword
    5              0.000005 hi def link javaScriptMember		Keyword
    5              0.000006 hi def link javaScriptDeprecated		Exception 
    5              0.000005 hi def link javaScriptReserved		Keyword
    5              0.000006 hi def link javaScriptDebug		Debug
    5              0.000006 hi def link javaScriptConstant		Label
    5              0.000005 hi def link javaScriptEmbed		Special
                            
                            
                            
    5              0.000015 let b:current_syntax = "javascript"
    5              0.000010 if main_syntax == 'javascript'
                              unlet main_syntax
    5              0.000003 endif
    5              0.000065 let &cpo = s:cpo_save
    5              0.000011 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/vb.vim
Sourced 5 times
Total time:   0.006603
 Self time:   0.006603

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Visual Basic
                            " Maintainer:   Doug Kearns <dougkearns@gmail.com>
                            " Former Maintainer:    Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:    Robert M. Cortopassi <cortopar@mindspring.com>
                            "       (tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2021 Nov 26  Incorporated additions from Doug Kearns
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    5              0.000043 if exists("b:current_syntax")
                                    finish
    5              0.000005 endif
                            
                            " VB is case insensitive
    5              0.000009 syn case ignore
                            
    5              0.000035 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    5              0.000027 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    5              0.000031 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    5              0.000037 syn match vbOperator "[()+.,\-/*=&]"
    5              0.000019 syn match vbOperator "[<>]=\="
    5              0.000016 syn match vbOperator "<>"
    5              0.000018 syn match vbOperator "\s\+_$"
                            
    5              0.000014 syn keyword vbBoolean  True False
    5              0.000013 syn keyword vbConst Null Nothing
                            
    5              0.000017 syn keyword vbRepeat Do For ForEach Loop Next
    5              0.000015 syn keyword vbRepeat Step To Until Wend While
                            
    5              0.000015 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    5              0.000015 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    5              0.000013 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    5              0.000013 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    5              0.000012 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    5              0.000018 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    5              0.000014 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    5              0.000012 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    5              0.000014 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    5              0.000013 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    5              0.000013 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    5              0.000012 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    5              0.000013 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    5              0.000012 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    5              0.000013 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    5              0.000015 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    5              0.000015 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    5              0.000017 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    5              0.000015 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    5              0.000013 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    5              0.000015 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    5              0.000013 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    5              0.000013 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    5              0.000013 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    5              0.000013 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    5              0.000014 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    5              0.000014 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    5              0.000013 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    5              0.000012 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    5              0.000013 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    5              0.000015 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    5              0.000016 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    5              0.000017 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    5              0.000015 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    5              0.000015 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    5              0.000014 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    5              0.000012 syn keyword vbEvents IniProperties InitProperties Initialize
    5              0.000013 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    5              0.000012 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    5              0.000016 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    5              0.000013 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    5              0.000013 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    5              0.000014 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    5              0.000015 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    5              0.000016 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    5              0.000016 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    5              0.000015 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    5              0.000013 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    5              0.000013 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    5              0.000014 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    5              0.000013 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    5              0.000013 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    5              0.000013 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    5              0.000013 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    5              0.000013 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    5              0.000011 syn keyword vbEvents RepeatedControlUnloaded Reposition
    5              0.000013 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    5              0.000013 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    5              0.000013 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    5              0.000016 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    5              0.000013 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    5              0.000015 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    5              0.000030 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    5              0.000017 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    5              0.000014 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    5              0.000012 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    5              0.000013 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    5              0.000015 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    5              0.000020 syn keyword vbEvents UserEvent Validate ValidationError
    5              0.000014 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    5              0.000013 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    5              0.000009 syn keyword vbEvents WriteProperties
                            
                            
    5              0.000021 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    5              0.000021 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    5              0.000019 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    5              0.000019 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    5              0.000017 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    5              0.000019 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    5              0.000016 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    5              0.000014 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    5              0.000015 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    5              0.000122 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    5              0.000020 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    5              0.000017 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    5              0.000016 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    5              0.000018 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    5              0.000015 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    5              0.000017 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    5              0.000020 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    5              0.000017 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    5              0.000021 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    5              0.000018 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    5              0.000018 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    5              0.000017 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    5              0.000016 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    5              0.000009 syn keyword vbFunction Year
                            
    5              0.000017 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    5              0.000014 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    5              0.000015 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    5              0.000014 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    5              0.000016 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    5              0.000014 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    5              0.000015 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    5              0.000016 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    5              0.000016 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    5              0.000034 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    5              0.000017 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    5              0.000017 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    5              0.000016 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    5              0.000014 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    5              0.000015 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    5              0.000015 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    5              0.000014 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    5              0.000014 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    5              0.000015 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    5              0.000015 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    5              0.000014 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    5              0.000016 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    5              0.000018 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    5              0.000016 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    5              0.000017 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    5              0.000016 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    5              0.000016 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    5              0.000014 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    5              0.000015 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    5              0.000016 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    5              0.000015 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    5              0.000014 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    5              0.000013 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    5              0.000014 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    5              0.000016 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    5              0.000015 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    5              0.000014 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    5              0.000013 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    5              0.000019 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    5              0.000016 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    5              0.000017 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    5              0.000014 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    5              0.000015 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    5              0.000013 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    5              0.000016 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    5              0.000016 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    5              0.000014 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    5              0.000014 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    5              0.000015 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    5              0.000016 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    5              0.000015 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    5              0.000017 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    5              0.000013 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    5              0.000016 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    5              0.000016 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    5              0.000014 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    5              0.000015 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    5              0.000015 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    5              0.000013 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    5              0.000014 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    5              0.000015 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    5              0.000015 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    5              0.000022 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    5              0.000018 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    5              0.000017 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    5              0.000016 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    5              0.000014 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    5              0.000020 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    5              0.000015 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    5              0.000020 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    5              0.000025 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    5              0.000015 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    5              0.000016 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    5              0.000014 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    5              0.000015 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    5              0.000013 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    5              0.000028 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    5              0.000022 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    5              0.000019 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    5              0.000019 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    5              0.000021 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    5              0.000020 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    5              0.000019 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    5              0.000022 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    5              0.000018 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    5              0.000017 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    5              0.000017 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    5              0.000020 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    5              0.000027 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    5              0.000009 syn keyword vbStatement Write
                            
    5              0.000020 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    5              0.000021 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    5              0.000018 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    5              0.000015 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    5              0.000016 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    5              0.000017 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    5              0.000010 syn keyword vbTodo contained    TODO
                            
                            "Datatypes
    5              0.000107 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    5              0.000020 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    5              0.000017 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    5              0.000017 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    5              0.000017 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    5              0.000017 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    5              0.000010 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    5              0.000015 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    5              0.000022 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    5              0.000015 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    5              0.000022 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    5              0.000015 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    5              0.000016 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    5              0.000016 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    5              0.000016 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    5              0.000017 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    5              0.000015 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    5              0.000014 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    5              0.000015 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    5              0.000014 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    5              0.000013 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    5              0.000015 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    5              0.000107 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    5              0.000019 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    5              0.000014 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    5              0.000015 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    5              0.000013 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    5              0.000013 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    5              0.000013 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    5              0.000013 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    5              0.000015 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    5              0.000017 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    5              0.000015 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    5              0.000016 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    5              0.000034 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    5              0.000017 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    5              0.000015 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    5              0.000015 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    5              0.000018 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    5              0.000017 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    5              0.000017 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    5              0.000017 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    5              0.000016 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    5              0.000019 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    5              0.000015 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    5              0.000013 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    5              0.000013 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    5              0.000012 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    5              0.000014 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    5              0.000015 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    5              0.000015 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    5              0.000017 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    5              0.000015 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    5              0.000016 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    5              0.000017 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    5              0.000014 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    5              0.000016 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    5              0.000014 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    5              0.000013 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    5              0.000015 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    5              0.000015 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    5              0.000014 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    5              0.000014 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    5              0.000015 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    5              0.000016 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    5              0.000015 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    5              0.000015 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    5              0.000014 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    5              0.000016 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    5              0.000014 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    5              0.000015 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    5              0.000029 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    5              0.000025 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    5              0.000019 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber            "{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber            ":[[:xdigit:]]\+"
                            "syn match  vbNumber            "[-+]\=\<\d\+\>"
    5              0.000033 syn match  vbFloat              "[-+]\=\<\d\+[eE][\-+]\=\d\+"
    5              0.000032 syn match  vbFloat              "[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    5              0.000029 syn match  vbFloat              "[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character constants
    5              0.000034 syn region  vbString		start=+"+  end=+"\|$+
    5              0.000041 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    5              0.000037 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    5              0.000022 syn match   vbLineLabel		"^\h\w\+:"
    5              0.000029 syn match   vbLineNumber	"^\d\+\(:\|\s\|$\)"
    5              0.000028 syn match   vbTypeSpecifier  "\<\a\w*[@\$%&!#]"ms=s+1
    5              0.000023 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            " Conditional Compilation
    5              0.000023 syn match  vbPreProc "^#const\>"
    5              0.000039 syn region vbPreProc matchgroup=PreProc start="^#if\>"     end="\<then\>" transparent contains=TOP
    5              0.000035 syn region vbPreProc matchgroup=PreProc start="^#elseif\>" end="\<then\>" transparent contains=TOP
    5              0.000019 syn match  vbPreProc "^#else\>"
    5              0.000022 syn match  vbPreProc "^#end\s*if\>"
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    5              0.000015 hi def link vbBoolean           Boolean
    5              0.000007 hi def link vbLineNumber        Comment
    5              0.000006 hi def link vbLineLabel         Comment
    5              0.000005 hi def link vbComment           Comment
    5              0.000006 hi def link vbConditional       Conditional
    5              0.000006 hi def link vbConst             Constant
    5              0.000005 hi def link vbDefine            Constant
    5              0.000006 hi def link vbError             Error
    5              0.000006 hi def link vbFunction          Identifier
    5              0.000006 hi def link vbIdentifier        Identifier
    5              0.000006 hi def link vbNumber            Number
    5              0.000005 hi def link vbFloat             Float
    5              0.000005 hi def link vbMethods           PreProc
    5              0.000006 hi def link vbOperator          Operator
    5              0.000005 hi def link vbRepeat            Repeat
    5              0.000005 hi def link vbString            String
    5              0.000006 hi def link vbStatement         Statement
    5              0.000005 hi def link vbKeyword           Statement
    5              0.000005 hi def link vbEvents            Special
    5              0.000005 hi def link vbTodo              Todo
    5              0.000005 hi def link vbTypes             Type
    5              0.000006 hi def link vbTypeSpecifier     Type
    5              0.000006 hi def link vbPreProc           PreProc
                            
    5              0.000019 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/css.vim
Sourced 5 times
Total time:   0.067238
 Self time:   0.067238

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Jules Wang      <w.jq0722@gmail.com>
                            "               Claudio Fleiner <claudio@fleiner.com>
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/vim-language-dept/css-syntax.vim
                            " Maintainer:   Jay Sitter <jay@jaysitter.com>
                            " Last Change:  2021 Oct 20
                            
                            " quit when a syntax file was already loaded
    5              0.000054 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
    5              0.000028 elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
    5              0.000003 endif
                            
    5              0.000060 let s:cpo_save = &cpo
    5              0.000066 set cpo&vim
                            
    5              0.000008 syn case ignore
                            " Add dash to allowed keyword characters.
    5              0.000053 syn iskeyword @,48-57,_,192-255,-
                            
                            " HTML4 tags
    5              0.000022 syn keyword cssTagName abbr address area a b base
    5              0.000017 syn keyword cssTagName bdo blockquote body br button
    5              0.000020 syn keyword cssTagName caption cite code col colgroup dd del
    5              0.000018 syn keyword cssTagName dfn div dl dt em fieldset form
    5              0.000018 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    5              0.000019 syn keyword cssTagName iframe input ins isindex kbd label legend li
    5              0.000017 syn keyword cssTagName link map menu meta noscript ol optgroup
    5              0.000020 syn keyword cssTagName option p param picture pre q s samp script small
    5              0.000015 syn keyword cssTagName span strong sub sup tbody td
    5              0.000018 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    5              0.000010 syn keyword cssTagName object svg
    5              0.000034 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    5              0.000020 syn keyword cssTagName article aside audio bdi canvas command data
    5              0.000020 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    5              0.000017 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    5              0.000015 syn keyword cssTagName output progress rt rp ruby section
    5              0.000015 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    5              0.000015 syn match cssTagName "\*"
                            
                            " selectors
    5              0.000019 syn match cssSelectorOp "[,>+~]"
    5              0.000022 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    5              0.000049 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    5              0.000034 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    5              0.000015 syn match cssClassNameDot contained '\.'
                            
    5              0.000006 try
    5              0.000031 syn match cssIdentifier "#[A-Za-zÀ-ÿ_@][A-Za-zÀ-ÿ0-9_@-]*"
                            catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
    5              0.000008 endtry
                            
                            " digits
    5              0.000027 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    5              0.000037 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    5              0.000065 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|fr\|vw\|vh\|vmin\|vmax\|ch\)\>" contains=cssUnitDecorators
    5              0.000029 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    5              0.000037 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    5              0.000033 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    5              0.000033 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    5              0.000033 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    5              0.000015 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    5              0.000017 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    5              0.000022 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    5              0.000038 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    5              0.000047 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    5              0.000026 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    5              0.000024 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    5              0.000021 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    5              0.000017 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    5              0.000016 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    5              0.000017 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    5              0.000013 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    5              0.000036 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    5              0.000035 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    5              0.000034 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    5              0.000042 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    5              0.000040 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    5              0.000019 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    5              0.000016 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    5              0.000034 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    5              0.000017 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    5              0.000016 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    5              0.000018 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    5              0.000017 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    5              0.000015 syn keyword cssColor contained thistle tomato turquoise violet wheat
    5              0.000011 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    5              0.000009 syn case match
    5              0.000046 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    5              0.000006 syn case ignore
                            
    5              0.000022 syn match cssImportant contained "!\s*important\>"
    5              0.000027 syn match cssCustomProp contained "\<--[a-zA-Z0-9-_]*\>"
                            
    5              0.000019 syn match cssColor contained "\<transparent\>"
    5              0.000019 syn match cssColor contained "\<currentColor\>"
    5              0.000015 syn match cssColor contained "\<white\>"
    5              0.000025 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    5              0.000022 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    5              0.000024 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    5              0.000056 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    5              0.004247 syn region cssMathGroup contained matchgroup=cssMathParens start="(" end=")" containedin=cssFunction,cssMathGroup contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    5              0.004075 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(var\|calc\)\s*(" end=")" contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    5              0.000075 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    5              0.000059 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    5              0.000069 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\|conic-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    5              0.000107 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    5              0.000076 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(blur\|brightness\|contrast\|drop-shadow\|grayscale\|hue-rotate\|invert\|opacity\|saturate\|sepia\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    5              0.000028 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    5              0.000015 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    5              0.000019 syn keyword cssCommonAttr contained auto none inherit all default normal
    5              0.000016 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
    5              0.000028 syn match cssCommonAttr contained "\<\(max-\|min-\|fit-\)content\>"
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    5              0.000059 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    5              0.000012 syn keyword cssAnimationAttr contained alternate reverse
    5              0.000024 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    5              0.000013 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    5              0.000010 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    5              0.000008 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    5              0.000044 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    5              0.000014 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    5              0.000014 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    5              0.000022 syn match cssBackgroundAttr contained "\<no-repeat\>"
    5              0.000024 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    5              0.000012 syn keyword cssBackgroundAttr contained cover contain
                            
    5              0.000043 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    5              0.000035 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    5              0.000042 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    5              0.000023 syn match cssBorderProp contained "\<box-decoration-break\>"
    5              0.000017 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    5              0.000014 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    5              0.000020 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    5              0.000011 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    5              0.000010 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    5              0.000031 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    5              0.000035 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    5              0.000024 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    5              0.000024 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    5              0.000015 syn keyword cssBoxAttr contained visible hidden scroll auto
    5              0.000025 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    5              0.000010 syn keyword cssCascadeProp contained all
    5              0.000013 syn keyword cssCascadeAttr contained initial unset revert
                            
    5              0.000009 syn keyword cssColorProp contained opacity
    5              0.000020 syn match cssColorProp contained "\<color-profile\>"
    5              0.000122 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    5              0.000026 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    5              0.000011 syn keyword cssDimensionProp contained height
    5              0.000009 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    5              0.000034 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    5              0.000039 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    5              0.000011 syn keyword cssFlexibleBoxProp contained order
                            
    5              0.000025 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    5              0.000016 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    5              0.000021 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    5              0.000038 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\|evenly\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    5              0.000084 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    5              0.000013 syn keyword cssFontAttr contained icon menu caption
    5              0.000017 syn match cssFontAttr contained "\<message-box\>"
    5              0.000018 syn match cssFontAttr contained "\<status-bar\>"
    5              0.000011 syn keyword cssFontAttr contained larger smaller
    5              0.000026 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    5              0.000022 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    5              0.000026 syn keyword cssFontAttr contained sans-serif serif cursive fantasy monospace
                            " font-feature-settings attributes
    5              0.000010 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    5              0.000040 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    5              0.000011 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    5              0.000010 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    5              0.000010 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    5              0.000017 syn match cssFontProp contained "\<font-smooth\>"
    5              0.000024 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    5              0.000035 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    5              0.000039 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    5              0.000011 syn keyword cssMultiColumnProp contained columns
    5              0.000011 syn keyword cssMultiColumnAttr contained balance medium
    5              0.000014 syn keyword cssMultiColumnAttr contained always left right page column
    5              0.000022 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    5              0.000027 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    5              0.000021 syn match cssInteractProp contained "\<pointer-events\>"
    5              0.000104 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    5              0.000013 syn keyword cssGeneratedContentProp contained quotes crop
    5              0.000024 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    5              0.000018 syn match cssGeneratedContentProp contained "\<move-to\>"
    5              0.000018 syn match cssGeneratedContentProp contained "\<page-policy\>"
    5              0.000028 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    5              0.000015 syn match cssGridProp contained "\<grid\>"
    5              0.000034 syn match cssGridProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
    5              0.000031 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    5              0.000020 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    5              0.000015 syn match cssGridProp contained "\<gap\>"
    5              0.000025 syn match cssGridProp contained "\<grid-auto-\(flow\|rows\|columns\)\>"
                            
    5              0.000025 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    5              0.000029 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    5              0.000035 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    5              0.000026 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    5              0.000033 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    5              0.000019 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    5              0.000011 syn keyword cssListAttr contained inside outside
                            
                            " object-fit https://www.w3.org/TR/css-images-3/#the-object-fit
    5              0.000030 syn match cssObjectProp contained "\<object-\(fit\|position\)\>"
    5              0.000018 syn keyword cssObjectAttr contained fill contain cover scale-down
                            
    5              0.000034 syn keyword cssPositioningProp contained bottom clear clip display float left
    5              0.000014 syn keyword cssPositioningProp contained position right top visibility
    5              0.000019 syn match cssPositioningProp contained "\<z-index\>"
    5              0.000015 syn keyword cssPositioningAttr contained block compact grid
    5              0.000055 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    5              0.000013 syn keyword cssPositioningAttr contained left right both
    5              0.000023 syn match cssPositioningAttr contained "\<list-item\>"
    5              0.000034 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    5              0.000019 syn match cssPositioningAttr contained "\<flow\(-root\)\=\>"
    5              0.000019 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid sticky
                            
    5              0.000015 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    5              0.000046 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    5              0.000021 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    5              0.000013 syn keyword cssTextProp contained color direction hyphens
    5              0.000070 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    5              0.000048 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    5              0.000038 syn match cssTextProp contained "\<\(word\|line\)-break\|\(overflow\|word\)-wrap\>"
    5              0.000022 syn match cssTextProp contained "\<white-space\>"
    5              0.000022 syn match cssTextProp contained "\<hanging-punctuation\>"
    5              0.000018 syn match cssTextProp contained "\<tab-size\>"
    5              0.000023 syn match cssTextProp contained "\<punctuation-trim\>"
    5              0.000020 syn match cssTextAttr contained "\<line-through\>"
    5              0.000022 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    5              0.000015 syn keyword cssTextAttr contained ltr rtl embed nowrap
    5              0.000017 syn keyword cssTextAttr contained underline overline blink sub super middle
    5              0.000013 syn keyword cssTextAttr contained capitalize uppercase lowercase
    5              0.000013 syn keyword cssTextAttr contained justify baseline sub super
    5              0.000016 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed geometricPrecision
    5              0.000022 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    5              0.000022 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    5              0.000014 syn keyword cssTextAttr contained start end adjacent
    5              0.000027 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    5              0.000015 syn keyword cssTextAttr contained distribute kashida first last
    5              0.000015 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    5              0.000019 syn match cssTextAttr contained "\<break-all\>"
    5              0.000020 syn match cssTextAttr contained "\<break-word\>"
    5              0.000010 syn keyword cssTextAttr contained manual
    5              0.000019 syn match cssTextAttr contained "\<bidi-override\>"
                            
    5              0.000026 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    5              0.000023 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    5              0.000021 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    5              0.000045 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    5              0.000026 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    5              0.000026 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    5              0.000022 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    5              0.000019 syn match cssUIProp contained "\<box-sizing\>"
    5              0.000029 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    5              0.000010 syn keyword cssUIProp contained cursor
    5              0.000037 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    5              0.000019 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    5              0.000015 syn keyword cssUIAttr contained progress wait text cell move
    5              0.000022 syn match cssUIAttr contained "\<context-menu\>"
    5              0.000017 syn match cssUIAttr contained "\<no-drop\>"
    5              0.000017 syn match cssUIAttr contained "\<not-allowed\>"
    5              0.000018 syn match cssUIAttr contained "\<all-scroll\>"
    5              0.000028 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    5              0.000022 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    5              0.000016 syn match cssUIProp contained "\<ime-mode\>"
    5              0.000013 syn keyword cssUIAttr contained active inactive disabled
                            
    5              0.000030 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    5              0.000030 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    5              0.000010 syn keyword cssUIAttr contained invert
                            
    5              0.000009 syn keyword cssUIProp contained icon resize
    5              0.000011 syn keyword cssUIAttr contained both horizontal vertical
                            
    5              0.000019 syn match cssUIProp contained "\<text-overflow\>"
    5              0.000012 syn keyword cssUIAttr contained clip ellipsis
                            
    5              0.000021 syn match cssUIProp contained "\<image-rendering\>"
    5              0.000010 syn keyword cssUIAttr contained pixellated
    5              0.000017 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    5              0.000016 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    5              0.000015 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    5              0.000036 syn match cssUIProp contained '\<\(tap-highlight-color\|user-select\|touch-callout\)\>'
                            " IE specific properties
    5              0.000026 syn match cssIEUIProp contained '\<\(interpolation-mode\|zoom\|filter\)\>'
                            
                            " Webkit/Firebox specific properties/attributes
    5              0.000010 syn keyword cssUIProp contained appearance
    5              0.000016 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    5              0.000029 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    5              0.000061 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    5              0.000019 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    5              0.000027 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    5              0.000011 syn keyword cssAuralAttr contained silent
    5              0.000018 syn match cssAuralAttr contained "\<spell-out\>"
    5              0.000012 syn keyword cssAuralAttr contained non mix
    5              0.000023 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    5              0.000029 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    5              0.000013 syn keyword cssAuralAttr contained leftwards rightwards behind
    5              0.000015 syn keyword cssAuralAttr contained below level above lower higher
    5              0.000026 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    5              0.000012 syn keyword cssAuralAttr contained faster slower
    5              0.000018 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    5              0.000022 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    5              0.000014 syn keyword cssMediaProp contained width height orientation scan
    5              0.000016 syn keyword cssMediaProp contained any-hover any-pointer color-gamut grid hover
    5              0.000015 syn keyword cssMediaProp contained overflow-block overflow-inline pointer update
    5              0.000033 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio\>/
    5              0.000028 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=device-pixel-ratio\>/
    5              0.000028 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=device-\(height\|width\)\>/
    5              0.000046 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)\>/
    5              0.000016 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    5              0.000017 syn keyword cssMediaAttr contained coarse fast fine hover infinite p3 paged
    5              0.000013 syn keyword cssMediaAttr contained rec2020 scroll slow srgb
    5              0.000038 syn match cssKeyFrameProp contained /\(\d\+\(\.\d\+\)\?%\|\(\<from\|to\>\)\)/ nextgroup=cssDefinition
    5              0.000051 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    5              0.000013 syn keyword cssPageProp contained content size
    5              0.000011 syn keyword cssPageProp contained orphans widows
    5              0.000009 syn keyword cssFontDescriptorProp contained src
    5              0.000022 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    5              0.000024 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    5              0.000018 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    5              0.000016 syn match cssBraces contained "[{}]"
    5              0.000019 syn match cssError contained "{@<>"
    5              0.009160 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssCustomProp,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    5              0.000027 syn match cssBraceError "}"
    5              0.000017 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " https://www.w3.org/TR/selectors-4/
    5              0.000040 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    5              0.000024 syn keyword cssPseudoClassId contained link visited active hover before after left right
    5              0.000020 syn keyword cssPseudoClassId contained root empty target enabled disabled checked invalid
    5              0.000026 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    5              0.000031 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    5              0.000025 syn match cssPseudoClassId contained  "\<focus\(-within\|-visible\)\=\>"
    5              0.000070 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|is\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")" contains=cssStringQ,cssStringQQ,cssTagName,cssAttributeSelector,cssClassName,cssIdentifier
                            " ------------------------------------
                            " Vendor specific properties
    5              0.000017 syn match cssPseudoClassId contained  "\<selection\>"
    5              0.000025 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    5              0.000065 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    5              0.000016 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    5              0.000049 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    5              0.000025 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    5              0.000016 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    5              0.000015 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    5              0.000042 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    5              0.000040 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    5              0.000023 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    5              0.000014 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
                            " cssPseudoClassId is hidden by cssAttrRegion, so we add it here. see #69
    5              0.012802 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\|{\)/ contained contains=cssPseudoClassId,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    5              0.017681 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    5              0.000064 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/
                            
    5              0.000019 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    5              0.000070 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment,cssCustomProp,cssFunctionName nextgroup=cssDefinition
    5              0.000031 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    5              0.000045 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    5              0.000029 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    5              0.000050 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    5              0.000059 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    5              0.000051 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    5              0.000039 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    5              0.008812 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    5              0.000032 if main_syntax == "css"
                              syn sync minlines=10
    5              0.000006 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    5              0.000011 hi def link cssComment Comment
    5              0.000006 hi def link cssVendor Comment
    5              0.000005 hi def link cssHacks Comment
    5              0.000006 hi def link cssTagName Statement
    5              0.000006 hi def link cssDeprecated Error
    5              0.000005 hi def link cssSelectorOp Special
    5              0.000005 hi def link cssSelectorOp2 Special
    5              0.000006 hi def link cssAttrComma Special
                            
    5              0.000006 hi def link cssAnimationProp cssProp
    5              0.000005 hi def link cssBackgroundProp cssProp
    5              0.000005 hi def link cssBorderProp cssProp
    5              0.000006 hi def link cssBoxProp cssProp
    5              0.000005 hi def link cssCascadeProp cssProp
    5              0.000005 hi def link cssColorProp cssProp
    5              0.000007 hi def link cssContentForPagedMediaProp cssProp
    5              0.000005 hi def link cssDimensionProp cssProp
    5              0.000006 hi def link cssFlexibleBoxProp cssProp
    5              0.000005 hi def link cssFontProp cssProp
    5              0.000006 hi def link cssGeneratedContentProp cssProp
    5              0.000005 hi def link cssGridProp cssProp
    5              0.000005 hi def link cssHyerlinkProp cssProp
    5              0.000005 hi def link cssInteractProp cssProp
    5              0.000006 hi def link cssLineboxProp cssProp
    5              0.000005 hi def link cssListProp cssProp
    5              0.000005 hi def link cssMarqueeProp cssProp
    5              0.000005 hi def link cssMultiColumnProp cssProp
    5              0.000006 hi def link cssPagedMediaProp cssProp
    5              0.000005 hi def link cssPositioningProp cssProp
    5              0.000005 hi def link cssObjectProp cssProp
    5              0.000006 hi def link cssPrintProp cssProp
    5              0.000005 hi def link cssRubyProp cssProp
    5              0.000005 hi def link cssSpeechProp cssProp
    5              0.000005 hi def link cssTableProp cssProp
    5              0.000005 hi def link cssTextProp cssProp
    5              0.000005 hi def link cssTransformProp cssProp
    5              0.000005 hi def link cssTransitionProp cssProp
    5              0.000005 hi def link cssUIProp cssProp
    5              0.000005 hi def link cssIEUIProp cssProp
    5              0.000005 hi def link cssAuralProp cssProp
    5              0.000005 hi def link cssRenderProp cssProp
    5              0.000005 hi def link cssMobileTextProp cssProp
                            
    5              0.000005 hi def link cssAnimationAttr cssAttr
    5              0.000005 hi def link cssBackgroundAttr cssAttr
    5              0.000005 hi def link cssBorderAttr cssAttr
    5              0.000005 hi def link cssBoxAttr cssAttr
    5              0.000006 hi def link cssContentForPagedMediaAttr cssAttr
    5              0.000005 hi def link cssDimensionAttr cssAttr
    5              0.000005 hi def link cssFlexibleBoxAttr cssAttr
    5              0.000005 hi def link cssFontAttr cssAttr
    5              0.000006 hi def link cssGeneratedContentAttr cssAttr
    5              0.000005 hi def link cssGridAttr cssAttr
    5              0.000005 hi def link cssHyerlinkAttr cssAttr
    5              0.000005 hi def link cssInteractAttr cssAttr
    5              0.000005 hi def link cssLineboxAttr cssAttr
    5              0.000005 hi def link cssListAttr cssAttr
    5              0.000005 hi def link cssMarginAttr cssAttr
    5              0.000005 hi def link cssMarqueeAttr cssAttr
    5              0.000005 hi def link cssMultiColumnAttr cssAttr
    5              0.000005 hi def link cssPaddingAttr cssAttr
    5              0.000006 hi def link cssPagedMediaAttr cssAttr
    5              0.000005 hi def link cssPositioningAttr cssAttr
    5              0.000005 hi def link cssObjectAttr cssAttr
    5              0.000005 hi def link cssGradientAttr cssAttr
    5              0.000005 hi def link cssPrintAttr cssAttr
    5              0.000005 hi def link cssRubyAttr cssAttr
    5              0.000007 hi def link cssSpeechAttr cssAttr
    5              0.000005 hi def link cssTableAttr cssAttr
    5              0.000005 hi def link cssTextAttr cssAttr
    5              0.000005 hi def link cssTransformAttr cssAttr
    5              0.000005 hi def link cssTransitionAttr cssAttr
    5              0.000005 hi def link cssUIAttr cssAttr
    5              0.000005 hi def link cssIEUIAttr cssAttr
    5              0.000005 hi def link cssAuralAttr cssAttr
    5              0.000005 hi def link cssRenderAttr cssAttr
    5              0.000005 hi def link cssCascadeAttr cssAttr
    5              0.000005 hi def link cssCommonAttr cssAttr
                            
    5              0.000005 hi def link cssPseudoClassId PreProc
    5              0.000006 hi def link cssPseudoClassLang Constant
    5              0.000005 hi def link cssValueLength Number
    5              0.000005 hi def link cssValueInteger Number
    5              0.000006 hi def link cssValueNumber Number
    5              0.000005 hi def link cssValueAngle Number
    5              0.000005 hi def link cssValueTime Number
    5              0.000005 hi def link cssValueFrequency Number
    5              0.000005 hi def link cssFunction Constant
    5              0.000005 hi def link cssURL String
    5              0.000005 hi def link cssFunctionName Function
    5              0.000005 hi def link cssFunctionComma Function
    5              0.000005 hi def link cssColor Constant
    5              0.000005 hi def link cssIdentifier Function
    5              0.000005 hi def link cssAtRule Include
    5              0.000005 hi def link cssAtKeyword PreProc
    5              0.000005 hi def link cssImportant Special
    5              0.000005 hi def link cssCustomProp Special
    5              0.000005 hi def link cssBraces Function
    5              0.000005 hi def link cssBraceError Error
    5              0.000005 hi def link cssError Error
    5              0.000021 hi def link cssUnicodeEscape Special
    5              0.000014 hi def link cssStringQQ String
    5              0.000005 hi def link cssStringQ String
    5              0.000005 hi def link cssAttributeSelector String
    5              0.000005 hi def link cssMediaType Special
    5              0.000006 hi def link cssMediaComma Normal
    5              0.000005 hi def link cssAtRuleLogical Statement
    5              0.000005 hi def link cssMediaProp cssProp
    5              0.000005 hi def link cssMediaAttr cssAttr
    5              0.000005 hi def link cssPagePseudo PreProc
    5              0.000006 hi def link cssPageMarginProp cssAtKeyword
    5              0.000005 hi def link cssPageProp cssProp
    5              0.000005 hi def link cssKeyFrameProp Constant
    5              0.000005 hi def link cssFontDescriptor Special
    5              0.000006 hi def link cssFontDescriptorProp cssProp
    5              0.000005 hi def link cssFontDescriptorAttr cssAttr
    5              0.000005 hi def link cssUnicodeRange Constant
    5              0.000005 hi def link cssClassName Function
    5              0.000005 hi def link cssClassNameDot Function
    5              0.000005 hi def link cssProp StorageClass
    5              0.000005 hi def link cssAttr Constant
    5              0.000006 hi def link cssUnitDecorators Number
    5              0.000005 hi def link cssNoise Noise
                            
    5              0.000022 let b:current_syntax = "css"
                            
    5              0.000011 if main_syntax == 'css'
                              unlet main_syntax
    5              0.000004 endif
                            
    5              0.000100 let &cpo = s:cpo_save
    5              0.000012 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/yaml.vim
Sourced 5 times
Total time:   0.006019
 Self time:   0.005323

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:         YAML (YAML Ain't Markup Language) 1.2
                            " Maintainer:       Nikolai Pavlov <zyx.vim@gmail.com>
                            " First author:     Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:  2015-03-28
                            " 		    removed duplicate yamlKeyValueDelimiter (pull #4799)
                            
    5              0.000056 if exists('b:current_syntax')
                                finish
    5              0.000004 endif
                            
    5              0.000060 let s:cpo_save = &cpo
    5              0.000072 set cpo&vim
                            
                            " Choose the schema to use
                            " TODO: Validate schema
    5              0.000018 if !exists('b:yaml_schema')
    5              0.000013   if exists('g:yaml_schema')
                                let b:yaml_schema = g:yaml_schema
    5              0.000005   else
    5              0.000010     let b:yaml_schema = 'core'
    5              0.000004   endif
    5              0.000009 endif
                            
    5              0.000012 let s:ns_char = '\%([\n\r\uFEFF \t]\@!\p\)'
    5              0.000011 let s:ns_word_char = '[[:alnum:]_\-]'
    5              0.000020 let s:ns_uri_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$,.!~*''()[\]]\)'
    5              0.000016 let s:ns_tag_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$.~*''()]\)'
    5              0.000013 let s:c_ns_anchor_char = '\%([\n\r\uFEFF \t,[\]{}]\@!\p\)'
    5              0.000010 let s:c_indicator      = '[\-?:,[\]{}#&*!|>''"%@`]'
    5              0.000010 let s:c_flow_indicator = '[,[\]{}]'
                            
    5              0.000075 let s:ns_char_without_c_indicator = substitute(s:ns_char, '\v\C[\zs', '\=s:c_indicator[1:-2]', '')
                            
    5              0.000012 let s:_collection = '[^\@!\(\%(\\\.\|\[^\\\]]\)\+\)]'
    5              0.000020 let s:_neg_collection = '[^\(\%(\\\.\|\[^\\\]]\)\+\)]'
    5              0.000024 function s:SimplifyToAssumeAllPrintable(p)
                                return substitute(a:p, '\V\C\\%('.s:_collection.'\\@!\\p\\)', '[^\1]', '')
                            endfunction
    5   0.000209   0.000069 let s:ns_char = s:SimplifyToAssumeAllPrintable(s:ns_char)
    5   0.000182   0.000073 let s:ns_char_without_c_indicator = s:SimplifyToAssumeAllPrintable(s:ns_char_without_c_indicator)
    5   0.000153   0.000061 let s:c_ns_anchor_char = s:SimplifyToAssumeAllPrintable(s:c_ns_anchor_char)
                            
    5              0.000015 function s:SimplifyAdjacentCollections(p)
                                return substitute(a:p, '\V\C'.s:_collection.'\\|'.s:_collection, '[\1\2]', 'g')
                            endfunction
    5   0.000205   0.000053 let s:ns_uri_char = s:SimplifyAdjacentCollections(s:ns_uri_char)
    5   0.000138   0.000047 let s:ns_tag_char = s:SimplifyAdjacentCollections(s:ns_tag_char)
                            
    5              0.000017 let s:c_verbatim_tag = '!<'.s:ns_uri_char.'\+>'
    5              0.000015 let s:c_named_tag_handle     = '!'.s:ns_word_char.'\+!'
    5              0.000010 let s:c_secondary_tag_handle = '!!'
    5              0.000012 let s:c_primary_tag_handle   = '!'
    5              0.000033 let s:c_tag_handle = '\%('.s:c_named_tag_handle.
                                        \         '\|'.s:c_secondary_tag_handle.
                                        \         '\|'.s:c_primary_tag_handle.'\)'
    5              0.000017 let s:c_ns_shorthand_tag = s:c_tag_handle . s:ns_tag_char.'\+'
    5              0.000009 let s:c_non_specific_tag = '!'
    5              0.000026 let s:c_ns_tag_property = s:c_verbatim_tag.
                                        \        '\|'.s:c_ns_shorthand_tag.
                                        \        '\|'.s:c_non_specific_tag
                            
    5              0.000012 let s:c_ns_anchor_name = s:c_ns_anchor_char.'\+'
    5              0.000014 let s:c_ns_anchor_property =  '&'.s:c_ns_anchor_name
    5              0.000013 let s:c_ns_alias_node      = '\*'.s:c_ns_anchor_name
                            
    5              0.000012 let s:ns_directive_name = s:ns_char.'\+'
                            
    5              0.000014 let s:ns_local_tag_prefix  = '!'.s:ns_uri_char.'*'
    5              0.000016 let s:ns_global_tag_prefix = s:ns_tag_char.s:ns_uri_char.'*'
    5              0.000019 let s:ns_tag_prefix = s:ns_local_tag_prefix.
                                        \    '\|'.s:ns_global_tag_prefix
                            
    5              0.000010 let s:ns_plain_safe_out = s:ns_char
    5              0.000019 let s:ns_plain_safe_in  = '\%('.s:c_flow_indicator.'\@!'.s:ns_char.'\)'
                            
    5              0.000116 let s:ns_plain_safe_in = substitute(s:ns_plain_safe_in, '\V\C\\%('.s:_collection.'\\@!'.s:_neg_collection.'\\)', '[^\1\2]', '')
    5              0.000079 let s:ns_plain_safe_in_without_colhash = substitute(s:ns_plain_safe_in, '\V\C'.s:_neg_collection, '[^\1:#]', '')
    5              0.000072 let s:ns_plain_safe_out_without_colhash = substitute(s:ns_plain_safe_out, '\V\C'.s:_neg_collection, '[^\1:#]', '')
                            
    5              0.000025 let s:ns_plain_first_in  = '\%('.s:ns_char_without_c_indicator.'\|[?:\-]\%('.s:ns_plain_safe_in.'\)\@=\)'
    5              0.000021 let s:ns_plain_first_out = '\%('.s:ns_char_without_c_indicator.'\|[?:\-]\%('.s:ns_plain_safe_out.'\)\@=\)'
                            
    5              0.000025 let s:ns_plain_char_in  = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_in.'\|'.s:ns_plain_safe_in_without_colhash.'\)'
    5              0.000024 let s:ns_plain_char_out = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_out.'\|'.s:ns_plain_safe_out_without_colhash.'\)'
                            
    5              0.000017 let s:ns_plain_out = s:ns_plain_first_out . s:ns_plain_char_out.'*'
    5              0.000017 let s:ns_plain_in  = s:ns_plain_first_in  . s:ns_plain_char_in.'*'
                            
                            
    5              0.000028 syn keyword yamlTodo            contained TODO FIXME XXX NOTE
                            
    5              0.000048 syn region  yamlComment         display oneline start='\%\(^\|\s\)#' end='$'
                                        \                   contains=yamlTodo
                            
    5              0.000125 execute 'syn region yamlDirective oneline start='.string('^\ze%'.s:ns_directive_name.'\s\+').' '.
                                        \                            'end="$" '.
                                        \                            'contains=yamlTAGDirective,'.
                                        \                                     'yamlYAMLDirective,'.
                                        \                                     'yamlReservedDirective '.
                                        \                            'keepend'
                            
    5              0.000025 syn match yamlTAGDirective '%TAG\s\+' contained nextgroup=yamlTagHandle
    5              0.000072 execute 'syn match yamlTagHandle contained nextgroup=yamlTagPrefix '.string(s:c_tag_handle.'\s\+')
    5              0.000099 execute 'syn match yamlTagPrefix contained nextgroup=yamlComment ' . string(s:ns_tag_prefix)
                            
    5              0.000033 syn match yamlYAMLDirective '%YAML\s\+'  contained nextgroup=yamlYAMLVersion
    5              0.000022 syn match yamlYAMLVersion   '\d\+\.\d\+' contained nextgroup=yamlComment
                            
    5              0.000069 execute 'syn match yamlReservedDirective contained nextgroup=yamlComment '.
                                        \string('%\%(\%(TAG\|YAML\)\s\)\@!'.s:ns_directive_name)
                            
    5              0.000053 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start='"' skip='\\"' end='"'
                                        \ contains=yamlEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    5              0.000054 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start="'" skip="''"  end="'"
                                        \ contains=yamlSingleEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    5              0.000049 syn match  yamlEscape contained '\\\%([\\"abefnrtv\^0_ NLP\n]\|x\x\x\|u\x\{4}\|U\x\{8}\)'
    5              0.000015 syn match  yamlSingleEscape contained "''"
                            
    5              0.000032 syn match yamlBlockScalarHeader contained '\s\+\zs[|>]\%([+-]\=[1-9]\|[1-9]\=[+-]\)\='
                            
    5              0.000021 syn cluster yamlConstant contains=yamlBool,yamlNull
                            
    5              0.000019 syn cluster yamlFlow contains=yamlFlowString,yamlFlowMapping,yamlFlowCollection
    5              0.000018 syn cluster yamlFlow      add=yamlFlowMappingKey,yamlFlowMappingMerge
    5              0.000020 syn cluster yamlFlow      add=@yamlConstant,yamlPlainScalar,yamlFloat
    5              0.000028 syn cluster yamlFlow      add=yamlTimestamp,yamlInteger,yamlMappingKeyStart
    5              0.000012 syn cluster yamlFlow      add=yamlComment
    5              0.000042 syn region yamlFlowMapping    matchgroup=yamlFlowIndicator start='{' end='}' contains=@yamlFlow
    5              0.000030 syn region yamlFlowCollection matchgroup=yamlFlowIndicator start='\[' end='\]' contains=@yamlFlow
                            
    5              0.000079 execute 'syn match yamlPlainScalar /'.s:ns_plain_out.'/'
    5              0.000077 execute 'syn match yamlPlainScalar contained /'.s:ns_plain_in.'/'
                            
    5              0.000017 syn match yamlMappingKeyStart '?\ze\s'
    5              0.000014 syn match yamlMappingKeyStart '?' contained
                            
    5              0.000182 execute 'syn match yamlFlowMappingKey /\%#=1'.s:ns_plain_in.'\%(\s\+'.s:ns_plain_in.'\)*\ze\s*:/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    5              0.000023 syn match yamlFlowMappingMerge /<<\ze\s*:/ contained nextgroup=yamlKeyValueDelimiter
                            
    5              0.000034 syn match yamlBlockCollectionItemStart '^\s*\zs-\%(\s\+-\)*\s' nextgroup=yamlBlockMappingKey,yamlBlockMappingMerge
                            " Use the old regexp engine, the NFA engine doesn't like all the \@ items.
    5              0.000150 execute 'syn match yamlBlockMappingKey /\%#=1^\s*\zs'.s:ns_plain_out.'\%(\s\+'.s:ns_plain_out.'\)*\ze\s*:\%(\s\|$\)/ '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    5              0.000128 execute 'syn match yamlBlockMappingKey /\%#=1\s*\zs'.s:ns_plain_out.'\%(\s\+'.s:ns_plain_out.'\)*\ze\s*:\%(\s\|$\)/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    5              0.000035 syn match yamlBlockMappingMerge /^\s*\zs<<\ze:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter
    5              0.000025 syn match yamlBlockMappingMerge /<<\ze\s*:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter contained
                            
    5              0.000015 syn match   yamlKeyValueDelimiter /\s*:/ contained
                            
    5              0.000023 syn cluster yamlScalarWithSpecials contains=yamlPlainScalar,yamlBlockMappingKey,yamlFlowMappingKey
                            
    5   0.000185   0.000072 let s:_bounder = s:SimplifyToAssumeAllPrintable('\%([[\]{}, \t]\@!\p\)')
    5              0.000016 if b:yaml_schema is# 'json'
                                syn keyword yamlNull null contained containedin=@yamlScalarWithSpecials
                                syn keyword yamlBool true false
                                exe 'syn match   yamlInteger /'.s:_bounder.'\@1<!\%(0\|-\=[1-9][0-9]*\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match   yamlFloat   /'.s:_bounder.'\@1<!\%(-\=[1-9][0-9]*\%(\.[0-9]*\)\=\(e[-+]\=[0-9]\+\)\=\|0\|-\=\.inf\|\.nan\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    5              0.000011 elseif b:yaml_schema is# 'core'
    5              0.000040     syn keyword yamlNull null Null NULL contained containedin=@yamlScalarWithSpecials
    5              0.000025     syn keyword yamlBool true True TRUE false False FALSE contained containedin=@yamlScalarWithSpecials
    5              0.000061     exe 'syn match   yamlNull /'.s:_bounder.'\@1<!\~'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    5              0.000115     exe 'syn match   yamlInteger /'.s:_bounder.'\@1<!\%([+-]\=\%(0\%(b[0-1_]\+\|[0-7_]\+\|x[0-9a-fA-F_]\+\)\=\|\%([1-9][0-9_]*\%(:[0-5]\=\d\)\+\)\)\|[1-9][0-9_]*\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    5              0.000139     exe 'syn match   yamlFloat /'.s:_bounder.'\@1<!\%([+-]\=\%(\%(\d[0-9_]*\)\.[0-9_]*\%([eE][+-]\=\d\+\)\=\|\.[0-9_]\+\%([eE][-+]\=[0-9]\+\)\=\|\d[0-9_]*\%(:[0-5]\=\d\)\+\.[0-9_]*\|\.\%(inf\|Inf\|INF\)\)\|\%(\.\%(nan\|NaN\|NAN\)\)\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                            elseif b:yaml_schema is# 'pyyaml'
                                syn keyword yamlNull null Null NULL contained containedin=@yamlScalarWithSpecials
                                syn keyword yamlBool true True TRUE false False FALSE yes Yes YES no No NO on On ON off Off OFF contained containedin=@yamlScalarWithSpecials
                                exe 'syn match   yamlNull /'.s:_bounder.'\@1<!\~'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlFloat /'.s:_bounder.'\@1<!\%(\v[-+]?%(\d[0-9_]*)\.[0-9_]*%([eE][-+]\d+)?|\.[0-9_]+%([eE][-+]\d+)?|[-+]?\d[0-9_]*%(\:[0-5]?\d)+\.[0-9_]*|[-+]?\.%(inf|Inf|INF)|\.%(nan|NaN|NAN)\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlInteger /'.s:_bounder.'\@1<!\%(\v[-+]?0b[0-1_]+|[-+]?0[0-7_]+|[-+]?%(0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?[1-9][0-9_]*%(:[0-5]?\d)+\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlTimestamp /'.s:_bounder.'\@1<!\%(\v\d\d\d\d\-\d\d\-\d\d|\d\d\d\d \-\d\d? \-\d\d?%([Tt]|[ \t]+)\d\d?\:\d\d \:\d\d %(\.\d*)?%([ \t]*%(Z|[-+]\d\d?%(\:\d\d)?))?\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                            elseif b:yaml_schema is# 'failsafe'
                                " Nothing
    5              0.000005 endif
    5              0.000010 unlet s:_bounder
                            
                            
    5              0.000110 execute 'syn match yamlNodeTag '.string(s:c_ns_tag_property)
    5              0.000053 execute 'syn match yamlAnchor  '.string(s:c_ns_anchor_property)
    5              0.000051 execute 'syn match yamlAlias   '.string(s:c_ns_alias_node)
                            
    5              0.000023 syn match yamlDocumentStart '^---\ze\%(\s\|$\)'
    5              0.000022 syn match yamlDocumentEnd   '^\.\.\.\ze\%(\s\|$\)'
                            
    5              0.000010 hi def link yamlTodo                     Todo
    5              0.000007 hi def link yamlComment                  Comment
                            
    5              0.000006 hi def link yamlDocumentStart            PreProc
    5              0.000006 hi def link yamlDocumentEnd              PreProc
                            
    5              0.000006 hi def link yamlDirectiveName            Keyword
                            
    5              0.000007 hi def link yamlTAGDirective             yamlDirectiveName
    5              0.000006 hi def link yamlTagHandle                String
    5              0.000006 hi def link yamlTagPrefix                String
                            
    5              0.000007 hi def link yamlYAMLDirective            yamlDirectiveName
    5              0.000006 hi def link yamlReservedDirective        Error
    5              0.000006 hi def link yamlYAMLVersion              Number
                            
    5              0.000006 hi def link yamlString                   String
    5              0.000006 hi def link yamlFlowString               yamlString
    5              0.000007 hi def link yamlFlowStringDelimiter      yamlString
    5              0.000006 hi def link yamlEscape                   SpecialChar
    5              0.000006 hi def link yamlSingleEscape             SpecialChar
                            
    5              0.000006 hi def link yamlBlockCollectionItemStart Label
    5              0.000006 hi def link yamlBlockMappingKey          Identifier
    5              0.000006 hi def link yamlBlockMappingMerge        Special
                            
    5              0.000006 hi def link yamlFlowMappingKey           Identifier
    5              0.000006 hi def link yamlFlowMappingMerge         Special
                            
    5              0.000006 hi def link yamlMappingKeyStart          Special
    5              0.000005 hi def link yamlFlowIndicator            Special
    5              0.000005 hi def link yamlKeyValueDelimiter        Special
                            
    5              0.000007 hi def link yamlConstant                 Constant
                            
    5              0.000006 hi def link yamlNull                     yamlConstant
    5              0.000006 hi def link yamlBool                     yamlConstant
                            
    5              0.000005 hi def link yamlAnchor                   Type
    5              0.000006 hi def link yamlAlias                    Type
    5              0.000005 hi def link yamlNodeTag                  Type
                            
    5              0.000006 hi def link yamlInteger                  Number
    5              0.000005 hi def link yamlFloat                    Float
    5              0.000005 hi def link yamlTimestamp                Number
                            
    5              0.000014 let b:current_syntax = "yaml"
                            
    5              0.000089 unlet s:ns_word_char s:ns_uri_char s:c_verbatim_tag s:c_named_tag_handle s:c_secondary_tag_handle s:c_primary_tag_handle s:c_tag_handle s:ns_tag_char s:c_ns_shorthand_tag s:c_non_specific_tag s:c_ns_tag_property s:c_ns_anchor_char s:c_ns_anchor_name s:c_ns_anchor_property s:c_ns_alias_node s:ns_char s:ns_directive_name s:ns_local_tag_prefix s:ns_global_tag_prefix s:ns_tag_prefix s:c_indicator s:ns_plain_safe_out s:c_flow_indicator s:ns_plain_safe_in s:ns_plain_first_in s:ns_plain_first_out s:ns_plain_char_in s:ns_plain_char_out s:ns_plain_out s:ns_plain_in s:ns_char_without_c_indicator s:ns_plain_safe_in_without_colhash s:ns_plain_safe_out_without_colhash
    5              0.000009 unlet s:_collection s:_neg_collection
    5              0.000019 delfunction s:SimplifyAdjacentCollections
    5              0.000013 delfunction s:SimplifyToAssumeAllPrintable
                            
    5              0.000077 let &cpo = s:cpo_save
    5              0.000020 unlet s:cpo_save

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/c.vim
Sourced 208 times
Total time:   0.533779
 Self time:   0.533779

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2022 Oct 05
                            
                            " Quit when a (custom) syntax file was already loaded
  208              0.003250 if exists("b:current_syntax")
                              finish
  208              0.000291 endif
                            
  208              0.003689 let s:cpo_save = &cpo
  208              0.004136 set cpo&vim
                            
  208              0.005153 let s:ft = matchstr(&ft, '^\%([^.]\)\+')
                            
                            " check if this was included from cpp.vim
  208              0.001882 let s:in_cpp_family = exists("b:filetype_in_cpp_family")
                            
                            " Optional embedded Autodoc parsing
                            " To enable it add: let g:c_autodoc = 1
                            " to your .vimrc
  208              0.000841 if exists("c_autodoc")
                              syn include @cAutodoc <sfile>:p:h/autodoc.vim
                              unlet b:current_syntax
  208              0.000241 endif
                            
                            " A bunch of useful C keywords
  208              0.001588 syn keyword	cStatement	goto break return continue asm
  208              0.000650 syn keyword	cLabel		case default
  208              0.000711 syn keyword	cConditional	if else switch
  208              0.000723 syn keyword	cRepeat		while for do
                            
  208              0.001020 syn keyword	cTodo		contained TODO FIXME XXX
                            
                            " It's easy to accidentally add a space after a backslash that was intended
                            " for line continuation.  Some compilers allow it, which makes it
                            " unpredictable and should be avoided.
  208              0.001823 syn match	cBadContinuation contained "\\\s\+$"
                            
                            " cCommentGroup allows adding matches for special things in comments
  208              0.001704 syn cluster	cCommentGroup	contains=cTodo,cBadContinuation
                            
                            " String and Character constants
                            " Highlight special characters (those which have a backslash) differently
  208              0.002346 syn match	cSpecial	display contained "\\\%(x\x\+\|\o\{1,3}\|.\|$\)"
  208              0.001240 if !exists("c_no_utf")
  208              0.001976   syn match	cSpecial	display contained "\\\%(u\x\{4}\|U\x\{8}\)"
  208              0.000332 endif
                            
  208              0.000861 if !exists("c_no_cformat")
                              " Highlight % items in strings.
  208              0.000843   if !exists("c_no_c99") " ISO C99
  208              0.004308     syn match	cFormat		display "%\%(\d\+\$\)\=[-+' #0*]*\%(\d*\|\*\|\*\d\+\$\)\%(\.\%(\d*\|\*\|\*\d\+\$\)\)\=\%([hlLjzt]\|ll\|hh\)\=\%([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
                              else
                                syn match	cFormat		display "%\%(\d\+\$\)\=[-+' #0*]*\%(\d*\|\*\|\*\d\+\$\)\%(\.\%(\d*\|\*\|\*\d\+\$\)\)\=\%([hlL]\|ll\)\=\%([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
  208              0.000368   endif
  208              0.001038   syn match	cFormat		display "%%" contained
  208              0.000290 endif
                            
                            " cCppString: same as cString, but ends at end of line
  208              0.001156 if s:in_cpp_family && !exists("cpp_no_cpp11") && !exists("c_no_cformat")
                              " ISO C++11
    7              0.000133   syn region	cString		start=+\%(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
    7              0.000134   syn region 	cCppString	start=+\%(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
  201              0.001351 elseif s:ft ==# "c" && !exists("c_no_c11") && !exists("c_no_cformat")
                              " ISO C99
   10              0.000150   syn region	cString		start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
   10              0.000164   syn region	cCppString	start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
  191              0.000352 else
                              " older C or C++
  191              0.001007   syn match	cFormat		display "%%" contained
  191              0.002642   syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
  191              0.003237   syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
  208              0.000335 endif
                            
  208              0.004170 syn region	cCppSkip	contained start="^\s*\%(%:\|#\)\s*\%(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\%(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
                            
  208              0.000968 syn cluster	cStringGroup	contains=cCppString,cCppSkip
                            
  208              0.001228 syn match	cCharacter	"L\='[^\\]'"
  208              0.001411 syn match	cCharacter	"L'[^']*'" contains=cSpecial
  208              0.001079 if exists("c_gnu")
                              syn match	cSpecialError	"L\='\\[^'\"?\\abefnrtv]'"
                              syn match	cSpecialCharacter "L\='\\['\"?\\abefnrtv]'"
  208              0.000338 else
  208              0.001347   syn match	cSpecialError	"L\='\\[^'\"?\\abfnrtv]'"
  208              0.001579   syn match	cSpecialCharacter "L\='\\['\"?\\abfnrtv]'"
  208              0.000284 endif
  208              0.001290 syn match	cSpecialCharacter display "L\='\\\o\{1,3}'"
  208              0.001214 syn match	cSpecialCharacter display "'\\x\x\{1,2}'"
  208              0.001117 syn match	cSpecialCharacter display "L'\\x\x\+'"
                            
  208              0.001591 if (s:ft ==# "c" && !exists("c_no_c11")) || (s:in_cpp_family && !exists("cpp_no_cpp11"))
                              " ISO C11 or ISO C++ 11
   17              0.000047   if exists("c_no_cformat")
                                syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
   17              0.000024   else
   17              0.000183     syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
   17              0.000020   endif
   17              0.000075   syn match	cCharacter	"[Uu]'[^\\]'"
   17              0.000085   syn match	cCharacter	"[Uu]'[^']*'" contains=cSpecial
   17              0.000058   if exists("c_gnu")
                                syn match	cSpecialError	"[Uu]'\\[^'\"?\\abefnrtv]'"
                                syn match	cSpecialCharacter "[Uu]'\\['\"?\\abefnrtv]'"
   17              0.000019   else
   17              0.000079     syn match	cSpecialError	"[Uu]'\\[^'\"?\\abfnrtv]'"
   17              0.000095     syn match	cSpecialCharacter "[Uu]'\\['\"?\\abfnrtv]'"
   17              0.000017   endif
   17              0.000081   syn match	cSpecialCharacter display "[Uu]'\\\o\{1,3}'"
   17              0.000083   syn match	cSpecialCharacter display "[Uu]'\\x\x\+'"
  208              0.000315 endif
                            
                            "when wanted, highlight trailing white space
  208              0.001385 if exists("c_space_errors")
                              if !exists("c_no_trail_space_error")
                                syn match	cSpaceError	display excludenl "\s\+$"
                              endif
                              if !exists("c_no_tab_space_error")
                                syn match	cSpaceError	display " \+\t"me=e-1
                              endif
  208              0.000266 endif
                            
                            " This should be before cErrInParen to avoid problems with #define ({ xxx })
  208              0.000836 if exists("c_curly_error")
                              syn match cCurlyError "}"
                              syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell fold
  208              0.000340 else
  208              0.001428   syn region	cBlock		start="{" end="}" transparent fold
  208              0.000302 endif
                            
                            " Catch errors caused by wrong parenthesis and brackets.
                            " Also accept <% for {, %> for }, <: for [ and :> for ] (C99)
                            " But avoid matching <::.
  208              0.004249 syn cluster	cParenGroup	contains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
  208              0.000984 if exists("c_no_curly_error")
                              if s:in_cpp_family && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^^<%\|^%>"
                              else
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^[{}]\|^<%\|^%>"
                              endif
  208              0.001028 elseif exists("c_no_bracket_error")
                              if s:in_cpp_family && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "<%\|%>"
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "[{}]\|<%\|%>"
                              endif
  208              0.000645 else
  208              0.000885   if s:in_cpp_family && !exists("cpp_no_cpp11")
    7              0.000074     syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
    7              0.000088     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
    7              0.000028     syn match	cParenError	display "[\])]"
    7              0.000055     syn match	cErrInParen	display contained "<%\|%>"
    7              0.000100     syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
  201              0.000385   else
  201              0.003088     syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
  201              0.003394     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
  201              0.000983     syn match	cParenError	display "[\])]"
  201              0.001157     syn match	cErrInParen	display contained "[\]{}]\|<%\|%>"
  201              0.003367     syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
  208              0.000354   endif
                              " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
  208              0.003857   syn region	cCppBracket	transparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
  208              0.001222   syn match	cErrInBracket	display contained "[);{}]\|<%\|%>"
  208              0.000292 endif
                            
  208              0.001420 if s:ft ==# 'c' || exists("cpp_no_cpp11")
   10              0.000080   syn region	cBadBlock	keepend start="{" end="}" contained containedin=cParen,cBracket,cBadBlock transparent fold
  208              0.000332 endif
                            
                            "integer number, or floating point number without a dot and with "f".
  208              0.000387 syn case ignore
  208              0.002050 syn match	cNumbers	display transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctalError,cOctal
                            " Same, but without octal error (for comments)
  208              0.001548 syn match	cNumbersCom	display contained transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctal
  208              0.001718 syn match	cNumber		display contained "\d\+\%(u\=l\{0,2}\|ll\=u\)\>"
                            "hex number
  208              0.001594 syn match	cNumber		display contained "0x\x\+\%(u\=l\{0,2}\|ll\=u\)\>"
                            " Flag the first zero of an octal number as something special
  208              0.002106 syn match	cOctal		display contained "0\o\+\%(u\=l\{0,2}\|ll\=u\)\>" contains=cOctalZero
  208              0.001001 syn match	cOctalZero	display contained "\<0"
                            "floating point number, with dot, optional exponent
  208              0.001761 syn match	cFloat		display contained "\d\+\.\d*\%(e[-+]\=\d\+\)\=[fl]\="
                            "floating point number, starting with a dot, optional exponent
  208              0.001454 syn match	cFloat		display contained "\.\d\+\%(e[-+]\=\d\+\)\=[fl]\=\>"
                            "floating point number, without dot, with exponent
  208              0.001455 syn match	cFloat		display contained "\d\+e[-+]\=\d\+[fl]\=\>"
  208              0.001171 if !exists("c_no_c99")
                              "hexadecimal floating point number, optional leading digits, with dot, with exponent
  208              0.001630   syn match	cFloat		display contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
                              "hexadecimal floating point number, with leading digits, optional dot, with exponent
  208              0.001444   syn match	cFloat		display contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"
  208              0.000307 endif
                            
                            " flag an octal number with wrong digits
  208              0.001061 syn match	cOctalError	display contained "0\o*[89]\d*"
  208              0.000382 syn case match
                            
  208              0.000931 if exists("c_comment_strings")
                              " A comment can contain cString, cCharacter and cNumber.
                              " But a "*/" inside a cString in a cComment DOES end the comment!  So we
                              " need to use a special type of cString: cCommentString, which also ends on
                              " "*/", and sees a "*" at the start of the line as comment again.
                              " Unfortunately this doesn't very well work for // type of comments :-(
                              syn match	cCommentSkip	contained "^\s*\*\%($\|\s\+\)"
                              syn region cCommentString	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=cSpecial,cCommentSkip
                              syn region cComment2String	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=cSpecial
                              syn region  cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cComment2String,cCharacter,cNumbersCom,cSpaceError,cWrongComTail,@Spell
                              if exists("c_no_comment_fold")
                                " Use "extend" here to have preprocessor lines not terminate halfway a
                                " comment.
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell extend
                              else
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell fold extend
                              endif
  208              0.000242 else
  208              0.002500   syn region	cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cSpaceError,@Spell
  208              0.001034   if exists("c_no_comment_fold")
                                syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell extend
  208              0.000358   else
  208              0.002801     syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell fold extend
  208              0.000306   endif
  208              0.002190 endif
                            " keep a // comment separately, it terminates a preproc. conditional
  208              0.000827 syn match	cCommentError	display "\*/"
  208              0.000999 syn match	cCommentStartError display "/\*"me=e-1 contained
  208              0.000827 syn match	cWrongComTail	display "\*/"
                            
  208              0.000665 syn keyword	cOperator	sizeof
  208              0.000889 if exists("c_gnu")
                              syn keyword	cType		__label__ __complex__
                              syn keyword	cStatement	__asm__
                              syn keyword	cOperator	__alignof__
                              syn keyword	cOperator	typeof __typeof__
                              syn keyword	cOperator	__real__ __imag__
                              syn keyword	cStorageClass	__attribute__ __const__ __extension__
                              syn keyword	cStorageClass	inline __inline__
                              syn keyword	cStorageClass	__restrict__ __volatile__ __noreturn__
  208              0.000223 endif
  208              0.000825 syn keyword	cType		int long short char void
  208              0.000712 syn keyword	cType		signed unsigned float double
  208              0.001066 if !exists("c_no_ansi") || exists("c_ansi_typedefs")
  208              0.001094   syn keyword   cType		size_t ssize_t off_t wchar_t ptrdiff_t sig_atomic_t fpos_t
  208              0.001064   syn keyword   cType		clock_t time_t va_list jmp_buf FILE DIR div_t ldiv_t
  208              0.000907   syn keyword   cType		mbstate_t wctrans_t wint_t wctype_t
  208              0.000253 endif
  208              0.000769 if !exists("c_no_c99") " ISO C99
  208              0.000982   syn keyword	cType		_Bool bool _Complex complex _Imaginary imaginary
  208              0.000624   syn keyword	cType		int8_t int16_t int32_t int64_t
  208              0.000638   syn keyword	cType		uint8_t uint16_t uint32_t uint64_t
  208              0.000786   if !exists("c_no_bsd")
                                " These are BSD specific.
  208              0.000767     syn keyword	cType		u_int8_t u_int16_t u_int32_t u_int64_t
  208              0.000274   endif
  208              0.000635   syn keyword	cType		int_least8_t int_least16_t int_least32_t int_least64_t
  208              0.000717   syn keyword	cType		uint_least8_t uint_least16_t uint_least32_t uint_least64_t
  208              0.000587   syn keyword	cType		int_fast8_t int_fast16_t int_fast32_t int_fast64_t
  208              0.000638   syn keyword	cType		uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
  208              0.000431   syn keyword	cType		intptr_t uintptr_t
  208              0.000467   syn keyword	cType		intmax_t uintmax_t
  208              0.000217 endif
                            
  208              0.000460 syn keyword	cTypedef	typedef
  208              0.000701 syn keyword	cStructure	struct union enum
  208              0.000922 syn keyword	cStorageClass	static register auto volatile extern const
  208              0.000992 if !exists("c_no_c99") && !s:in_cpp_family
  201              0.000574   syn keyword	cStorageClass	inline restrict
  208              0.000231 endif
  208              0.000686 if !exists("c_no_c11")
  208              0.000602   syn keyword	cStorageClass	_Alignas alignas
  208              0.000512   syn keyword	cOperator	_Alignof alignof
  208              0.000442   syn keyword	cStorageClass	_Atomic
  208              0.000421   syn keyword	cOperator	_Generic
  208              0.000494   syn keyword	cStorageClass	_Noreturn noreturn
  208              0.000858   syn keyword	cOperator	_Static_assert static_assert
  208              0.000555   syn keyword	cStorageClass	_Thread_local thread_local
  208              0.000547   syn keyword   cType		char16_t char32_t
  208              0.000397   syn keyword   cType		max_align_t
                              " C11 atomics (take down the shield wall!)
  208              0.000665   syn keyword	cType		atomic_bool atomic_char atomic_schar atomic_uchar
  208              0.000677   syn keyword	Ctype		atomic_short atomic_ushort atomic_int atomic_uint
  208              0.000590   syn keyword	cType		atomic_long atomic_ulong atomic_llong atomic_ullong
  208              0.000594   syn keyword	cType		atomic_char16_t atomic_char32_t atomic_wchar_t
  208              0.000536   syn keyword	cType		atomic_int_least8_t atomic_uint_least8_t
  208              0.000509   syn keyword	cType		atomic_int_least16_t atomic_uint_least16_t
  208              0.000462   syn keyword	cType		atomic_int_least32_t atomic_uint_least32_t
  208              0.000503   syn keyword	cType		atomic_int_least64_t atomic_uint_least64_t
  208              0.000496   syn keyword	cType		atomic_int_fast8_t atomic_uint_fast8_t
  208              0.000470   syn keyword	cType		atomic_int_fast16_t atomic_uint_fast16_t
  208              0.000449   syn keyword	cType		atomic_int_fast32_t atomic_uint_fast32_t
  208              0.000501   syn keyword	cType		atomic_int_fast64_t atomic_uint_fast64_t
  208              0.000487   syn keyword	cType		atomic_intptr_t atomic_uintptr_t
  208              0.000470   syn keyword	cType		atomic_size_t atomic_ptrdiff_t
  208              0.000457   syn keyword	cType		atomic_intmax_t atomic_uintmax_t
  208              0.000217 endif
                            
  208              0.001155 if !exists("c_no_ansi") || exists("c_ansi_constants") || exists("c_gnu")
  208              0.000653   if exists("c_gnu")
                                syn keyword cConstant __GNUC__ __FUNCTION__ __PRETTY_FUNCTION__ __func__
  208              0.000256   endif
  208              0.000970   syn keyword cConstant __LINE__ __FILE__ __DATE__ __TIME__ __STDC__ __STDC_VERSION__ __STDC_HOSTED__
  208              0.001664   syn keyword cConstant CHAR_BIT MB_LEN_MAX MB_CUR_MAX
  208              0.000668   syn keyword cConstant UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
  208              0.000711   syn keyword cConstant CHAR_MIN INT_MIN LONG_MIN SHRT_MIN
  208              0.000656   syn keyword cConstant CHAR_MAX INT_MAX LONG_MAX SHRT_MAX
  208              0.001989   syn keyword cConstant SCHAR_MIN SINT_MIN SLONG_MIN SSHRT_MIN
  208              0.000762   syn keyword cConstant SCHAR_MAX SINT_MAX SLONG_MAX SSHRT_MAX
  208              0.000887   if !exists("c_no_c99")
  208              0.000625     syn keyword cConstant __func__ __VA_ARGS__
  208              0.000617     syn keyword cConstant LLONG_MIN LLONG_MAX ULLONG_MAX
  208              0.000661     syn keyword cConstant INT8_MIN INT16_MIN INT32_MIN INT64_MIN
  208              0.000619     syn keyword cConstant INT8_MAX INT16_MAX INT32_MAX INT64_MAX
  208              0.000683     syn keyword cConstant UINT8_MAX UINT16_MAX UINT32_MAX UINT64_MAX
  208              0.000757     syn keyword cConstant INT_LEAST8_MIN INT_LEAST16_MIN INT_LEAST32_MIN INT_LEAST64_MIN
  208              0.000746     syn keyword cConstant INT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST64_MAX
  208              0.000730     syn keyword cConstant UINT_LEAST8_MAX UINT_LEAST16_MAX UINT_LEAST32_MAX UINT_LEAST64_MAX
  208              0.000687     syn keyword cConstant INT_FAST8_MIN INT_FAST16_MIN INT_FAST32_MIN INT_FAST64_MIN
  208              0.000632     syn keyword cConstant INT_FAST8_MAX INT_FAST16_MAX INT_FAST32_MAX INT_FAST64_MAX
  208              0.000663     syn keyword cConstant UINT_FAST8_MAX UINT_FAST16_MAX UINT_FAST32_MAX UINT_FAST64_MAX
  208              0.000582     syn keyword cConstant INTPTR_MIN INTPTR_MAX UINTPTR_MAX
  208              0.000578     syn keyword cConstant INTMAX_MIN INTMAX_MAX UINTMAX_MAX
  208              0.000694     syn keyword cConstant PTRDIFF_MIN PTRDIFF_MAX SIG_ATOMIC_MIN SIG_ATOMIC_MAX
  208              0.000713     syn keyword cConstant SIZE_MAX WCHAR_MIN WCHAR_MAX WINT_MIN WINT_MAX
  208              0.000268   endif
  208              0.001094   syn keyword cConstant FLT_RADIX FLT_ROUNDS FLT_DIG FLT_MANT_DIG FLT_EPSILON DBL_DIG DBL_MANT_DIG DBL_EPSILON
  208              0.001182   syn keyword cConstant LDBL_DIG LDBL_MANT_DIG LDBL_EPSILON FLT_MIN FLT_MAX FLT_MIN_EXP FLT_MAX_EXP FLT_MIN_10_EXP FLT_MAX_10_EXP
  208              0.001229   syn keyword cConstant DBL_MIN DBL_MAX DBL_MIN_EXP DBL_MAX_EXP DBL_MIN_10_EXP DBL_MAX_10_EXP LDBL_MIN LDBL_MAX LDBL_MIN_EXP LDBL_MAX_EXP
  208              0.001112   syn keyword cConstant LDBL_MIN_10_EXP LDBL_MAX_10_EXP HUGE_VAL CLOCKS_PER_SEC NULL LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY
  208              0.001300   syn keyword cConstant LC_NUMERIC LC_TIME SIG_DFL SIG_ERR SIG_IGN SIGABRT SIGFPE SIGILL SIGHUP SIGINT SIGSEGV SIGTERM
                              " Add POSIX signals as well...
  208              0.001316   syn keyword cConstant SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
  208              0.001061   syn keyword cConstant SIGSTOP SIGTERM SIGTRAP SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2
  208              0.001115   syn keyword cConstant _IOFBF _IOLBF _IONBF BUFSIZ EOF WEOF FOPEN_MAX FILENAME_MAX L_tmpnam
  208              0.001236   syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET TMP_MAX stderr stdin stdout EXIT_FAILURE EXIT_SUCCESS RAND_MAX
                              " used in assert.h
  208              0.000438   syn keyword cConstant NDEBUG
                              " POSIX 2001
  208              0.000986   syn keyword cConstant SIGBUS SIGPOLL SIGPROF SIGSYS SIGURG SIGVTALRM SIGXCPU SIGXFSZ
                              " non-POSIX signals
  208              0.000757   syn keyword cConstant SIGWINCH SIGINFO
                              " Add POSIX errors as well.  List comes from:
                              " http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
  208              0.001015   syn keyword cConstant E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY EBADF
  208              0.001037   syn keyword cConstant EBADMSG EBUSY ECANCELED ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
  208              0.001086   syn keyword cConstant EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTUNREACH EIDRM EILSEQ
  208              0.001134   syn keyword cConstant EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE
  208              0.001009   syn keyword cConstant EMULTIHOP ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS ENODATA
  208              0.001209   syn keyword cConstant ENODEV ENOENT ENOEXEC ENOLCK ENOLINK ENOMEM ENOMSG ENOPROTOOPT ENOSPC ENOSR
  208              0.001071   syn keyword cConstant ENOSTR ENOSYS ENOTBLK ENOTCONN ENOTDIR ENOTEMPTY ENOTRECOVERABLE ENOTSOCK ENOTSUP
  208              0.001021   syn keyword cConstant ENOTTY ENXIO EOPNOTSUPP EOVERFLOW EOWNERDEAD EPERM EPIPE EPROTO
  208              0.001019   syn keyword cConstant EPROTONOSUPPORT EPROTOTYPE ERANGE EROFS ESPIPE ESRCH ESTALE ETIME ETIMEDOUT
  208              0.000603   syn keyword cConstant ETXTBSY EWOULDBLOCK EXDEV
                              " math.h
  208              0.000872   syn keyword cConstant M_E M_LOG2E M_LOG10E M_LN2 M_LN10 M_PI M_PI_2 M_PI_4
  208              0.000681   syn keyword cConstant M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2
  208              0.000232 endif
  208              0.000836 if !exists("c_no_c99") " ISO C99
  208              0.000639   syn keyword cConstant true false
  208              0.002259 endif
                            
                            " Accept %: for # (C99)
  208              0.006044 syn region	cPreCondit	start="^\s*\zs\%(%:\|#\)\s*\%(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" keepend contains=cComment,cCommentL,cCppString,cCharacter,cCppParen,cParenError,cNumbers,cCommentError,cSpaceError
  208              0.002061 syn match	cPreConditMatch	display "^\s*\zs\%(%:\|#\)\s*\%(else\|endif\)\>"
  208              0.001018 if !exists("c_no_if0")
  208              0.002088   syn cluster	cCppOutInGroup	contains=cCppInIf,cCppInElse,cCppInElse2,cCppOutIf,cCppOutIf2,cCppOutElse,cCppInSkip,cCppOutSkip
  208              0.003763   syn region	cCppOutWrapper	start="^\s*\zs\%(%:\|#\)\s*if\s\+0\+\s*\%($\|//\|/\*\|&\)" end=".\@=\|$" contains=cCppOutIf,cCppOutElse,@NoSpell fold
  208              0.002767   syn region	cCppOutIf	contained start="0\+" matchgroup=cCppOutWrapper end="^\s*\%(%:\|#\)\s*endif\>" contains=cCppOutIf2,cCppOutElse
  208              0.001093   if !exists("c_no_if0_fold")
  208              0.004678     syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\%(%:\|#\)\s*\%(else\>\|elif\s\+\%(0\+\s*\%($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell fold
                              else
                                syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\%(%:\|#\)\s*\%(else\>\|elif\s\+\%(0\+\s*\%($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
  208              0.000700   endif
  208              0.003323   syn region	cCppOutElse	contained matchgroup=cCppOutWrapper start="^\s*\%(%:\|#\)\s*\%(else\|elif\)" end="^\s*\%(%:\|#\)\s*endif\>"me=s-1 contains=TOP,cPreCondit
  208              0.003673   syn region	cCppInWrapper	start="^\s*\zs\%(%:\|#\)\s*if\s\+0*[1-9]\d*\s*\%($\|//\|/\*\||\)" end=".\@=\|$" contains=cCppInIf,cCppInElse fold
  208              0.002527   syn region	cCppInIf	contained matchgroup=cCppInWrapper start="\d\+" end="^\s*\%(%:\|#\)\s*endif\>" contains=TOP,cPreCondit
  208              0.001094   if !exists("c_no_if0_fold")
  208              0.003899     syn region	cCppInElse	contained start="^\s*\%(%:\|#\)\s*\%(else\>\|elif\s\+\%(0*[1-9]\d*\s*\%($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2 fold
                              else
                                syn region	cCppInElse	contained start="^\s*\%(%:\|#\)\s*\%(else\>\|elif\s\+\%(0*[1-9]\d*\s*\%($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2
  208              0.000389   endif
  208              0.004050   syn region	cCppInElse2	contained matchgroup=cCppInWrapper start="^\s*\%(%:\|#\)\s*\%(else\|elif\)\%([^/]\|/[^/*]\)*" end="^\s*\%(%:\|#\)\s*endif\>"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
  208              0.004132   syn region	cCppOutSkip	contained start="^\s*\%(%:\|#\)\s*\%(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\%(%:\|#\)\s*endif\>" contains=cSpaceError,cCppOutSkip
  208              0.005531   syn region	cCppInSkip	contained matchgroup=cCppInWrapper start="^\s*\%(%:\|#\)\s*\%(if\s\+\%(\d\+\s*\%($\|//\|/\*\||\|&\)\)\@!\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\%(%:\|#\)\s*endif\>" containedin=cCppOutElse,cCppInIf,cCppInSkip contains=TOP,cPreProc
  208              0.000356 endif
  208              0.002121 syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
  208              0.001167 syn match	cIncluded	display contained "<[^>]*>"
  208              0.002081 syn match	cInclude	display "^\s*\zs\%(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
                            "syn match cLineSkip	"\\$"
  208              0.005641 syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cErrInParen,cErrInBracket,cUserLabel,cSpecial,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cString,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cParen,cBracket,cMulti,cBadBlock
  208              0.004460 syn region	cDefine		start="^\s*\zs\%(%:\|#\)\s*\%(define\|undef\)\>" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
  208              0.004269 syn region	cPreProc	start="^\s*\zs\%(%:\|#\)\s*\%(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
                            
                            " Optional embedded Autodoc parsing
  208              0.001073 if exists("c_autodoc")
                              syn match cAutodocReal display contained "\%(//\|[/ \t\v]\*\|^\*\)\@2<=!.*" contains=@cAutodoc containedin=cComment,cCommentL
                              syn cluster cCommentGroup add=cAutodocReal
                              syn cluster cPreProcGroup add=cAutodocReal
  208              0.000229 endif
                            
                            " be able to fold #pragma regions
  208              0.002760 syn region	cPragma		start="^\s*#pragma\s\+region\>" end="^\s*#pragma\s\+endregion\>" transparent keepend extend fold
                            
                            " Highlight User Labels
  208              0.004760 syn cluster	cMultiGroup	contains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
  208              0.001429 if s:ft ==# 'c' || exists("cpp_no_cpp11")
   10              0.000116   syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell,@cStringGroup
  208              0.000333 endif
                            " Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
  208              0.000783 syn cluster	cLabelGroup	contains=cUserLabel
  208              0.001743 syn match	cUserCont	display "^\s*\zs\I\i*\s*:$" contains=@cLabelGroup
  208              0.001509 syn match	cUserCont	display ";\s*\zs\I\i*\s*:$" contains=@cLabelGroup
  208              0.000662 if s:in_cpp_family
    7              0.000070   syn match	cUserCont	display "^\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
    7              0.000057   syn match	cUserCont	display ";\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
  201              0.000353 else
  201              0.001497   syn match	cUserCont	display "^\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
  201              0.001535   syn match	cUserCont	display ";\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
  208              0.000329 endif
                            
  208              0.000959 syn match	cUserLabel	display "\I\i*" contained
                            
                            " Avoid recognizing most bitfields as labels
  208              0.001840 syn match	cBitField	display "^\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
  208              0.001582 syn match	cBitField	display ";\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
                            
  208              0.000964 if exists("c_minlines")
                              let b:c_minlines = c_minlines
  208              0.000232 else
  208              0.000739   if !exists("c_no_if0")
  208              0.001018     let b:c_minlines = 50	" #if 0 constructs can be long
                              else
                                let b:c_minlines = 15	" mostly for () constructs
  208              0.000229   endif
  208              0.000182 endif
  208              0.000749 if exists("c_curly_error")
                              syn sync fromstart
  208              0.000230 else
  208              0.002090   exec "syn sync ccomment cComment minlines=" . b:c_minlines
  208              0.000275 endif
                            
                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
  208              0.000680 hi def link cFormat		cSpecial
  208              0.000371 hi def link cCppString		cString
  208              0.000435 hi def link cCommentL		cComment
  208              0.000333 hi def link cCommentStart	cComment
  208              0.000323 hi def link cLabel		Label
  208              0.000330 hi def link cUserLabel		Label
  208              0.000353 hi def link cConditional	Conditional
  208              0.000332 hi def link cRepeat		Repeat
  208              0.000329 hi def link cCharacter		Character
  208              0.000349 hi def link cSpecialCharacter	cSpecial
  208              0.000324 hi def link cNumber		Number
  208              0.000331 hi def link cOctal		Number
  208              0.000398 hi def link cOctalZero		PreProc	 " link this to Error if you want
  208              0.000330 hi def link cFloat		Float
  208              0.000316 hi def link cOctalError		cError
  208              0.000302 hi def link cParenError		cError
  208              0.000286 hi def link cErrInParen		cError
  208              0.000399 hi def link cErrInBracket	cError
  208              0.000303 hi def link cCommentError	cError
  208              0.000340 hi def link cCommentStartError	cError
  208              0.000294 hi def link cSpaceError		cError
  208              0.000311 hi def link cWrongComTail	cError
  208              0.000292 hi def link cSpecialError	cError
  208              0.000303 hi def link cCurlyError		cError
  208              0.000326 hi def link cOperator		Operator
  208              0.000359 hi def link cStructure		Structure
  208              0.000307 hi def link cTypedef		Structure
  208              0.000349 hi def link cStorageClass	StorageClass
  208              0.000307 hi def link cInclude		Include
  208              0.000368 hi def link cPreProc		PreProc
  208              0.000325 hi def link cDefine		Macro
  208              0.000298 hi def link cIncluded		cString
  208              0.000296 hi def link cError		Error
  208              0.000316 hi def link cStatement		Statement
  208              0.000368 hi def link cCppInWrapper	cCppOutWrapper
  208              0.000349 hi def link cCppOutWrapper	cPreCondit
  208              0.000357 hi def link cPreConditMatch	cPreCondit
  208              0.000349 hi def link cPreCondit		PreCondit
  208              0.000295 hi def link cType		Type
  208              0.000332 hi def link cConstant		Constant
  208              0.000340 hi def link cCommentString	cString
  208              0.000312 hi def link cComment2String	cString
  208              0.000405 hi def link cCommentSkip	cComment
  208              0.000353 hi def link cString		String
  208              0.000305 hi def link cComment		Comment
  208              0.000346 hi def link cSpecial		SpecialChar
  208              0.000300 hi def link cTodo		Todo
  208              0.000325 hi def link cBadContinuation	Error
  208              0.000483 hi def link cCppOutSkip		cCppOutIf2
  208              0.000333 hi def link cCppInElse2		cCppOutIf2
  208              0.000316 hi def link cCppOutIf2		cCppOut
  208              0.000310 hi def link cCppOut		Comment
                            
  208              0.000778 let b:current_syntax = "c"
                            
  208              0.000641 unlet s:ft
                            
  208              0.004676 let &cpo = s:cpo_save
  208              0.000623 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/cpp.vim
Sourced 7 times
Total time:   0.065857
 Self time:   0.063003

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2020 Jul 26
                            
                            " Only do this when not done yet for this buffer
    7              0.000142 if exists("b:did_ftplugin")
                              finish
    7              0.000011 endif
                            
                            " Behaves mostly just like C
    7   0.037079   0.034226 runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
    7              0.027583 runtime! ftplugin/c.lua ftplugin/c_*.lua ftplugin/c/*.lua
                            
                            " C++ uses templates with <things>
                            " Disabled, because it gives an error for typing an unmatched ">".
                            " set matchpairs+=<:>
                            " let b:undo_ftplugin ..= ' | setl matchpairs<'

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/c.vim
Sourced 17 times
Total time:   0.005724
 Self time:   0.005724

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2022 Apr 08
                            
                            " Only do this when not done yet for this buffer
   17              0.000318 if exists("b:did_ftplugin")
                              finish
   17              0.000027 endif
                            
                            " Don't load another plugin for this buffer
   17              0.000128 let b:did_ftplugin = 1
                            
                            " Using line continuation here.
   17              0.000268 let s:cpo_save = &cpo
   17              0.000449 set cpo-=C
                            
   17              0.000085 let b:undo_ftplugin = "setl fo< com< ofu< cms< def< inc<"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
   17              0.000440 setlocal fo-=t fo+=croql
                            
                            " These options have the right value as default, but the user may have
                            " overruled that.
   17              0.000184 setlocal commentstring& define& include&
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
   17              0.000165 if exists('&ofu')
   17              0.000241   setlocal ofu=ccomplete#Complete
   17              0.000034 endif
                            
                            " Set 'comments' to format dashed lists in comments.
                            " Also include ///, used for Doxygen.
   17              0.000125  setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,:///,://
                            
                            " When the matchit plugin is loaded, this makes the % command skip parens and
                            " braces in comments properly.
   17              0.000097 if !exists("b:match_words")
   17              0.000097   let b:match_words = '^\s*#\s*if\(\|def\|ndef\)\>:^\s*#\s*elif\>:^\s*#\s*else\>:^\s*#\s*endif\>'
   17              0.000065   let b:match_skip = 's:comment\|string\|character\|special'
   17              0.000103   let b:undo_ftplugin ..= " | unlet! b:match_skip b:match_words"
   17              0.000025 endif
                            
                            " Win32 can filter files in the browse dialog
   17              0.000262 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              if &ft == "cpp"
                                let b:browsefilter = "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              elseif &ft == "ch"
                                let b:browsefilter = "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              else
                                let b:browsefilter = "C Source Files (*.c)\t*.c\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
   17              0.000020 endif
                            
   17              0.000059 let b:man_default_sects = '3,2'
                            
   17              0.000368 let &cpo = s:cpo_save
   17              0.000130 unlet s:cpo_save

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/indent/cpp.vim
Sourced 7 times
Total time:   0.000776
 Self time:   0.000776

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Nov 29
                            
                            " Only load this indent file when no other was loaded.
    7              0.000064 if exists("b:did_indent")
                               finish
    7              0.000008 endif
    7              0.000032 let b:did_indent = 1
                            
                            " C++ indenting is built-in, thus this is very simple
    7              0.000079 setlocal cindent
                            
    7              0.000053 let b:undo_indent = "setl cin<"

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/cpp.vim
Sourced 7 times
Total time:   0.025387
 Self time:   0.009767

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C++
                            " Current Maintainer:	vim-jp (https://github.com/vim-jp/vim-cpp)
                            " Previous Maintainer:	Ken Shan <ccshan@post.harvard.edu>
                            " Last Change:	2021 Aug 23
                            
                            " quit when a syntax file was already loaded
    7              0.000117 if exists("b:current_syntax")
                              finish
    7              0.000016 endif
                            
                            " inform C syntax that the file was included from cpp.vim
    7              0.000038 let b:filetype_in_cpp_family = 1
                            
                            " Read the C syntax to start with
    7   0.020469   0.004849 runtime! syntax/c.vim
    7              0.000037 unlet b:current_syntax
                            
                            " C++ extensions
    7              0.000042 syn keyword cppStatement	new delete this friend using
    7              0.000020 syn keyword cppAccess		public protected private
    7              0.000020 syn keyword cppModifier		inline virtual explicit export
    7              0.000015 syn keyword cppType		bool wchar_t
    7              0.000016 syn keyword cppExceptions	throw try catch
    7              0.000019 syn keyword cppOperator		operator typeid
    7              0.000030 syn keyword cppOperator		and bitor or xor compl bitand and_eq or_eq xor_eq not not_eq
    7              0.000081 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*<"me=e-1
    7              0.000056 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*$"
    7              0.000016 syn keyword cppStorageClass	mutable
    7              0.000020 syn keyword cppStructure	class typename template namespace
    7              0.000017 syn keyword cppBoolean		true false
    7              0.000012 syn keyword cppConstant		__cplusplus
                            
                            " C++ 11 extensions
    7              0.000038 if !exists("cpp_no_cpp11")
    7              0.000018   syn keyword cppModifier	override final
    7              0.000403   syn keyword cppType		nullptr_t auto
    7              0.000013   syn keyword cppExceptions	noexcept
    7              0.000018   syn keyword cppStorageClass	constexpr decltype thread_local
    7              0.000012   syn keyword cppConstant	nullptr
    7              0.000017   syn keyword cppConstant	ATOMIC_FLAG_INIT ATOMIC_VAR_INIT
    7              0.000016   syn keyword cppConstant	ATOMIC_BOOL_LOCK_FREE ATOMIC_CHAR_LOCK_FREE
    7              0.000013   syn keyword cppConstant	ATOMIC_CHAR16_T_LOCK_FREE ATOMIC_CHAR32_T_LOCK_FREE
    7              0.000013   syn keyword cppConstant	ATOMIC_WCHAR_T_LOCK_FREE ATOMIC_SHORT_LOCK_FREE
    7              0.000013   syn keyword cppConstant	ATOMIC_INT_LOCK_FREE ATOMIC_LONG_LOCK_FREE
    7              0.000015   syn keyword cppConstant	ATOMIC_LLONG_LOCK_FREE ATOMIC_POINTER_LOCK_FREE
    7              0.000353   syn region cppRawString	matchgroup=cppRawStringDelimiter start=+\%(u8\|[uLU]\)\=R"\z([[:alnum:]_{}[\]#<>%:;.?*\+\-/\^&|~!=,"']\{,16}\)(+ end=+)\z1"\(sv\|s\|_[_a-zA-Z][_a-zA-Z0-9]*\)\=+ contains=@Spell
    7              0.000071   syn match cppCast		"\<\(const\|static\|dynamic\)_pointer_cast\s*<"me=e-1
    7              0.000053   syn match cppCast		"\<\(const\|static\|dynamic\)_pointer_cast\s*$"
    7              0.000009 endif
                            
                            " C++ 14 extensions
    7              0.000029 if !exists("cpp_no_cpp14")
    7              0.000049   syn match cppNumbers		display transparent "\<\d\|\.\d" contains=cppNumber,cppFloat
    7              0.000088   syn match cppNumber		display contained "\<0\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000103   syn match cppNumber		display contained "\<[1-9]\('\=\d\+\)*\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000076   syn match cppNumber		display contained "\<0\o\+\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000086   syn match cppNumber		display contained "\<0b[01]\('\=[01]\+\)*\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000075   syn match cppNumber		display contained "\<0x\x\('\=\x\+\)*\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000077   syn match cppFloat		display contained "\<\d\+\.\d*\(e[-+]\=\d\+\)\=\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000082   syn match cppFloat		display contained "\<\.\d\+\(e[-+]\=\d\+\)\=\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000067   syn match cppFloat		display contained "\<\d\+e[-+]\=\d\+\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000175   syn region cppString		start=+\(L\|u\|u8\|U\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"\(sv\|s\|_\i*\)\=+ end='$' contains=cSpecial,cFormat,@Spell
    7              0.000010 endif
                            
                            " C++ 17 extensions
    7              0.000028 if !exists("cpp_no_cpp17")
    7              0.000055   syn match cppCast		"\<reinterpret_pointer_cast\s*<"me=e-1
    7              0.000040   syn match cppCast		"\<reinterpret_pointer_cast\s*$"
    7              0.000068   syn match cppFloat		display contained "\<0x\x*\.\x\+p[-+]\=\d\+\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    7              0.000060   syn match cppFloat		display contained "\<0x\x\+\.\=p[-+]\=\d\+\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
                            
                              " TODO: push this up to c.vim if/when supported in C23
    7              0.000028   syn match cppCharacter	"u8'[^\\]'"
    7              0.000033   syn match cppCharacter	"u8'[^']*'" contains=cSpecial
    7              0.000026   if exists("c_gnu")
                                syn match cppSpecialError	  "u8'\\[^'\"?\\abefnrtv]'"
                                syn match cppSpecialCharacter "u8'\\['\"?\\abefnrtv]'"
    7              0.000010   else
    7              0.000031     syn match cppSpecialError	  "u8'\\[^'\"?\\abfnrtv]'"
    7              0.000036     syn match cppSpecialCharacter "u8'\\['\"?\\abfnrtv]'"
    7              0.000008   endif
    7              0.000032   syn match cppSpecialCharacter display "u8'\\\o\{1,3}'"
    7              0.000028   syn match cppSpecialCharacter display "u8'\\x\x\+'"
                            
    7              0.000006 endif
                            
                            " C++ 20 extensions
    7              0.000025 if !exists("cpp_no_cpp20")
    7              0.000033   syn match cppNumber		display contained "\<0\(y\|d\)\>"
    7              0.000042   syn match cppNumber		display contained "\<[1-9]\('\=\d\+\)*\(y\|d\)\>"
    7              0.000037   syn match cppNumber		display contained "\<0\o\+\(y\|d\)\>"
    7              0.000041   syn match cppNumber		display contained "\<0b[01]\('\=[01]\+\)*\(y\|d\)\>"
    7              0.000038   syn match cppNumber		display contained "\<0x\x\('\=\x\+\)*\(y\|d\)\>"
    7              0.000025   syn keyword cppStatement	co_await co_return co_yield requires
    7              0.000017   syn keyword cppStorageClass	consteval constinit
    7              0.000013   syn keyword cppStructure	concept
    7              0.000012   syn keyword cppType		char8_t
    7              0.000018   syn keyword cppModule		import module export
    7              0.000006 endif
                            
                            " The minimum and maximum operators in GNU C++
    7              0.000033 syn match cppMinMax "[<>]?"
                            
                            " Default highlighting
    7              0.000017 hi def link cppAccess		cppStatement
    7              0.000010 hi def link cppCast		cppStatement
    7              0.000010 hi def link cppExceptions		Exception
    7              0.000009 hi def link cppOperator		Operator
    7              0.000008 hi def link cppStatement		Statement
    7              0.000009 hi def link cppModifier		Type
    7              0.000008 hi def link cppType		Type
    7              0.000009 hi def link cppStorageClass	StorageClass
    7              0.000492 hi def link cppStructure		Structure
    7              0.000009 hi def link cppBoolean		Boolean
    7              0.000009 hi def link cppCharacter		cCharacter
    7              0.000010 hi def link cppSpecialCharacter		cSpecialCharacter
    7              0.000009 hi def link cppSpecialError		cSpecialError
    7              0.000009 hi def link cppConstant		Constant
    7              0.000010 hi def link cppRawStringDelimiter	Delimiter
    7              0.000009 hi def link cppRawString		String
    7              0.000008 hi def link cppString		String
    7              0.000008 hi def link cppNumber		Number
    7              0.000008 hi def link cppFloat		Number
    7              0.000008 hi def link cppModule		Include
                            
    7              0.000027 let b:current_syntax = "cpp"
                            
                            " vim: ts=8

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/indent/c.vim
Sourced 10 times
Total time:   0.000678
 Self time:   0.000678

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2005 Mar 27
                            
                            " Only load this indent file when no other was loaded.
   10              0.000110 if exists("b:did_indent")
                               finish
   10              0.000013 endif
   10              0.000050 let b:did_indent = 1
                            
                            " C indenting is built-in, thus this is very simple
   10              0.000124 setlocal cindent
                            
   10              0.000071 let b:undo_indent = "setl cin<"

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim
Sourced 1 time
Total time:   0.001521
 Self time:   0.001521

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Commands
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Functions in this script are associated with plugs, all commands that can
                            " start VM have their entry point here.
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Function: s:init
                            " Most commands call this function to ensure VM is initialized.
                            " @param whole: use word boundaries
                            " @param type: 0 if a pattern will be added, 1 if not, 2 if using regex
                            " @param extend_mode: 1 if forcing extend mode
                            " Returns: 1 if VM was already active when called
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            ""
    1              0.000015 fun! s:init(whole, type, extend_mode) abort
                                " Ensure the buffer is initialized, set starting options.
                                if a:extend_mode | let g:Vm.extend_mode = 1 | endif
                            
                                if g:Vm.buffer
                                    call s:F.Scroll.get()
                                    if s:v.using_regex | call vm#commands#regex_reset() | endif
                                    let s:v.whole_word = a:whole
                                    return 1    " return true if already initialized
                                else
                                    let error = vm#init_buffer(a:type)
                                    if type(error) == v:t_string | throw error | endif
                                    call s:F.Scroll.get()
                                    let s:v.whole_word = a:whole
                                endif
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#init() abort
                                " Variables initialization.
                                let s:V        = b:VM_Selection
                                let s:v        = s:V.Vars
                                let s:G        = s:V.Global
                                let s:F        = s:V.Funcs
                                let s:Search   = s:V.Search
                                let s:v.motion = ''
                            endfun
                            
                            
    1              0.000005 fun! s:set_extend_mode(X) abort
                                " If just starting, enable extend mode if appropriate.
                            
                                if s:X() || a:X | return s:init(0, 1, 1)
                                else            | return s:init(0, 1, 0)
                                endif
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Add cursor
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 fun! s:skip_shorter_lines() abort
                                " When adding cursors below or above, don't add on shorter lines.
                                " we don't want cursors on final column('$'), except when adding at column 1
                                " in this case, moving to an empty line would give:
                                "   vcol     = 1
                                "   col      = 1
                                "   endline  = 1
                                " and the line would be skipped: check endline as 2, so that the cursor is added
                            
                                if get(g:, 'VM_skip_shorter_lines', 1)
                                    let vcol    = s:v.vertical_col
                                    let col     = virtcol('.')
                                    let endline = get(g:, 'VM_skip_empty_lines', 0) ? virtcol('$') :
                                                \                                     virtcol('$') > 1 ?
                                                \                                     virtcol('$') : 2
                            
                                    "skip line
                                    if ( col < vcol || col == endline ) | return 1 | endif
                                endif
                            
                                call s:G.new_cursor()
                            endfun
                            
                            
    1              0.000004 fun! s:went_too_far() abort
                                " If gone too far, because it skipped all lines, reselect region.
                                if empty(s:G.region_at_pos())
                                    call s:G.select_region(s:v.index)
                                endif
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#add_cursor_at_pos(extend) abort
                                " Add/toggle a single cursor at current position.
                                call s:set_extend_mode(a:extend)
                                call s:G.new_cursor(1)
                            endfun
                            
                            
    1              0.000005 fun! vm#commands#add_cursor_down(extend, count) abort
                                " Add cursors vertically, downwards.
                                if s:last_line() | return | endif
                                call s:set_extend_mode(a:extend)
                                let s:v.vertical_col = s:F.get_vertcol()
                                call s:G.new_cursor()
                                let N = a:count
                            
                                while N
                                    normal! j
                                    if !s:skip_shorter_lines() | let N -= 1 | endif
                                    if s:last_line()           | break      | endif
                                endwhile
                            
                                call s:went_too_far()
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#add_cursor_up(extend, count) abort
                                " Add cursors vertically, upwards.
                                if s:first_line() | return | endif
                                call s:set_extend_mode(a:extend)
                                let s:v.vertical_col = s:F.get_vertcol()
                                call s:G.new_cursor()
                                let N = a:count
                            
                                while N
                                    normal! k
                                    if !s:skip_shorter_lines() | let N -= 1 | endif
                                    if s:first_line()          | break      | endif
                                endwhile
                            
                                call s:went_too_far()
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#add_cursor_at_word(yank, search) abort
                                " Add a pattern for current word, place cursor at word begin.
                                call s:init(0, 1, 0)
                            
                                if a:yank
                                    keepjumps normal! viwy`[
                                endif
                                if a:search | call s:Search.add() | endif
                            
                                let R = s:G.new_cursor() | let R.pat = s:v.search[0]
                                call s:F.restore_reg()
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Find by regex
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 fun! vm#commands#find_by_regex(mode) abort
                                " Entry point for VM regex search.
                                if !g:Vm.buffer | call s:init(0, 2, 1) | endif
                                let s:v.using_regex = a:mode
                                let s:v.regex_backup = empty(@/) ? '\%^' : @/
                            
                                "if visual regex, reposition cursor to the beginning of the selection
                                if a:mode == 2
                                    keepjumps normal! `<
                                endif
                            
                                "store position, restored if the search will be aborted
                                let s:regex_pos = winsaveview()
                            
                                cnoremap <silent> <buffer> <cr>  <cr>:call vm#commands#regex_done()<cr>
                                cnoremap <silent><nowait><buffer> <esc><esc> <C-u><C-r>=b:VM_Selection.Vars.regex_backup<cr><esc>:call vm#commands#regex_abort()<cr>
                                cnoremap <silent><nowait><buffer> <esc>      <C-u><C-r>=b:VM_Selection.Vars.regex_backup<cr><esc>:call vm#commands#regex_abort()<cr>
                                call s:F.special_statusline('VM-REGEX')
                                return '/'
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#regex_done() abort
                                " Terminate the VM regex mode after having entered search a pattern.
                                let s:v.visual_regex = s:v.using_regex == 2
                                let extend_current = s:v.using_regex == 3
                                call vm#commands#regex_reset()
                            
                                if s:v.visual_regex
                                    call s:Search.get_slash_reg()
                                    let g:Vm.finding = 1
                                    silent keepjumps normal! gv
                                    exe "silent normal \<Plug>(VM-Visual-Find)"
                                    return
                            
                                elseif extend_current
                                    call vm#commands#regex_motion(@/, 1, 0)
                                    return
                            
                                elseif s:X() | silent keepjumps normal! gny`]
                                else         | silent keepjumps normal! gny
                                endif
                                call s:Search.get_slash_reg()
                            
                                if s:X()
                                    call s:G.new_region()
                                else
                                    call vm#commands#add_cursor_at_word(0, 0)
                                endif
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#regex_abort()
                                " Abort the VM regex mode.
                                call winrestview(s:regex_pos)
                                call vm#commands#regex_reset()
                                if !len(s:R())
                                    call feedkeys("\<esc>")
                                else
                                    call s:F.msg('Regex search aborted. ')
                                endif
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#regex_reset(...) abort
                                " Reset the VM regex mode.
                                silent! cunmap <buffer> <cr>
                                silent! cunmap <buffer> <esc>
                                silent! cunmap <buffer> <esc><esc>
                                let s:v.using_regex = 0
                                silent! unlet s:v.statusline_mode
                                if a:0 | return a:1 | endif
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Find commands
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000003 fun! vm#commands#ctrln(count) abort
                                " Ctrl-N command: find word under cursor.
                                call s:init(1, 0, 0)
                                let no_reselect = get(g:, 'VM_notify_previously_selected', 0) == 2
                            
                                if !s:X() && s:is_r()
                                    let pos = getpos('.')[1:2]
                                    call vm#operators#select(1, "iw")
                                    call s:G.update_and_select_region(pos)
                                else
                                    for i in range(a:count)
                                        call vm#commands#find_under(0, 1, 1)
                                        if no_reselect && s:v.was_region_at_pos
                                            break
                                        endif
                                    endfor
                                endif
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#find_under(visual, whole, ...) abort
                                " Generic command that adds word under cursor. Used by C-N and variations.
                                call s:init(a:whole, 0, 1)
                            
                                "Ctrl-N command
                                if a:0 && s:is_r() | return vm#commands#find_next(0, 0) | endif
                            
                                " yank and create region
                                if !a:visual | exe 'normal! viwy`]' | endif
                            
                                "replace region if calling the command on an existing region
                                if s:is_r() | call s:G.region_at_pos().remove() | endif
                            
                                call s:Search.add()
                                let R = s:G.new_region()
                                call s:G.check_mutliline(0, R)
                                return (a:0 && a:visual)? s:G.region_at_pos() : s:G.merge_overlapping(R)
                            endfun
                            
                            
    1              0.000011 fun! vm#commands#find_all(visual, whole) abort
                                " Find all words under cursor or occurrences of visual selection.
                                call s:init(a:whole, 0, 1)
                            
                                let pos = getpos('.')[1:2]
                                let s:v.eco = 1
                            
                                if !a:visual
                                    let R = s:G.region_at_pos()
                                    if empty(R)
                                        let R = vm#commands#find_under(0, a:whole)
                                    endif
                                    call s:Search.update_patterns(R.pat)
                                else
                                    let R = vm#commands#find_under(1, a:whole)
                                endif
                            
                                call s:Search.join()
                                let s:v.nav_direction = 1
                                call s:G.erase_regions()
                                call s:G.get_all_regions()
                            
                                let s:v.restore_scroll = 1
                                return s:G.update_map_and_select_region(pos)
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Find next/previous
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 fun! s:get_region(next) abort
                                " Call the needed function and notify if reselecting a region.
                                if !get(g:, 'VM_notify_previously_selected', 0)
                                    try
                                        return a:next ? s:get_next() : s:get_prev()
                                    catch /E38[45]/
                                        redraw
                                        let dir = a:next ? 'BOTTOM' : 'TOP'
                                        call s:F.msg(printf("Search hit %s without a match for %s", dir, @/))
                                        return s:G.select_region_at_pos('.')
                                    endtry
                                endif
                                normal! m`
                                echo "\r"
                                let R = a:next ? s:get_next() : s:get_prev()
                                if s:v.was_region_at_pos
                                    if g:VM_notify_previously_selected == 2
                                        normal! ``
                                        call s:F.msg('Already selected')
                                        return s:G.region_at_pos()
                                    endif
                                    call s:F.msg('Already selected')
                                endif
                                return R
                            endfun
                            
    1              0.000004 fun! s:get_next() abort
                                let s:v.nav_direction = 1
                                if s:X()
                                    silent keepjumps normal! ngny`]
                                    return s:G.new_region()
                                else
                                    silent keepjumps normal! ngny`[
                                    return vm#commands#add_cursor_at_word(0, 0)
                                endif
                            endfun
                            
    1              0.000003 fun! s:get_prev() abort
                                let s:v.nav_direction = 0
                                if s:X()
                                    silent keepjumps normal! NgNy`]
                                    return s:G.new_region()
                                else
                                    silent keepjumps normal! NgNy`[
                                    return vm#commands#add_cursor_at_word(0, 0)
                                endif
                            endfun
                            
    1              0.000004 fun! s:navigate(force, dir) abort
                                if a:force || @/==''
                                    let s:v.nav_direction = a:dir
                                    let r = s:G.region_at_pos()
                                    if empty(r)
                                        let i = s:G.nearest_region().index
                                    else
                                        let i = a:dir? r.index+1 : r.index-1
                                    endif
                                    call s:G.select_region(i)
                                    return 1
                                endif
                            endfun
                            
    1              0.000003 fun! s:skip() abort
                                let r = s:G.region_at_pos()
                                if empty(r) | call s:navigate(1, s:v.nav_direction)
                                else        | call r.clear()
                                endif
                            endfun
                            
    1              0.000004 fun! vm#commands#find_next(skip, nav) abort
                                " Find next region, always downwards.
                                if ( a:nav || a:skip ) && s:F.no_regions() | return | endif
                            
                                "write search pattern if not navigating and no search set
                                if s:X() && !a:nav | call s:Search.add_if_empty() | endif
                            
                                if !s:Search.validate() && !a:nav | return | endif
                            
                                if s:navigate(a:nav, 1) | return 0        "just navigate to previous
                                elseif a:skip           | call s:skip()   "skip current match
                                endif
                            
                                return s:get_region(1)
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#find_prev(skip, nav) abort
                                " Find previous region, always upwards.
                                if ( a:nav || a:skip ) && s:F.no_regions() | return | endif
                            
                                "write search pattern if not navigating and no search set
                                if s:X() && !a:nav | call s:Search.add_if_empty() | endif
                            
                                if !s:Search.validate() && !a:nav | return | endif
                            
                                let r = s:G.region_at_pos()
                                if empty(r)  | let r = s:G.select_region(s:v.index) | endif
                                if !empty(r) | let pos = [r.l, r.a]
                                else         | let pos = getpos('.')[1:2]
                                endif
                            
                                if s:navigate(a:nav, 0) | return 0        "just navigate to previous
                                elseif a:skip           | call s:skip()   "skip current match
                                endif
                            
                                "move to the beginning of the current match
                                call cursor(pos)
                                return s:get_region(0)
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#skip(just_remove) abort
                                " Skip region and get next, respecting current direction.
                                if s:F.no_regions() | return | endif
                            
                                if a:just_remove
                                    let r = s:G.region_at_pos()
                                    if !empty(r)
                                        return s:G.remove_last_region(r.id)
                                    endif
                            
                                elseif s:v.nav_direction
                                    return vm#commands#find_next(1, 0)
                                else
                                    return vm#commands#find_prev(1, 0)
                                endif
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Cycle regions
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#commands#seek_down() abort
                                let nR = len(s:R())
                                if !nR | return | endif
                            
                                " don't jump down if nothing else to seek
                                if !s:F.Scroll.can_see_eof()
                                    let r = s:G.region_at_pos()
                                    if !empty(r) && r.index != nR - 1
                                        exe "keepjumps normal! \<C-f>"
                                    endif
                                endif
                            
                                let end = getpos('.')[1]
                                for r in s:R()
                                    if r.l >= end
                                        return s:G.select_region(r.index)
                                    endif
                                endfor
                                return s:G.select_region(nR - 1)
                            endfun
                            
    1              0.000003 fun! vm#commands#seek_up() abort
                                if !len(s:R()) | return | endif
                            
                                " don't jump up if nothing else to seek
                                if !s:F.Scroll.can_see_bof()
                                    let r = s:G.region_at_pos()
                                    if !empty(r) && r.index != 0
                                        exe "keepjumps normal! \<C-b>"
                                    endif
                                endif
                            
                                let end = getpos('.')[1]
                            
                                for r in reverse(copy(s:R()))
                                    if r.l <= end
                                        return s:G.select_region(r.index)
                                    endif
                                endfor
                                return s:G.select_region(0)
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Motion commands
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 fun! vm#commands#motion(motion, count, select, single) abort
                                " Entry point for motions in VM.
                                call s:init(0, 1, a:select)
                            
                                "create cursor if needed:
                                " - VM hasn't started yet
                                " - there are no regions
                                " - called with (single_region) and cursor not on a region
                            
                                if !g:Vm.buffer || s:F.no_regions() || ( a:single && !s:is_r() )
                                    call s:G.new_cursor()
                                endif
                            
                                "-----------------------------------------------------------------------
                            
                                if a:motion == '|' && a:count <= 1
                                    let s:v.motion = virtcol('.').a:motion
                                else
                                    let s:v.motion = a:count>1? a:count.a:motion : a:motion
                                endif
                            
                                "-----------------------------------------------------------------------
                            
                                if s:symbol()          | let s:v.merge = 1          | endif
                                if a:select && !s:X()  | let g:Vm.extend_mode = 1   | endif
                            
                                if a:select && !s:v.multiline && s:vertical()
                                    call s:F.toggle_option('multiline')
                                endif
                            
                                call s:call_motion(a:single)
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#merge_to_beol(eol) abort
                                " Entry point for 0/^/$ motions.
                                if s:F.no_regions() | return | endif
                                call s:G.cursor_mode()
                            
                                let s:v.motion = a:eol? "\<End>" : '^'
                                let s:v.merge = 1
                                call s:call_motion()
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#find_motion(motion, char) abort
                                " Entry point for f/F/t/T motions.
                                if s:F.no_regions() | return | endif
                            
                                if a:char != ''
                                    let s:v.motion = a:motion.a:char
                                else
                                    let s:v.motion = a:motion.nr2char(getchar())
                                endif
                            
                                call s:call_motion()
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#regex_motion(regex, count, remove) abort
                                " Entry point for Goto-Regex motion.
                                if s:F.no_regions() | return | endif
                            
                                let regex = empty(a:regex) ? s:F.search_chars(a:count) : a:regex
                                let case =    g:VM_case_setting ==? 'sensitive' ? '\C' :
                                            \ g:VM_case_setting ==? 'ignore'    ? '\c' : ''
                            
                                if empty(regex)
                                    return s:F.msg('Cancel')
                                endif
                            
                                call s:F.Scroll.get()
                                let [ R, X ] = [ s:R()[ s:v.index ], s:X() ]
                                call s:before_move()
                            
                                if s:v.direction
                                    for r in ( s:v.single_region ? [R] : s:R() )
                                        call cursor(r.L, r.b)
                                        let endl = s:v.multiline && !empty(a:regex) ? line('$') : r.L
                                        if !search(regex . case, 'z', endl)
                                            if a:remove | call r.remove() | endif
                                            continue
                                        endif
                                        if X
                                            let [r.L, r.b] = getpos('.')[1:2]
                                            call r.update_region()
                                        else
                                            call r.update_cursor_pos()
                                        endif
                                    endfor
                                else
                                    for r in ( s:v.single_region ? [R] : s:R() )
                                        call cursor(r.l, r.a)
                                        let endl = s:v.multiline && !empty(a:regex) ? line('$') : r.l
                                        if !search(regex . case, 'b', endl)
                                            if a:remove | call r.remove() | endif
                                            continue
                                        endif
                                        if X
                                            let [r.l, r.a] = getpos('.')[1:2]
                                            call r.update_region()
                                        else
                                            call r.update_cursor_pos()
                                        endif
                                    endfor
                                endif
                            
                                " if using slash-search, it's safer to merge regions
                                " a region update is also needed for some reason (some bytes map issue)
                                if !empty(a:regex)
                                    let s:v.merge = 1
                                    if !a:remove
                                        call s:G.update_regions()
                                    endif
                                endif
                            
                                " update variables, facing direction, highlighting
                                call s:after_move(R)
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Motion event
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 fun! s:call_motion(...) abort
                                if s:F.no_regions() | return | endif
                                call s:F.Scroll.get()
                                let R = s:R()[ s:v.index ]
                            
                                let regions = (a:0 && a:1) || s:v.single_region ? [R] : s:R()
                            
                                call s:before_move()
                            
                                for r in regions | call r.move() | endfor
                            
                                "update variables, facing direction, highlighting
                                call s:after_move(R)
                            endfun
                            
                            
    1              0.000004 fun! s:before_move() abort
                                call s:G.reset_byte_map(0)
                                if !s:X() | let s:v.merge = 1 | endif
                            endfun
                            
                            
    1              0.000004 fun! s:after_move(R) abort
                                let s:v.direction = a:R.dir
                                let s:v.restore_scroll = !s:v.insert
                            
                                if s:v.merge
                                    call s:G.select_region(a:R.index)
                                    call s:F.Scroll.get(1)
                                    call s:G.update_and_select_region(a:R.A)
                                else
                                    call s:F.restore_reg()
                                    call s:G.update_highlight()
                                    call s:G.select_region(a:R.index)
                                endif
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Align
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#commands#align() abort
                                if s:F.no_regions() | return | endif
                                let s:v.restore_index = s:v.index
                                call s:F.Scroll.get(1)
                                call s:V.Edit.align()
                                call s:F.Scroll.restore()
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#align_char(count) abort
                                if s:F.no_regions() | return | endif
                                call s:G.cursor_mode()
                            
                                let s:v.restore_index = s:v.index
                                call s:F.Scroll.get(1)
                                let n = a:count | let s = n>1? 's' : ''
                                echohl Label    | echo 'Align with '.n.' char'.s.' > ' | echohl None
                            
                                let C = []
                                while n
                                    let c = nr2char(getchar())
                                    if c == "\<esc>" | echohl WarningMsg | echon ' ...Aborted' | return
                                    else             | call add(C, c) | let n -= 1 | echon c
                                    endif
                                endwhile
                            
                                let s = 'czp'    "search method: accept at cursor position
                            
                                while !empty(C)
                                    let c = remove(C, 0)
                            
                                    "remove region if a match isn't found, otherwise it will be aligned
                                    for r in s:R()
                                        call cursor(r.l, r.a)
                                        if !search(c, s, r.l) | call r.remove() | continue | endif
                                        call r.update_cursor([r.l, getpos('.')[2]])
                                    endfor
                            
                                    "TODO: strip white spaces preceding the shortest columns
                                    call s:V.Edit.align()
                                    let s = 'zp'    "change search method: don't accept at cursor position
                                endwhile
                                call s:F.Scroll.restore()
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#align_regex() abort
                                if s:F.no_regions() | return | endif
                                call s:G.cursor_mode()
                                let s:v.restore_index = s:v.index
                                call s:F.Scroll.get(1)
                            
                                echohl Label | let rx = input('Align with regex > ')   | echohl None
                                if empty(rx) | echohl WarningMsg | echon ' ...Aborted' | return | endif
                            
                                for r in s:R()
                                    call cursor(r.l, r.a)
                                    if !search(rx, 'czp', r.l) | call r.remove() | continue | endif
                                    call r.update_cursor([r.l, getpos('.')[2]])
                                endfor
                                call s:V.Edit.align()
                                call s:F.Scroll.restore()
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Miscellaneous commands
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#commands#invert_direction(...) abort
                                " Invert direction and reselect region.
                                if s:F.no_regions() || s:v.auto | return | endif
                            
                                for r in s:R() | let r.dir = !r.dir | endfor
                            
                                "invert anchor
                                if s:v.direction
                                    let s:v.direction = 0
                                    for r in s:R() | let r.k = r.b | let r.K = r.B | endfor
                                else
                                    let s:v.direction = 1
                                    for r in s:R() | let r.k = r.a | let r.K = r.A | endfor
                                endif
                            
                                if !a:0 | return | endif
                                call s:G.update_highlight()
                                call s:G.select_region(s:v.index)
                            endfun
                            
    1              0.000003 function! vm#commands#reset_direction(...) abort
                                " Resets regions facing.
                                if s:F.no_regions() || s:v.auto | return | endif
                            
                                let s:v.direction = 1
                                for r in s:R()
                                    let r.dir = 1
                                    let r.k = r.a
                                    let r.K = r.A
                                endfor
                            
                                if !a:0 | return | endif
                                call s:G.update_highlight()
                                call s:G.select_region(s:v.index)
                            endfunction
                            
                            
    1              0.000003 fun! vm#commands#split_lines() abort
                                " Split regions so that they don't cross line boundaries.
                                if s:F.no_regions() | return | endif
                                call s:G.split_lines()
                                if get(g:, 'VM_autoremove_empty_lines', 1)
                                    call s:G.remove_empty_lines()
                                endif
                                call s:G.update_and_select_region()
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#remove_empty_lines() abort
                                " Remove selections that consist of empty lines.
                                call s:G.remove_empty_lines()
                                call s:G.update_and_select_region()
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#visual_cursors() abort
                                " Create a column of cursors from visual mode.
                                call s:set_extend_mode(0)
                                call vm#visual#cursors(visualmode())
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#visual_add() abort
                                " Convert a visual selection to a VM selection.
                                call s:set_extend_mode(1)
                                call vm#visual#add(visualmode())
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#remove_every_n_regions(count) abort
                                " Remove every n regions, given by [count], min 2.
                                if s:F.no_regions() | return | endif
                                let R = s:R() | let i = 1 | let cnt = a:count < 2 ? 2 : a:count
                                for n in range(1, len(R))
                                    if n % cnt == 0
                                        call R[n-i].remove()
                                        let i += 1
                                    endif
                                endfor
                                call s:G.update_and_select_region({'index': 0})
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#mouse_column() abort
                                " Create a column of cursors with the mouse.
                                call s:set_extend_mode(0)
                                let start = getpos('.')[1:2]
                                exe "normal! \<LeftMouse>"
                                let end = getpos('.')[1:2]
                            
                                if start[0] < end[0]
                                    call cursor(start[0], start[1])
                                    while getpos('.')[1] < end[0]
                                        call vm#commands#add_cursor_down(0, 1)
                                    endwhile
                                    if getpos('.')[1] > end[0]
                                        call vm#commands#skip(1)
                                    endif
                                else
                                    call cursor(start[0], start[1])
                                    while getpos('.')[1] > end[0]
                                        call vm#commands#add_cursor_up(0, 1)
                                    endwhile
                                    if getpos('.')[1] < end[0]
                                        call vm#commands#skip(1)
                                    endif
                                endif
                            endfun
                            
                            
    1              0.000004 fun! vm#commands#shrink_or_enlarge(shrink) abort
                                " Reduce/enlarge selection size by 1.
                                if s:F.no_regions() | return | endif
                                call s:G.extend_mode()
                            
                                let dir = s:v.direction
                            
                                let s:v.motion = a:shrink? (dir? 'h':'l') : (dir? 'l':'h')
                                call s:call_motion()
                            
                                call vm#commands#invert_direction()
                            
                                let s:v.motion = a:shrink? (dir? 'l':'h') : (dir? 'h':'l')
                                call s:call_motion()
                            
                                if s:v.direction != dir | call vm#commands#invert_direction(1) | endif
                            endfun
                            
                            
    1              0.000006 fun! vm#commands#increase_or_decrease(increase, all_types, count, g)
                                let oldnr = &nrformats
                                if a:all_types
                                    setlocal nrformats+=alpha
                                endif
                                let map = a:increase ? "\<c-a>" : "\<c-x>"
                                call s:V.Edit.run_normal(map, {'count': a:count, 'recursive': 0, 'gcount': a:g})
                                if a:all_types
                                    let &l:nrformats = oldnr
                                endif
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Reselect last regions, undo, redo
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#commands#reselect_last()
                                let was_active = s:init(0, 1, 0)
                                if empty(get(b:, 'VM_LastBackup', {})) || empty(get(b:VM_LastBackup, 'regions', []))
                                    return s:F.exit('No regions to restore')
                                endif
                            
                                if was_active && !s:X()
                                    call s:G.erase_regions()
                                elseif was_active
                                    return s:F.msg('Not in extend mode.')
                                endif
                            
                                try
                                    for r in b:VM_LastBackup.regions
                                        call vm#region#new(1, r.A, r.B)
                                    endfor
                                    let g:Vm.extend_mode = b:VM_LastBackup.extend
                                    let s:v.search = b:VM_LastBackup.search
                                catch
                                    return s:F.exit('Error while restoring regions.')
                                endtry
                            
                                call s:G.update_and_select_region({'index': b:VM_LastBackup.index})
                            endfun
                            
                            
                            
    1              0.000003 fun! vm#commands#undo() abort
                                let first = b:VM_Backup.first
                                let ticks = b:VM_Backup.ticks
                                let index = index(ticks, b:VM_Backup.last)
                            
                                try
                                    if index <= 0
                                        if undotree().seq_cur != first
                                            exe "undo" first
                                            call s:G.restore_regions(0)
                                        endif
                                    else
                                        exe "undo" ticks[index-1]
                                        call s:G.restore_regions(index-1)
                                        let b:VM_Backup.last = ticks[index - 1]
                                    endif
                                catch
                                    call s:V.Funcs.msg('[visual-multi] errors during undo operation.')
                                endtry
                            endfun
                            
                            
    1              0.000003 fun! vm#commands#redo() abort
                                let ticks = b:VM_Backup.ticks
                                let index = index(ticks, b:VM_Backup.last)
                            
                                try
                                    if index != len(ticks) - 1
                                        exe "undo" ticks[index+1]
                                        call s:G.restore_regions(index+1)
                                        let b:VM_Backup.last = ticks[index + 1]
                                    endif
                                catch
                                    call s:V.Funcs.msg('[visual-multi] errors during redo operation.')
                                endtry
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000016 let s:X                = { -> g:Vm.extend_mode }
    1              0.000008 let s:R                = { -> s:V.Regions      }
    1              0.000014 let s:is_r             = { -> g:Vm.buffer && !empty(s:G.region_at_pos()) }
    1              0.000011 let s:first_line       = { -> line('.') == 1 }
    1              0.000013 let s:last_line        = { -> line('.') == line('$') }
    1              0.000013 let s:symbol           = {   -> index(['^', '0', '%', '$'],     s:v.motion) >= 0 }
    1              0.000011 let s:horizontal       = {   -> index(['h', 'l'],               s:v.motion) >= 0 }
    1              0.000010 let s:vertical         = {   -> index(['j', 'k'],               s:v.motion) >= 0 }
    1              0.000012 let s:simple           = { m -> index(split('hlwebWEB', '\zs'), m)          >= 0 }
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=indent fdn=1

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim
Sourced 1 time
Total time:   0.097512
 Self time:   0.005009

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Initialize global variables
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000023 let g:VM_live_editing                     = get(g:, 'VM_live_editing', 1)
                            
    1              0.000011 let g:VM_custom_commands                  = get(g:, 'VM_custom_commands', {})
    1              0.000009 let g:VM_commands_aliases                 = get(g:, 'VM_commands_aliases', {})
    1              0.000008 let g:VM_debug                            = get(g:, 'VM_debug', 0)
    1              0.000008 let g:VM_reselect_first                   = get(g:, 'VM_reselect_first', 0)
    1              0.000008 let g:VM_case_setting                     = get(g:, 'VM_case_setting', '')
    1              0.000009 let g:VM_use_first_cursor_in_line         = get(g:, 'VM_use_first_cursor_in_line', 0)
    1              0.000008 let g:VM_disable_syntax_in_imode          = get(g:, 'VM_disable_syntax_in_imode', 0)
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            "Reindentation after insert mode
                            
    1              0.000014 let g:VM_reindent_filetypes               = get(g:, 'VM_reindent_filetypes', [])
                            
    1   0.002689   0.001762 call vm#themes#init()
    1   0.004083   0.000022 call vm#plugs#buffer()
                            
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Initialize buffer
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " b:VM_Selection (= s:V) contains Regions, Vars (= s:v = plugin variables),
                            " function classes (Global, Funcs, Edit, Search, Insert, etc)
                            
                            " Parameters:
                            "   cmd_type: if > 0, the search register will be set to an empty string
                            "             adding cursors uses 1, starting regex uses 2
                            
    1              0.000007 fun! vm#init_buffer(cmd_type) abort
                                " If already initialized, return current instance.
                                let v:errmsg = ""
                                try
                                    if exists('b:visual_multi') | return s:V | endif
                            
                                    let b:VM_Selection = {'Vars': {}, 'Regions': [], 'Bytes': {}}
                                    let b:visual_multi = 1
                            
                                    let b:VM_Debug  = get(b:, 'VM_Debug', {'lines': []})
                                    let b:VM_Backup = {'ticks': [], 'last': 0, 'first': undotree().seq_cur}
                            
                                    " funcs script must be sourced first
                                    let s:V       = b:VM_Selection
                                    let s:v       = s:V.Vars
                                    let s:V.Funcs = vm#funcs#init()
                            
                                    " init plugin variables
                                    call vm#variables#init()
                            
                                    if get(g:, 'VM_filesize_limit', 0) && s:V.Funcs.size() > gVM_filesize_limit
                                        call vm#variables#reset_globals()
                                        let v:errmsg = 'VM cannot start, buffer too big.'
                                        return v:errmsg
                                    endif
                            
                                    " init search register
                                    let @/ = a:cmd_type ? '' : @/
                            
                                    " hooks and compatibility tweaks before applying mappings
                                    call vm#comp#init()
                            
                                    " init classes
                                    let s:V.Maps   = vm#maps#init()
                                    let s:V.Global = vm#global#init()
                                    let s:V.Search = vm#search#init()
                                    let s:V.Edit   = vm#edit#init()
                                    let s:V.Insert = vm#insert#init()
                                    let s:V.Case   = vm#special#case#init()
                            
                                    call s:V.Maps.enable()
                            
                                    call vm#region#init()
                                    call vm#commands#init()
                                    call vm#operators#init()
                                    call vm#special#commands#init()
                            
                                    call vm#augroup(0)
                                    call vm#au_cursor(0)
                            
                                    " set vim variables
                                    call vm#variables#set()
                            
                                    if !empty(g:VM_highlight_matches)
                                        if !has_key(g:Vm, 'Search')
                                            call vm#themes#init()
                                        else
                                            call vm#themes#search_highlight()
                                        endif
                                        hi clear Search
                                        exe 'hi! ' . g:Vm.Search
                                    endif
                            
                                    if !v:hlsearch && a:cmd_type != 2
                                        call s:enable_hls()
                                    endif
                            
                                    call s:V.Funcs.set_statusline(0)
                            
                                    " backup sync settings for the buffer
                                    if !exists('b:VM_sync_minlines')
                                        let b:VM_sync_minlines = s:V.Funcs.sync_minlines()
                                    endif
                            
                                    let g:Vm.buffer = bufnr('')
                                    return s:V
                                catch
                                    let v:errmsg = 'VM cannot start, unhandled exception.'
                                    call vm#variables#reset_globals()
                                    return v:errmsg
                                endtry
                            endfun
                            
    1              0.000005 fun! s:enable_hls()
                                if mode(1) == 'n'
                                    call feedkeys("\<Plug>(VM-Hls)")
                                else
                                    call timer_start(50, { t -> s:enable_hls() })
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Reset
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#reset(...)
                                if !exists('b:visual_multi')
                                    return {}
                                endif
                                call vm#variables#reset()
                                call vm#commands#regex_reset()
                            
                                call s:V.Global.remove_highlight()
                                call s:V.Global.backup_last_regions()
                            
                                call s:V.Funcs.restore_regs()
                                call s:V.Maps.disable(1)
                                silent! call s:V.Insert.auto_end()
                            
                                call vm#maps#reset()
                                call vm#comp#reset()
                                call vm#augroup(1)
                                call vm#au_cursor(1)
                            
                                " reenable folding, but keep winline and open current fold
                                if exists('s:v.oldfold')
                                    call s:V.Funcs.Scroll.get(1)
                                    normal! zizv
                                    call s:V.Funcs.Scroll.restore()
                                endif
                            
                                if !empty(g:VM_highlight_matches)
                                    hi clear Search
                                    exe 'hi! ' . g:Vm.search_hi
                                endif
                            
                                if g:Vm.oldupdate && &updatetime != g:Vm.oldupdate
                                    let &updatetime = g:Vm.oldupdate
                                endif
                            
                                call vm#comp#exit()
                            
                                call s:V.Funcs.restore_visual_marks()
                            
                                "exiting manually
                                if !get(g:, 'VM_silent_exit', 0) && !a:0
                                    call s:V.Funcs.msg('Exited Visual-Multi.')
                                else
                                    echo "\r"
                                endif
                            
                                call vm#variables#reset_globals()
                                call vm#special#commands#unset()
                                unlet b:visual_multi
                                call garbagecollect()
                                return {}
                            endfun
                            
                            "------------------------------------------------------------------------------
                            
    1              0.000003 fun! vm#hard_reset()
                                silent! call vm#reset(1)
                                call vm#clearmatches()
                            endfun
                            
                            "------------------------------------------------------------------------------
                            
    1              0.000003 fun! vm#clearmatches() abort
                                for m in getmatches()
                                    if m.group == 'VM_Extend' || m.group == 'MultiCursor'
                                        silent! call matchdelete(m.id)
                                    endif
                                endfor
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Autocommands
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 fun! vm#augroup(end) abort
                                if a:end
                                    autocmd! VM_global
                                    augroup! VM_global
                                    return
                                endif
                            
                                augroup VM_global
                                    au!
                                    au BufLeave     * call s:buffer_leave()
                                    au BufEnter     * call s:buffer_enter()
                            
                                    if exists("##TextYankPost")
                                        au TextYankPost <buffer> call s:set_reg()
                                        au TextYankPost <buffer> call vm#operators#after_yank()
                                    else
                                        au CursorMoved  <buffer> call s:set_reg()
                                        au CursorMoved  <buffer> call vm#operators#after_yank()
                                        au CursorHold   <buffer> call vm#operators#after_yank()
                                    endif
                                augroup END
                            endfun
                            
    1              0.000003 fun! vm#au_cursor(end) abort
                                if a:end
                                    autocmd! VM_cursormoved
                                    augroup! VM_cursormoved
                                    return
                                endif
                            
                                augroup VM_cursormoved
                                    au!
                                    au CursorMoved  <buffer> call s:cursor_moved()
                                    au CursorMoved  <buffer> call s:V.Funcs.set_statusline(2)
                                    au CursorHold   <buffer> call s:V.Funcs.set_statusline(1)
                                augroup END
                            endfun
                            
    1              0.000004 fun! s:cursor_moved() abort
                                if !s:v.eco
                                    " if currently on a region, set the index to this region
                                    " so that it's possible to select next/previous from it
                                    let r = s:V.Global.region_at_pos()
                                    if !empty(r) | let s:v.index = r.index | endif
                                endif
                            endfun
                            
    1              0.000004 fun! s:buffer_leave() abort
                                if exists('b:VM_skip_reset_once_on_bufleave')
                                    unlet b:VM_skip_reset_once_on_bufleave
                                elseif !empty(get(b:, 'VM_Selection', {})) && !b:VM_Selection.Vars.insert
                                    call vm#reset(1)
                                endif
                            endfun
                            
    1              0.000003 fun! s:buffer_enter() abort
                                if empty(get(b:, 'VM_Selection', {}))
                                    let b:VM_Selection = {}
                                endif
                            endfun
                            
    1              0.000003 fun! s:set_reg() abort
                                " Replace old default register if yanking in VM outside a region or cursor.
                                if s:v.yanked
                                    let s:v.yanked = 0
                                    let g:Vm.registers['"'] = []
                                    let s:v.oldreg = s:V.Funcs.get_reg(v:register)
                                endif
                            endfun
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Python section
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1   0.090287   0.002772 if !has('python3')
    1              0.000006     let g:VM_use_python = 0
    1              0.000002     finish
                            endif
                            
                            let g:VM_use_python = get(g:, 'VM_use_python', !has('nvim'))
                            if !g:VM_use_python | finish | endif
                            
                            let s:root_dir = fnamemodify(resolve(expand('<sfile>:p')), ':h')
                            
                            python3 << EOF
                            import sys
                            from os.path import normpath, join
                            import vim
                            root_dir = vim.eval('s:root_dir')
                            python_root_dir = normpath(join(root_dir, '..', 'python'))
                            sys.path.insert(0, python_root_dir)
                            import vm
                            EOF
                            
                            " vim: et ts=4 sw=4 sts=4 :

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/themes.vim
Sourced 1 time
Total time:   0.000533
 Self time:   0.000533

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            "Set up highlighting
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000014 let s:Themes = {}
                            
    1              0.000018 augroup VM_reset_theme
    1              0.000045   au!
    1              0.000019   au ColorScheme * call vm#themes#init()
    1              0.000003 augroup END
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000006 fun! vm#themes#init() abort
                              if !exists('g:Vm') | return | endif
                            
                              if !empty(g:VM_highlight_matches)
                                let out = execute('highlight Search')
                                if match(out, ' links to ') >= 0
                                  let hi = substitute(out, '^.*links to ', '', '')
                                  let g:Vm.search_hi = "link Search " . hi
                                else
                                  let hi = strtrans(substitute(out, '^.*xxx ', '', ''))
                                  let hi = substitute(hi, '\^.', '', 'g')
                                  let g:Vm.search_hi = "Search " . hi
                                endif
                            
                                call vm#themes#search_highlight()
                              endif
                            
                              let g:Vm.hi.mono    = 'VM_Mono'
                              let g:Vm.hi.cursor  = 'VM_Cursor'
                              let g:Vm.hi.extend  = 'VM_Extend'
                              let g:Vm.hi.insert  = 'VM_Insert'
                              let g:Vm.hi.message = get(g:, 'VM_Message_hl', 'WarningMsg')
                            
                              if exists('g:VM_theme_set_by_colorscheme')
                                unlet g:VM_theme_set_by_colorscheme
                                highlight! link MultiCursor VM_Cursor
                                return
                              endif
                            
                              let theme = get(g:, 'VM_theme', 'default')
                            
                              silent! hi clear VM_Mono
                              silent! hi clear VM_Cursor
                              silent! hi clear VM_Extend
                              silent! hi clear VM_Insert
                              silent! hi clear MultiCursor
                            
                              if theme == 'default'
                                exe "highlight! link VM_Mono     ".get(g:, 'VM_Mono_hl',   'ErrorMsg')
                                exe "highlight! link VM_Cursor   ".get(g:, 'VM_Cursor_hl', 'Visual')
                                exe "highlight! link VM_Extend   ".get(g:, 'VM_Extend_hl', 'PmenuSel')
                                exe "highlight! link VM_Insert   ".get(g:, 'VM_Insert_hl', 'DiffChange')
                                exe "highlight! link MultiCursor ".get(g:, 'VM_Cursor_hl', 'Visual')
                                return
                              endif
                            
                              call s:Themes[theme]()
                              highlight! link MultiCursor VM_Cursor
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 fun! vm#themes#search_highlight() abort
                              " Init Search highlight.
                              let hl = g:VM_highlight_matches
                              let g:Vm.Search = hl == 'underline' ? 'Search term=underline cterm=underline gui=underline' :
                                    \           hl == 'red'       ? 'Search ctermfg=196 guifg=#ff0000' :
                                    \           hl =~ '^hi!\? '   ? substitute(g:VM_highlight_matches, '^hi!\?', '', '')
                                    \                             : 'Search term=underline cterm=underline gui=underline'
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 fun! vm#themes#load(theme) abort
                              " Load a theme or set default.
                              if empty(a:theme)
                                let g:VM_theme = 'default'
                                echo 'Theme set to default'
                              elseif index(keys(s:Themes), a:theme) < 0
                                echo "No such theme."
                                return
                              else
                                let g:VM_theme = a:theme
                              endif
                              call vm#themes#init()
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 fun! vm#themes#complete(A, L, P) abort
                              let valid = &background == 'light' ? s:Themes._light : s:Themes._dark
                              return filter(sort(copy(valid)), 'v:val=~#a:A')
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#themes#statusline() abort
                              if !exists('b:visual_multi')
                                return ''
                              endif
                              let v = b:VM_Selection.Vars
                              let vm = VMInfos()
                              let color  = '%#VM_Extend#'
                              let single = b:VM_Selection.Vars.single_region ? '%#VM_Mono# SINGLE ' : ''
                              try
                                if v.insert
                                  if b:VM_Selection.Insert.replace
                                    let [ mode, color ] = [ 'V-R', '%#VM_Mono#' ]
                                  else
                                    let [ mode, color ] = [ 'V-I', '%#VM_Cursor#' ]
                                  endif
                                else
                                  let mode = { 'n': 'V-M', 'v': 'V', 'V': 'V-L', "\<C-v>": 'V-B' }[mode()]
                                endif
                              catch
                                let mode = 'V-M'
                              endtry
                              let mode = exists('v.statusline_mode') ? v.statusline_mode : mode
                              let patterns = string(vm.patterns)[:(winwidth(0)-30)]
                              return printf("%s %s %s %s %s%s %s %%=%%l:%%c %s %s",
                                    \ color, mode, '%#VM_Insert#', vm.ratio, single, '%#TabLine#',
                                    \ patterns, color, vm.status . ' ')
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000018 let s:Themes._light = ['sand', 'paper', 'lightblue1', 'lightblue2', 'lightpurple1', 'lightpurple2']
    1              0.000011 let s:Themes._dark = ['iceblue', 'ocean', 'neon', 'purplegray', 'nord', 'codedark', 'spacegray', 'olive', 'sand']
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 fun! s:Themes.iceblue()
                              hi! VM_Extend ctermbg=24                   guibg=#005f87
                              hi! VM_Cursor ctermbg=31    ctermfg=237    guibg=#0087af    guifg=#87dfff
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=180   ctermfg=235    guibg=#dfaf87    guifg=#262626
                            endfun
                            
    1              0.000003 fun! s:Themes.ocean()
                              hi! VM_Extend ctermbg=25                   guibg=#005faf
                              hi! VM_Cursor ctermbg=39    ctermfg=239    guibg=#87afff    guifg=#4e4e4e
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=186   ctermfg=239    guibg=#dfdf87    guifg=#4e4e4e
                            endfun
                            
    1              0.000003 fun! s:Themes.neon()
                              hi! VM_Extend ctermbg=26    ctermfg=109    guibg=#005fdf    guifg=#89afaf
                              hi! VM_Cursor ctermbg=39    ctermfg=239    guibg=#00afff    guifg=#4e4e4e
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=221   ctermfg=239    guibg=#ffdf5f    guifg=#4e4e4e
                            endfun
                            
    1              0.000003 fun! s:Themes.lightblue1()
                              hi! VM_Extend ctermbg=153                  guibg=#afdfff
                              hi! VM_Cursor ctermbg=111   ctermfg=239    guibg=#87afff    guifg=#4e4e4e
                              hi! VM_Insert ctermbg=180   ctermfg=235    guibg=#dfaf87    guifg=#262626
                              hi! VM_Mono   ctermbg=167   ctermfg=253    guibg=#df5f5f    guifg=#dadada cterm=bold term=bold gui=bold
                            endfun
                            
    1              0.000003 fun! s:Themes.lightblue2()
                              hi! VM_Extend ctermbg=117                  guibg=#87dfff
                              hi! VM_Cursor ctermbg=111   ctermfg=239    guibg=#87afff    guifg=#4e4e4e
                              hi! VM_Insert ctermbg=180   ctermfg=235    guibg=#dfaf87    guifg=#262626
                              hi! VM_Mono   ctermbg=167   ctermfg=253    guibg=#df5f5f    guifg=#dadada cterm=bold term=bold gui=bold
                            endfun
                            
    1              0.000003 fun! s:Themes.purplegray()
                              hi! VM_Extend ctermbg=60                   guibg=#544a65
                              hi! VM_Cursor ctermbg=103   ctermfg=54     guibg=#8787af    guifg=#5f0087
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=141   ctermfg=235    guibg=#af87ff    guifg=#262626
                            endfun
                            
    1              0.000003 fun! s:Themes.nord()
                              hi! VM_Extend ctermbg=239                  guibg=#434C5E
                              hi! VM_Cursor ctermbg=245   ctermfg=24     guibg=#8a8a8a    guifg=#005f87
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=131   ctermfg=235    guibg=#AF5F5F    guifg=#262626
                            endfun
                            
    1              0.000003 fun! s:Themes.codedark()
                              hi! VM_Extend ctermbg=242                  guibg=#264F78
                              hi! VM_Cursor ctermbg=239   ctermfg=252    guibg=#6A7D89    guifg=#C5D4DD
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=131   ctermfg=235    guibg=#AF5F5F    guifg=#262626
                            endfun
                            
    1              0.000003 fun! s:Themes.spacegray()
                              hi! VM_Extend ctermbg=237                  guibg=#404040
                              hi! VM_Cursor ctermbg=242   ctermfg=239    guibg=Grey50     guifg=#4e4e4e
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=131   ctermfg=235    guibg=#AF5F5F    guifg=#262626
                            endfun
                            
    1              0.000003 fun! s:Themes.sand()
                              hi! VM_Extend ctermbg=143   ctermfg=0      guibg=darkkhaki  guifg=black
                              hi! VM_Cursor ctermbg=64    ctermfg=186    guibg=olivedrab  guifg=khaki
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=131   ctermfg=235    guibg=#AF5F5F    guifg=#262626
                            endfun
                            
    1              0.000003 fun! s:Themes.paper()
                              hi! VM_Extend ctermbg=250   ctermfg=16     guibg=#bfbcaf    guifg=black
                              hi! VM_Cursor ctermbg=239   ctermfg=188    guibg=#4c4e50    guifg=#d8d5c7
                              hi! VM_Insert ctermbg=167   ctermfg=253    guibg=#df5f5f    guifg=#dadada cterm=bold term=bold gui=bold
                              hi! VM_Mono   ctermbg=16    ctermfg=188    guibg=#000000    guifg=#d8d5c7
                            endfun
                            
    1              0.000003 fun! s:Themes.olive()
                              hi! VM_Extend ctermbg=3     ctermfg=0      guibg=olive      guifg=black
                              hi! VM_Cursor ctermbg=64    ctermfg=186    guibg=olivedrab  guifg=khaki
                              hi! VM_Insert ctermbg=239                  guibg=#4c4e50
                              hi! VM_Mono   ctermbg=131   ctermfg=235    guibg=#AF5F5F    guifg=#262626
                            endfun
                            
    1              0.000003 fun! s:Themes.lightpurple1()
                              hi! VM_Extend ctermbg=225                  guibg=#ffdfff
                              hi! VM_Cursor ctermbg=183   ctermfg=54     guibg=#dfafff    guifg=#5f0087 cterm=bold term=bold gui=bold
                              hi! VM_Insert ctermbg=146   ctermfg=235    guibg=#afafdf    guifg=#262626
                              hi! VM_Mono   ctermbg=135   ctermfg=225    guibg=#af5fff    guifg=#ffdfff cterm=bold term=bold gui=bold
                            endfun
                            
    1              0.000003 fun! s:Themes.lightpurple2()
                              hi! VM_Extend ctermbg=189                  guibg=#dfdfff
                              hi! VM_Cursor ctermbg=183   ctermfg=54     guibg=#dfafff    guifg=#5f0087 cterm=bold term=bold gui=bold
                              hi! VM_Insert ctermbg=225   ctermfg=235    guibg=#ffdfff    guifg=#262626
                              hi! VM_Mono   ctermbg=135   ctermfg=225    guibg=#af5fff    guifg=#ffdfff cterm=bold term=bold gui=bold
                            endfun
                            
                            " vim: et ts=2 sw=2 sts=2 :

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/python3.vim
Sourced 1 time
Total time:   0.087486
 Self time:   0.002570

count  total (s)   self (s)
                            " The Python3 provider uses a Python3 host to emulate an environment for running
                            " python3 plugins. :help provider
                            "
                            " Associating the plugin with the Python3 host is the first step because
                            " plugins will be passed as command-line arguments
                            
    1              0.000019 if exists('g:loaded_python3_provider')
                              finish
    1              0.000002 endif
    1   0.085378   0.000980 let [s:prog, s:err] = provider#pythonx#Detect(3)
    1              0.000009 let g:loaded_python3_provider = empty(s:prog) ? 1 : 2
                            
    1              0.000003 function! provider#python3#Prog() abort
                              return s:prog
                            endfunction
                            
    1              0.000002 function! provider#python3#Error() abort
                              return s:err
                            endfunction
                            
                            " The Python3 provider plugin will run in a separate instance of the Python3
                            " host.
    1   0.001236   0.000796 call remote#host#RegisterClone('legacy-python3-provider', 'python3')
    1   0.000094   0.000018 call remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])
                            
    1              0.000002 function! provider#python3#Call(method, args) abort
                              if s:err != ''
                                return
                              endif
                              if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
                            endfunction

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/pythonx.vim
Sourced 1 time
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
                            " The Python provider helper
    1              0.000019 if exists('s:loaded_pythonx_provider')
                              finish
    1              0.000002 endif
                            
    1              0.000009 let s:loaded_pythonx_provider = 1
                            
    1              0.000007 function! provider#pythonx#Require(host) abort
                              " Python host arguments
                              let prog = provider#python3#Prog()
                              let args = [prog, '-c', 'import sys; sys.path = [p for p in sys.path if p != ""]; import neovim; neovim.start_host()']
                            
                            
                              " Collect registered Python plugins into args
                              let python_plugins = remote#host#PluginsForHost(a:host.name)
                              for plugin in python_plugins
                                call add(args, plugin.path)
                              endfor
                            
                              return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})
                            endfunction
                            
    1              0.000009 function! s:get_python_executable_from_host_var(major_version) abort
                              return expand(get(g:, 'python'.(a:major_version == 3 ? '3' : execute("throw 'unsupported'")).'_host_prog', ''), v:true)
                            endfunction
                            
    1              0.000005 function! s:get_python_candidates(major_version) abort
                              return {
                                    \ 3: ['python3', 'python3.10', 'python3.9', 'python3.8', 'python3.7', 'python']
                                    \ }[a:major_version]
                            endfunction
                            
                            " Returns [path_to_python_executable, error_message]
    1              0.000004 function! provider#pythonx#Detect(major_version) abort
                              return provider#pythonx#DetectByModule('neovim', a:major_version)
                            endfunction
                            
                            " Returns [path_to_python_executable, error_message]
    1              0.000005 function! provider#pythonx#DetectByModule(module, major_version) abort
                              let python_exe = s:get_python_executable_from_host_var(a:major_version)
                            
                              if !empty(python_exe)
                                return [exepath(expand(python_exe, v:true)), '']
                              endif
                            
                              let candidates = s:get_python_candidates(a:major_version)
                              let errors = []
                            
                              for exe in candidates
                                let [result, error] = provider#pythonx#CheckForModule(exe, a:module, a:major_version)
                                if result
                                  return [exe, error]
                                endif
                                " Accumulate errors in case we don't find any suitable Python executable.
                                call add(errors, error)
                              endfor
                            
                              " No suitable Python executable found.
                              return ['', 'Could not load Python '.a:major_version.":\n".join(errors, "\n")]
                            endfunction
                            
                            " Returns array: [prog_exitcode, prog_version]
    1              0.000005 function! s:import_module(prog, module) abort
                              let prog_version = system([a:prog, '-c' , printf(
                                    \ 'import sys; ' .
                                    \ 'sys.path = [p for p in sys.path if p != ""]; ' .
                                    \ 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' .
                                    \ 'import pkgutil; ' .
                                    \ 'exit(2*int(pkgutil.get_loader("%s") is None))',
                                    \ a:module)])
                              return [v:shell_error, prog_version]
                            endfunction
                            
                            " Returns array: [was_success, error_message]
    1              0.000005 function! provider#pythonx#CheckForModule(prog, module, major_version) abort
                              let prog_path = exepath(a:prog)
                              if prog_path ==# ''
                                return [0, a:prog . ' not found in search path or not executable.']
                              endif
                            
                              let min_version = '3.7'
                            
                              " Try to load module, and output Python version.
                              " Exit codes:
                              "   0  module can be loaded.
                              "   2  module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
                              let [prog_exitcode, prog_version] = s:import_module(a:prog, a:module)
                            
                              if prog_exitcode == 2 || prog_exitcode == 0
                                " Check version only for expected return codes.
                                if prog_version !~ '^' . a:major_version
                                  return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python '
                                        \ . a:major_version . '.']
                                elseif prog_version =~ '^' . a:major_version && str2nr(prog_version[2:]) < str2nr(min_version[2:])
                                  return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python >= '
                                        \ . min_version . '.']
                                endif
                              endif
                            
                              if prog_exitcode == 2
                                return [0, prog_path.' does not have the "' . a:module . '" module.']
                              elseif prog_exitcode == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_version]
                              elseif prog_exitcode
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. '
                                      \ . '(' . prog_exitcode . ', output: ' . prog_version . ')'
                                      \ . ' Report this at https://github.com/neovim/neovim']
                              endif
                            
                              return [1, '']
                            endfunction

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/remote/host.vim
Sourced 1 time
Total time:   0.000335
 Self time:   0.000264

count  total (s)   self (s)
    1              0.000011 let s:hosts = {}
    1              0.000003 let s:plugin_patterns = {}
    1              0.000003 let s:plugins_for_host = {}
                            
                            " Register a host by associating it with a factory(funcref)
    1              0.000004 function! remote#host#Register(name, pattern, factory) abort
                              let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
                              let s:plugin_patterns[a:name] = a:pattern
                              if type(a:factory) == type(1) && a:factory
                                " Passed a channel directly
                                let s:hosts[a:name].channel = a:factory
                              endif
                            endfunction
                            
                            " Register a clone to an existing host. The new host will use the same factory
                            " as `source`, but it will run as a different process. This can be used by
                            " plugins that should run isolated from other plugins created for the same host
                            " type
    1              0.000003 function! remote#host#RegisterClone(name, orig_name) abort
                              if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
                              endif
                              let Factory = s:hosts[a:orig_name].factory
                              let s:hosts[a:name] = {
                                    \ 'factory': Factory,
                                    \ 'channel': 0,
                                    \ 'initialized': 0,
                                    \ 'orig_name': a:orig_name
                                    \ }
                            endfunction
                            
                            " Get a host channel, bootstrapping it if necessary
    1              0.000002 function! remote#host#Require(name) abort
                              if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
                              let host = s:hosts[a:name]
                              if !host.channel && !host.initialized
                                let host_info = {
                                      \ 'name': a:name,
                                      \ 'orig_name': get(host, 'orig_name', a:name)
                                      \ }
                                let host.channel = call(host.factory, [host_info])
                                let host.initialized = 1
                              endif
                              return host.channel
                            endfunction
                            
    1              0.000002 function! remote#host#IsRunning(name) abort
                              if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
                              return s:hosts[a:name].channel != 0
                            endfunction
                            
                            " Example of registering a Python plugin with two commands (one async), one
                            " autocmd (async) and one function (sync):
                            "
                            " let s:plugin_path = expand('<sfile>:p:h').'/nvim_plugin.py'
                            " call remote#host#RegisterPlugin('python', s:plugin_path, [
                            "   \ {'type': 'command', 'name': 'PyCmd', 'sync': 1, 'opts': {}},
                            "   \ {'type': 'command', 'name': 'PyAsyncCmd', 'sync': 0, 'opts': {'eval': 'cursor()'}},
                            "   \ {'type': 'autocmd', 'name': 'BufEnter', 'sync': 0, 'opts': {'eval': 'expand("<afile>")'}},
                            "   \ {'type': 'function', 'name': 'PyFunc', 'sync': 1, 'opts': {}}
                            "   \ ])
                            "
                            " The third item in a declaration is a boolean: non zero means the command,
                            " autocommand or function will be executed synchronously with rpcrequest.
    1              0.000002 function! remote#host#RegisterPlugin(host, path, specs) abort
                              let plugins = remote#host#PluginsForHost(a:host)
                            
                              for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
                              endfor
                            
                              if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
                              endif
                            
                              for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
                              endfor
                            
                              call add(plugins, {'path': a:path, 'specs': a:specs})
                            endfunction
                            
    1              0.000003 function! s:RegistrationCommands(host) abort
                              " Register a temporary host clone for discovering specs
                              let host_id = a:host.'-registration-clone'
                              call remote#host#RegisterClone(host_id, a:host)
                              let pattern = s:plugin_patterns[a:host]
                              let paths = nvim_get_runtime_file('rplugin/'.a:host.'/'.pattern, 1)
                              let paths = map(paths, 'tr(resolve(v:val),"\\","/")') " Normalize slashes #4795
                              let paths = uniq(sort(paths))
                              if empty(paths)
                                return []
                              endif
                            
                              for path in paths
                                call remote#host#RegisterPlugin(host_id, path, [])
                              endfor
                              let channel = remote#host#Require(host_id)
                              let lines = []
                              let registered = []
                              for path in paths
                                unlet! specs
                                let specs = rpcrequest(channel, 'specs', path)
                                if type(specs) != type([])
                                  " host didn't return a spec list, indicates a failure while loading a
                                  " plugin
                                  continue
                                endif
                                call add(lines, "call remote#host#RegisterPlugin('".a:host
                                      \ ."', '".path."', [")
                                for spec in specs
                                  call add(lines, "      \\ ".string(spec).",")
                                endfor
                                call add(lines, "     \\ ])")
                                call add(registered, path)
                              endfor
                              echomsg printf("remote/host: %s host registered plugins %s",
                                    \ a:host, string(map(registered, "fnamemodify(v:val, ':t')")))
                            
                              " Delete the temporary host clone
                              call jobstop(s:hosts[host_id].channel)
                              call remove(s:hosts, host_id)
                              call remove(s:plugins_for_host, host_id)
                              return lines
                            endfunction
                            
    1              0.000002 function! remote#host#UpdateRemotePlugins() abort
                              let commands = []
                              let hosts = keys(s:hosts)
                              for host in hosts
                                if has_key(s:plugin_patterns, host)
                                  try
                                    let commands +=
                                          \   ['" '.host.' plugins']
                                          \ + s:RegistrationCommands(host)
                                          \ + ['', '']
                                  catch
                                    echomsg v:throwpoint
                                    echomsg v:exception
                                  endtry
                                endif
                              endfor
                              call writefile(commands, g:loaded_remote_plugins)
                              echomsg printf('remote/host: generated rplugin manifest: %s',
                                    \ g:loaded_remote_plugins)
                            endfunction
                            
    1              0.000002 function! remote#host#PluginsForHost(host) abort
                              if !has_key(s:plugins_for_host, a:host)
                                let s:plugins_for_host[a:host] = []
                              end
                              return s:plugins_for_host[a:host]
                            endfunction
                            
    1              0.000002 function! remote#host#LoadErrorForHost(host, log) abort
                              return 'Failed to load '. a:host . ' host. '.
                                    \ 'You can try to see what happened by starting nvim with '.
                                    \ a:log . ' set and opening the generated log file.'.
                                    \ ' Also, the host stderr is available in messages.'
                            endfunction
                            
                            " Registration of standard hosts
                            
                            " Python/Python3
    1   0.000037   0.000017 call remote#host#Register('python', '*',
                                  \ function('provider#pythonx#Require'))
    1   0.000023   0.000010 call remote#host#Register('python3', '*',
                                  \ function('provider#pythonx#Require'))
                            
                            " Ruby
    1   0.000022   0.000009 call remote#host#Register('ruby', '*.rb',
                                  \ function('provider#ruby#Require'))
                            
                            " nodejs
    1   0.000021   0.000008 call remote#host#Register('node', '*',
                                  \ function('provider#node#Require'))
                            
                            " perl
    1   0.000024   0.000011 call remote#host#Register('perl', '*',
                                  \ function('provider#perl#Require'))

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim
Sourced 1 time
Total time:   0.000343
 Self time:   0.000343

count  total (s)   self (s)
                            "This script holds miscellaneous functions
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Initialize
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            "Store registers, initialize script vars and temporary buffer mappings.
                            "Some functions are registered in s:Funcs, that is returned to the global
                            "script, and then included in the global variable, so that they can be
                            "accessed from anywhere.
                            
    1              0.000005 fun! vm#funcs#init() abort
                                let s:V = b:VM_Selection
                                let s:v = s:V.Vars
                                return s:Funcs
                            endfun
                            
    1              0.000008 let s:R = { -> s:V.Regions }
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Functions
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 let s:Funcs = {}
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.pos2byte(...) abort
                                "pos can be a mark, a list [line, col], or the offset itself
                            
                                if type(a:1) == 0                   "an offset
                                    return a:1
                            
                                elseif type(a:1) == v:t_list        "a list [line, col]
                                    return (line2byte(a:1[0]) + a:1[1] - 1)
                            
                                else                                "a mark like '[
                                    let pos = getpos(a:1)[1:2]
                                    return (line2byte(pos[0]) + min([pos[1], col([pos[0], '$'])]) - 1)
                                endif
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.curs2byte() abort
                                " Return the offset of the current cursor position.
                                let pos = getcurpos()[1:2]
                                return (line2byte(pos[0]) + pos[1] - 1)
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.byte2pos(byte) abort
                                " Return the (line, col) position of a byte offset.
                                let line = byte2line(a:byte)
                                let col  = a:byte - line2byte(line) + 1
                                return [line, col]
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.Cursor(A) abort
                                let ln = byte2line(a:A)
                                let cl = a:A - line2byte(ln) + 1
                                call cursor(ln, cl)
                                return [ln, cl]
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.get_vertcol() abort
                                " getcurpos() is unreliable at $ (https://github.com/vim/vim/issues/4464)
                                " if > eol, reposition the cursor, so that curswant is reset
                                let curswant = getcurpos()[4]
                                if curswant > col('$')
                                    call cursor(getpos('.')[1:2])
                                    let curswant = getcurpos()[4]
                                endif
                                return curswant
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.no_regions() abort
                                if !len(s:R())
                                    let s:v.index = -1
                                    return 1
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.char_under_cursor() abort
                                return matchstr(getline('.'), '\%' . col('.') . 'c.')
                            endfun
                            
    1              0.000002 fun! s:Funcs.char_at_pos(l, c) abort
                                return matchstr(getline(a:l), '\%' . a:c . 'c.')
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.default_reg() abort
                                return "\""
                            endfun
                            
    1              0.000001 fun! s:Funcs.size() abort
                                return line2byte(line('$') + 1) - 1
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.get_reg(...) abort
                                let r = a:0? a:1 : s:v.def_reg
                                return [r, getreg(r), getregtype(r)]
                            endfun
                            
    1              0.000001 fun! s:Funcs.get_regs_1_9() abort
                                let regs = []
                                for r in range(1, 9)
                                    call add(regs, [r, getreg(r), getregtype(r)])
                                endfor
                                return regs
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.set_reg(text) abort
                                let r = s:v.def_reg
                                call setreg(r, a:text, 'v')
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.restore_reg() abort
                                let r = s:v.oldreg
                                call setreg(r[0], r[1], r[2])
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.restore_regs() abort
                                "default reg
                                call self.restore_reg()
                            
                                "regs 0-9
                                for r in s:v.oldregs_1_9 | call setreg(r[0], r[1], r[2]) | endfor
                            
                                "search reg
                                let s = s:v.oldsearch
                                call setreg("/", s[0], s[1])
                                let g:Vm.registers['"'] = []
                                let g:Vm.registers['-'] = []
                                silent! unlet g:Vm.registers['§']
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.restore_visual_marks() abort
                                call setpos("'<", s:v.vmarks[0])
                                call setpos("'>", s:v.vmarks[1])
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.region_with_id(id) abort
                                for r in s:R()
                                    if r.id == a:id | return r | endif
                                endfor
                                return {}
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.should_quit() abort
                                " VM should quit if there are no active regions.
                                return !len(s:V.Global.active_regions())
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.syntax(pos) abort
                                " Find syntax element at position.
                                if type(a:pos) == type([])    "list [line, col]
                                    let line = a:pos[0]
                                    let col = a:pos[1]
                                else                          "position ('.', ...)
                                    let line = line(a:pos)
                                    let col = col(a:pos)
                                endif
                                return synIDattr(synID(line, col, 1),"name")
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.get_expr(x) abort
                                let l:Has = { x, c -> match(x, '\C%'.c ) >= 0 }
                                let l:Sub = { x, a, b -> substitute(x, a, b, 'g') }
                                let N = len(s:R()) | let x = a:x
                            
                                if l:Has(x, 't')   | let x = l:Sub(x, '%t', 'r.txt')                    | endif
                                if l:Has(x, 'f')   | let x = l:Sub(x, '%f', 'str2float(r.txt)')         | endif
                                if l:Has(x, 'n')   | let x = l:Sub(x, '%n', 'str2nr(r.txt)')            | endif
                                if l:Has(x, 'i')   | let x = l:Sub(x, '%i', 'r.index')                  | endif
                                if l:Has(x, 'N')   | let x = l:Sub(x, '%N', N)                          | endif
                                return x
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.sync_minlines() abort
                                " Get the current sync minlines setting for the buffer.
                                let sync = split(execute('syn sync'), '\n')
                                let sync = len(sync) > 1 ? sync[1] : sync[0]
                                return matchstr(sync, '\d\+')
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Funcs.set_statusline(auto) abort
                                let setting = get(g:, 'VM_set_statusline', 2)
                                if ( setting - a:auto ) >= 1
                                    silent! noautocmd setlocal statusline=%!vm#themes#statusline()
                                endif
                            endfun
                            
    1              0.000002 fun! s:Funcs.special_statusline(msg) abort
                                let s:v.statusline_mode = a:msg
                                call self.set_statusline(1)
                                redraw
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:add_char(c)
                              let s:chars .= nr2char(a:c)
                              echon nr2char(a:c)
                            endfun
                            
    1              0.000001 fun! s:ask_char()
                              let c = getchar()
                              if c == 27                        " escape
                                return
                              elseif s:char_escape              " escaped character
                              elseif c == 92                    " backslash
                                call s:add_char(c)
                                let s:char_escape = 1
                                return s:ask_char()
                              endif
                              call s:add_char(c)
                              let s:chars2go -= 1
                              let s:char_escape = 0
                              return 1
                            endfun
                            
    1              0.000002 fun! s:Funcs.search_chars(n) abort
                              " Ask for [count] or 1 regex-interpretable character(s).
                              let [ s:chars, s:chars2go, s:char_escape ] = [ '', a:n, 0 ]
                              let ns = a:n > 1 ? 's' : ''
                              let pre = printf('Find regex [%d char'.ns.'] ', a:n)
                              echohl Label  | echo pre
                              echohl None   | echon '> '
                              while s:chars2go
                                if !s:ask_char() | return '' | endif
                              endwhile
                              return s:chars
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Keep viewport position
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 let s:Funcs.Scroll = {}
                            
    1              0.000002 fun! s:Funcs.Scroll.can_see_eof() abort
                                return ( winheight(0) - winline() + line('.') ) >= line('$')
                            endfun
                            
    1              0.000004 fun! s:Funcs.Scroll.can_see_bof() abort
                                return line('.') <= winline()
                            endfun
                            
    1              0.000001 fun! s:Funcs.Scroll.get(...) abort
                                " Store winline().
                                if a:0 | let s:v.restore_scroll = 1 | endif
                                let s:v.winline = winline()
                            endfun
                            
    1              0.000002 fun! s:Funcs.Scroll.force(line) abort
                                " Restore arbitrary winline().
                                let s:v.restore_scroll = 1
                                let s:v.winline = a:line
                                call self.restore()
                            endfun
                            
    1              0.000001 fun! s:Funcs.Scroll.restore(...) abort
                                " Restore viewport position when done.
                                if s:v.restore_scroll | let s:v.restore_scroll = 0 | else | return | endif
                            
                                " restoring should be avoided if it's possible to see EOF or BOF
                                if ( self.can_see_bof() || self.can_see_eof() ) | return | endif
                            
                                let lines = winline() - s:v.winline
                                if lines > 0
                                    silent! exe "normal! ".lines."\<C-e>"
                                elseif lines < 0
                                    let lines = lines * -1
                                    silent! exe "normal! ".lines."\<C-y>"
                                endif
                                if a:0 | let s:v.winline = winline() | endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Messages
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.msg(text) abort
                                if s:v.eco | return | endif
                            
                                echo "\r"
                                redraw
                                if type(a:text) == type("")
                                    exe "echohl" g:Vm.hi.message
                                    echon a:text
                                    echohl None | return
                                endif
                            
                                for txt in a:text
                                    exe "echohl ".txt[1]
                                    echon txt[0]
                                    echohl None
                                endfor
                            endfun
                            
    1              0.000001 fun! s:Funcs.infoline() abort
                                if s:v.index < 0
                                    return self.msg("No regions.")
                                endif
                                let r = s:R()[s:v.index]
                            
                                let hl = 'Directory' | let H1 = 'Type' | let H2 = 'WarningMsg'
                            
                                if g:VM_debug | let ix = ' '.r.index.' '.r.a.' '.r.b | else | let ix = '' | endif
                                let ix = ['  ['.s:v['index'].ix.']  ', hl]
                            
                                let i1 = [' '  , hl] | let m1 = g:Vm.mappings_enabled? ["M\+", H1] : ["m\-", H2]
                                let i2 = [' / ', hl] | let m2 = s:v.multiline?         ["V\+", H1] : ["v\-", H2]
                                let i3 = [' / ', hl] | let m3 = s:v.single_region?     ["S\+", H1] : ["s\-", H2]
                            
                                let s = len(s:R())>1 ? 's.' : '.'
                                let t = g:Vm.extend_mode? ' region' : ' cursor'
                                let R = [len(s:R()).t.s, hl]
                                let s1 = ['   Current patterns: ', hl]
                                let s2 = [self.pad(string(s:v.search), &columns - 1), H1]
                                let msg = [i1, m1, i2, m2, i3, m3, ix, R, s1, s2]
                                call self.msg(msg)
                            endfun
                            
    1              0.000001 fun! s:Funcs.exit(msg) abort
                                call self.msg(a:msg)
                                call vm#reset(1)
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Toggle options
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Funcs.toggle_option(option) abort
                                if s:v.eco | return | endif
                            
                                let s = "s:v.".a:option
                                exe "let" s "= !".s
                            
                                if a:option == 'multiline'
                                    if !s:v.multiline
                                        call vm#commands#split_lines()
                                    endif
                            
                                elseif a:option == 'single_region'
                                    let a = ['Single region mode: ', 'None']
                                    if !get(g:, 'VM_set_statusline', 2)
                                        if s:v.single_region
                                            call self.msg([a, ['activated', 'Label']])
                                        else
                                            call self.msg([a, ['deactivated', 'WarningMsg']])
                                        endif
                                    endif
                            
                                elseif a:option == 'whole_word'
                                    if empty(s:v.search) | return self.msg('No search patterns.') | endif
                                    let s = s:v.search[0]
                                    let wm = 'WarningMsg' | let L = 'Label'
                            
                                    if s:v.whole_word
                                        if s[:1] != '\<' | let s:v.search[0] = '\<'.s.'\>' | endif
                                        let pats = self.pad(string(s:v.search), &columns - 1)
                                        call self.msg([
                                                    \['Search ->'               , wm], ['    whole word  ', L],
                                                    \['  ->  Current patterns: ', wm], [pats              , L]])
                                    else
                                        if s[:1] == '\<' | let s:v.search[0] = s[2:-3] | endif
                                        let pats = self.pad(string(s:v.search), &columns - 1)
                                        call self.msg([
                                                    \['Search ->'              , wm], ['  not whole word ', L],
                                                    \[' ->  Current patterns: ', wm], [pats               , L]])
                                    endif
                                    call s:V.Search.join()
                                    return
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Utility functions
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 function! s:Funcs.pad(t, n, ...)
                                if len(a:t) > a:n
                                    return a:t[:(a:n-3)]."… "
                                elseif a:0
                                    let spaces = a:n - len(a:t)
                                    let spaces = printf("%".spaces."s", "")
                                    return a:t.spaces
                                else
                                    return a:t
                                endif
                            endfunction
                            
    1              0.000002 fun! s:Funcs.repeat_char(c) abort
                                let s = ''
                                for i in range(&columns - 20)
                                    let s .= a:c
                                endfor
                                return s
                            endfun
                            
    1              0.000001 fun! s:Funcs.redraw() abort
                                if !has('gui_running') | redraw!
                                endif
                            endfun
                            
    1              0.000001 fun! s:Funcs.regions_contents() abort
                                echohl WarningMsg | echo "Index\tID\tA\tB\tw\tl / L\t\ta / b\t\t"
                                            \ "--- Pattern ---\t"
                                            \ "--- Regions contents ---" | echohl None
                                for r in s:R() | call self.region_txt(r) | endfor
                            endfun
                            
    1              0.000002 fun! s:Funcs.region_txt(r) abort
                                let r = a:r
                                let index = printf("%-4d", r.index)
                                let line = substitute(r.txt, '\V\n', '^M', 'g')
                                if len(line) > 80 | let line = line[:80] . '…' | endif
                            
                                echohl Directory
                                echo index."\t".r.id."\t".r.A."\t".r.B."\t".r.w."\t"
                                            \.self.pad(r.l." / ".r.L, 14, 1)
                                            \.self.pad("\t".r.a." / ".r.b, 14, 1)."\t"
                            
                                echohl Type       | echon self.pad(r.pat, 18, 1)
                                echohl None       | echon "\t".line
                                echohl None
                            endfun
                            
    1              0.000002 fun! s:Funcs.not_VM() abort
                                return !exists('b:visual_multi')
                            endfun
                            
                            " vim: et ts=4 sw=4 sts=4 tw=85 :

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/variables.vim
Sourced 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Set vim variable to VM compatible values
                            
    1              0.000016 fun! vm#variables#set() abort
                              let F = b:VM_Selection.Funcs
                              let v = b:VM_Selection.Vars
                            
                              " disable folding, but keep winline
                              if &foldenable
                                call F.Scroll.get(1)
                                let v.oldfold = 1
                                set nofoldenable
                                call F.Scroll.restore()
                              endif
                            
                              if g:VM_case_setting ==? 'smart'
                                set smartcase
                                set ignorecase
                              elseif g:VM_case_setting ==? 'sensitive'
                                set nosmartcase
                                set noignorecase
                              elseif g:VM_case_setting ==? 'ignore'
                                set nosmartcase
                                set ignorecase
                              endif
                            
                              "force default register
                              set clipboard=
                            
                              "disable conceal
                              let &l:conceallevel = vm#comp#conceallevel()
                              set concealcursor=
                            
                              set virtualedit=onemore
                              set ww=h,l,<,>
                              set lz
                            
                              if get(g:, 'VM_cmdheight', 1) > 1
                                let &ch = g:VM_cmdheight
                              endif
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Init VM variables
                            
    1              0.000002 fun! vm#variables#init() abort
                              let F = b:VM_Selection.Funcs
                              let v = b:VM_Selection.Vars
                            
                              "init search
                              let v.def_reg          = F.default_reg()
                              let v.oldreg           = F.get_reg()
                              let v.oldregs_1_9      = F.get_regs_1_9()
                              let v.oldsearch        = [getreg("/"), getregtype("/")]
                              let v.noh              = !v:hlsearch ? 'noh|' : ''
                            
                              "store old vars
                              let v.oldhls           = &hlsearch
                              let v.oldvirtual       = &virtualedit
                              let v.oldwhichwrap     = &whichwrap
                              let v.oldlz            = &lz
                              let v.oldch            = &ch
                              let v.oldcase          = [&smartcase, &ignorecase]
                              let v.indentkeys       = &indentkeys
                              let v.cinkeys          = &cinkeys
                              let v.synmaxcol        = &synmaxcol
                              let v.oldmatches       = getmatches()
                              let v.clipboard        = &clipboard
                              let v.textwidth        = &textwidth
                              let v.conceallevel     = &conceallevel
                              let v.concealcursor    = &concealcursor
                              let v.softtabstop      = &softtabstop
                              let v.statusline       = &statusline
                            
                              "init new vars
                            
                              let v.search           = []
                              let v.IDs_list         = []
                              let v.ID               = 0
                              let v.index            = -1
                              let v.direction        = 1
                              let v.nav_direction    = 1
                              let v.auto             = 0
                              let v.silence          = 0
                              let v.eco              = 0
                              let v.single_region    = 0
                              let v.using_regex      = 0
                              let v.multiline        = 0
                              let v.yanked           = 0
                              let v.merge            = 0
                              let v.insert           = 0
                              let v.whole_word       = 0
                              let v.winline          = 0
                              let v.restore_scroll   = 0
                              let v.find_all_overlap = 0
                              let v.dot              = ''
                              let v.no_search        = 0
                              let v.visual_regex     = 0
                              let v.use_register     = v.def_reg
                              let v.deleting         = 0
                              let v.vmarks           = [getpos("'<"), getpos("'>")]
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Reset vim variables to previous values
                            
    1              0.000002 fun! vm#variables#reset() abort
                              let v = b:VM_Selection.Vars
                            
                              if !v.oldhls
                                set nohlsearch
                              endif
                            
                              let &virtualedit = v.oldvirtual
                              let &whichwrap   = v.oldwhichwrap
                              let &smartcase   = v.oldcase[0]
                              let &ignorecase  = v.oldcase[1]
                              let &lz          = v.oldlz
                              let &cmdheight   = v.oldch
                              let &clipboard   = v.clipboard
                            
                              let &l:indentkeys    = v.indentkeys
                              let &l:cinkeys       = v.cinkeys
                              let &l:synmaxcol     = v.synmaxcol
                              let &l:textwidth     = v.textwidth
                              let &l:softtabstop   = v.softtabstop
                              let &l:conceallevel  = v.conceallevel
                              let &l:concealcursor = v.concealcursor
                            
                              if get(g:, 'VM_set_statusline', 2)
                                let &l:statusline  = v.statusline
                              endif
                            
                              silent! unlet b:VM_skip_reset_once_on_bufleave
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Reset VM global variables
                            
    1              0.000002 fun! vm#variables#reset_globals()
                              let b:VM_Backup = {}
                              let b:VM_Selection = {}
                              let g:Vm.buffer = 0
                              let g:Vm.extend_mode = 0
                              let g:Vm.finding = 0
                            endfun
                            
                            " vim: et ts=2 sw=2 sts=2 tw=79 :

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim
Sourced 1 time
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
                            "script to handle compatibility issues with other plugins
                            
    1              0.000056 let s:plugins = extend({
                                        \'ctrlsf':    {
                                        \   'test': { -> &ft == 'ctrlsf' },
                                        \   'enable': 'call ctrlsf#buf#ToggleMap(1)',
                                        \   'disable': 'call ctrlsf#buf#ToggleMap(0)',
                                        \},
                                        \'AutoPairs': {
                                        \   'test': { -> exists('b:autopairs_enabled') && b:autopairs_enabled },
                                        \   'enable': 'unlet b:autopairs_loaded | call AutoPairsTryInit() | let b:autopairs_enabled = 1',
                                        \   'disable': 'let b:autopairs_enabled = 0',
                                        \},
                                        \'smartinput': {
                                        \   'test': { -> exists('g:loaded_smartinput') && g:loaded_smartinput == 1 },
                                        \   'enable': 'unlet! b:smartinput_disabled',
                                        \   'disable': 'let b:smartinput_disabled = 1',
                                        \},
                                        \'tagalong': {
                                        \   'test': { -> exists('b:tagalong_initialized') },
                                        \   'enable': 'TagalongInit',
                                        \   'disable': 'TagalongDeinit'
                                        \},
                                        \}, get(g:, 'VM_plugins_compatibilty', {}))
                            
    1              0.000003 let s:disabled_deoplete = 0
    1              0.000002 let s:disabled_ncm2     = 0
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#comp#init() abort
                                " Set variables according to plugin needs. "{{{1
                                let s:V = b:VM_Selection
                                let s:v = s:V.Vars
                                let s:v.disabled_plugins = []
                            
                                silent! call VM_Start()
                                silent doautocmd <nomodeline> User visual_multi_start
                            
                                if exists('g:loaded_youcompleteme')
                                    let g:VM_use_first_cursor_in_line = 1
                                endif
                            
                                if exists('b:doge_interactive')
                                    call doge#deactivate()
                                endif
                            
                                for plugin in keys(s:plugins)
                                    let p = s:plugins[plugin]
                            
                                    if p.test()
                                        exe p.disable
                                        call add(s:v.disabled_plugins, plugin)
                                    endif
                                endfor
                            endfun "}}}
                            
                            
    1              0.000002 fun! vm#comp#icmds() abort
                                " Insert mode starts: temporarily disable autocompletion engines. {{{1
                                if exists('g:loaded_deoplete') && g:deoplete#is_enabled()
                                    call deoplete#disable()
                                    let s:disabled_deoplete = 1
                                elseif exists('b:ncm2_enable') && b:ncm2_enable
                                    let b:ncm2_enable = 0
                                    let s:disabled_ncm2 = 1
                                endif
                            endfun "}}}
                            
                            
    1              0.000002 fun! vm#comp#TextChangedI() abort
                                " Insert mode change: re-enable autocompletion engines. {{{1
                                if exists('g:loaded_deoplete') && s:disabled_deoplete
                                    call deoplete#enable()
                                    let s:disabled_deoplete = 0
                                elseif s:disabled_ncm2
                                    let b:ncm2_enable = 1
                                    let s:disabled_ncm2 = 0
                                endif
                            endfun "}}}
                            
                            
    1              0.000001 fun! vm#comp#conceallevel() abort
                                " indentLine compatibility. {{{1
                                return exists('b:indentLine_ConcealOptionSet') && b:indentLine_ConcealOptionSet
                            endfun "}}}
                            
                            
    1              0.000001 fun! vm#comp#iobj() abort
                                " Inner text objects that should avoid using the select operator. {{{1
                                return exists('g:loaded_targets') ? ['q'] : []
                            endfun "}}}
                            
                            
    1              0.000001 fun! vm#comp#reset() abort
                                " Called during VM exit. "{{{1
                                if exists('g:loaded_deoplete') && s:disabled_deoplete
                                    call deoplete#enable()
                                    let s:disabled_deoplete = 0
                                elseif s:disabled_ncm2
                                    let b:ncm2_enable = 1
                                    let s:disabled_ncm2 = 0
                                endif
                            
                                "restore plugins functionality if necessary
                                for plugin in keys(s:plugins)
                                    if index(s:v.disabled_plugins, plugin) >= 0
                                        exe s:plugins[plugin].enable
                                    endif
                                endfor
                            endfun "}}}
                            
                            
    1              0.000001 fun! vm#comp#exit() abort
                                " Called last on VM exit. "{{{1
                                silent! call VM_Exit()
                                silent doautocmd <nomodeline> User visual_multi_exit
                            endfun "}}}
                            
                            
    1              0.000001 fun! vm#comp#add_line() abort
                                " Ensure a line is added with these text objects, while changing in cursor mode. "{{{1
                            
                                let l = []
                                if exists('g:loaded_textobj_indent')
                                    let l += ['ii', 'ai', 'iI', 'aI']
                                endif
                                if exists('g:loaded_textobj_function')
                                    let l += ['if', 'af', 'iF', 'aF']
                                endif
                                return l
                            endfun "}}}
                            
                            
    1              0.000001 fun! vm#comp#no_reindents() abort
                                " Don't reindent for filetypes. "{{{1
                                return ['ctrlsf']
                            endfun "}}}
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=marker

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim
Sourced 1 time
Total time:   0.000437
 Self time:   0.000437

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Global class
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000006 let s:Global = {}
                            
    1              0.000003 fun! vm#global#init() abort
                                " Store Global class in buffer VM dictionary.
                            
                                let s:V = b:VM_Selection
                                let s:v = s:V.Vars
                                let s:F = s:V.Funcs
                            
                                let s:X = { -> g:Vm.extend_mode }
                                let s:R = { -> s:V.Regions      }
                            
                                return s:Global
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Regions creation and access
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Global.new_region() abort
                                " Get the region under cursor, or create a new one if there is none.
                            
                                let R = self.region_at_pos()
                                if empty(R)
                                    let R = vm#region#new(0)
                                    let s:v.was_region_at_pos = 0
                                else
                                    let s:v.was_region_at_pos = 1
                                endif
                            
                                if !s:v.eco
                                    call self.select_region(R.index)
                                    call s:V.Search.update_patterns()
                                    call s:F.restore_reg()
                                endif
                                return R
                            endfun
                            
                            
    1              0.000002 fun! s:Global.new_cursor(...) abort
                                " Create a new cursor if there isn't already a region.
                            
                                let R = self.region_at_pos()
                            
                                if empty(R)
                                    return vm#region#new(1)
                                elseif a:0  " toggle cursor
                                    call R.clear()
                                endif
                                return s:F.should_quit() ? vm#reset() : R
                            endfun
                            
                            
    1              0.000002 fun! s:Global.active_regions(...) abort
                                " Return current working set of regions.
                            
                                if s:v.single_region    | return [s:V.Regions[s:v.index]]
                                else                    | return s:V.Regions
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Global.get_all_regions(...) abort
                                " Get all regions, optionally between two byte offsets.
                            
                                let ows = &wrapscan
                                set nowrapscan
                                let [l:start, l:end] = a:0 ? [a:1, a:2] : [1, 0]
                                call s:F.Cursor(l:start)
                                silent keepjumps normal! ygn
                                let R = self.new_region()
                                while 1
                                    try
                                        silent keepjumps normal! nygn
                                        if a:0 && s:F.pos2byte("'[") > l:end
                                            break
                                        endif
                                        let R = self.new_region()
                                        if !s:v.find_all_overlap && self.overlapping_regions(R)
                                            let s:v.find_all_overlap = 1
                                        endif
                                    catch
                                        break
                                    endtry
                                endwhile
                                let &wrapscan = ows
                                return R
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Change mode
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Global.change_mode(...) abort
                                " Change from extend to cursor mode and viceversa.
                                " Merge cursors if transitioning from cursor mode, but reset direction
                                " transitioning from extend mode.
                            
                                if !s:X() | call self.merge_cursors()
                                else      | call self.backup_last_regions()
                                endif
                            
                                let g:Vm.extend_mode = !s:X()
                            
                                let ix = s:v.index
                                call s:F.Scroll.get()
                                if s:X()
                                    call self.update_regions()
                                else
                                    call self.collapse_regions()
                                endif
                            
                                let R = self.select_region(ix)
                            
                                if a:0  "called manually
                                    let s:v.restore_scroll = 1
                                    call s:F.Scroll.restore()
                                endif
                                return R
                            endfun
                            
                            
    1              0.000001 fun! s:Global.cursor_mode() abort
                                " Set cursor mode. Return 1 if mode had to be changed.
                                if s:X() | call self.change_mode() | return 1 | endif
                            endfun
                            
                            
    1              0.000001 fun! s:Global.extend_mode() abort
                                " Set extend mode. Return 1 if mode had to be changed.
                                if !s:X() | call self.change_mode() | return 1 | endif
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Highlight
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000001 fun! s:Global.update_highlight(...) abort
                                " Update highlight for all regions.
                                if s:v.eco | return | endif
                            
                                call self.remove_highlight()
                                for r in s:R()
                                    call r.highlight()
                                endfor
                            
                                call self.update_cursor_highlight()
                            endfun
                            
                            
    1              0.000001 fun! s:Global.update_cursor_highlight(...) abort
                                " Set cursor highlight, depending on extending mode.
                                if s:v.eco | return | endif
                            
                                highlight clear MultiCursor
                            
                                if s:v.insert
                                    exe "highlight link MultiCursor ".g:Vm.hi.insert
                            
                                elseif !s:X() && self.all_empty()
                                    exe "highlight link MultiCursor ".g:Vm.hi.mono
                            
                                else
                                    exe "highlight link MultiCursor ".g:Vm.hi.cursor
                                endif
                            endfun
                            
                            
    1              0.000001 fun! s:Global.remove_highlight() abort
                                " Remove all regions' highlight.
                                for r in s:R()
                                    call r.remove_highlight()
                                endfor
                                call vm#clearmatches()
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Regions functions
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000004 fun! s:Global.all_empty() abort
                                " If not all regions are empty, turn on extend mode.
                                for r in s:R()
                                    if r.a != r.b
                                        if !s:X() | let g:Vm.extend_mode = 1 | endif
                                        return 0
                                    endif
                                endfor
                                return 1
                            endfun
                            
                            
    1              0.000001 fun! s:Global.update_regions() abort
                                " Force regions update.
                                if s:v.eco | return | endif
                            
                                if s:X()
                                    for r in s:R() | call r.update_region() | endfor
                                else
                                    for r in s:R() | call r.update_cursor() | endfor
                                endif
                                call self.update_highlight()
                                call s:F.restore_reg()
                            endfun
                            
                            
    1              0.000002 fun! s:Global.update_and_select_region(...) abort
                                " Update regions and select region at position, index or id.
                                if s:v.merge
                                    let s:v.merge = 0 | return self.merge_regions()
                                endif
                            
                                call self.remove_highlight()
                            
                                call self.reset_byte_map(0)
                                call self.reset_vars()
                                call self.update_indices()
                                call self.update_regions()
                            
                                "a region is going to be reselected:
                                "   no arguments        ->  position '.'
                                "   a:1 not a dict      ->  position (a string, a list [ln, col], an offset)
                                "   {'index': i}        ->  index
                                "   {'id': i}           ->  id
                            
                                let nR = len(s:R())
                                if !nR | return vm#reset() | endif
                            
                                if !g:VM_reselect_first
                                    if exists('s:v.restore_index')
                                        let i = s:v.restore_index >= nR? nR - 1 : s:v.restore_index
                                        let R = self.select_region(i)
                                        unlet s:v.restore_index
                                    elseif a:0
                                        if type (a:1) != v:t_dict
                                            let R = self.select_region_at_pos(a:1)
                                        elseif  has_key(a:1, 'index')
                                            let i = a:1.index >= nR? nR - 1 : a:1.index
                                            let R = self.select_region(i)
                                        elseif has_key(a:1, 'id')
                                            let R = self.select_region(s:F.region_with_id(a:1.id).index)
                                        else
                                            return s:F.msg('[visual-multi] '.
                                                        \  'update_and_select_region() '.
                                                        \  'called with wrong arguments')
                                        endif
                                    else
                                        let R = self.select_region_at_pos('.')
                                    endif
                                else
                                    let R = self.select_region(0)
                                endif
                            
                                return s:F.should_quit() ? vm#reset() : R
                            endfun
                            
                            
    1              0.000002 fun! s:Global.update_map_and_select_region(...) abort
                                " Update only the bytes map, skipping region update.
                                " Regions have been just created and there's no need to update them.
                                if s:v.find_all_overlap
                                    let s:v.find_all_overlap = 0
                                    return self.merge_regions()
                                endif
                            
                                call self.reset_vars()
                                call self.update_indices()
                                call self.reset_byte_map(1)
                                call self.update_highlight()
                                let R = self.select_region_at_pos(a:0? a:1 : '.')
                            
                                return s:F.should_quit() ? vm#reset() : R
                            endfun
                            
                            
    1              0.000001 fun! s:Global.erase_regions() abort
                                " Erase all regions.
                                call self.remove_highlight()
                                let s:V.Regions = []
                                let s:V.Bytes = {}
                                let s:v.index = -1
                            endfun
                            
                            
    1              0.000002 fun! s:Global.restore_regions(index) abort
                                " Restore previous regions from backup.
                                let backup = b:VM_Backup | call self.erase_regions()
                            
                                let tick = backup.ticks[a:index]
                                let s:V.Regions = deepcopy(backup[tick].regions)
                                let g:Vm.extend_mode = backup[tick].X
                                return self.update_and_select_region()
                            endfun
                            
                            
    1              0.000001 fun! s:Global.backup_regions() abort
                                " Store a copy of the current regions.
                            
                                let tick   = undotree().seq_cur
                                let backup = b:VM_Backup
                                let index  = index(backup.ticks, backup.last)
                            
                                if index < len(backup.ticks) - 1
                                    let backup.ticks = backup.ticks[:index]
                                endif
                            
                                call add(backup.ticks, tick)
                                let backup[tick] = { 'regions': deepcopy(s:R()), 'X': s:X() }
                                let backup.last = tick
                            endfun
                            
                            
    1              0.000002 fun! s:Global.backup_last_regions() abort
                                " Create a backup of last set of regions.
                            
                                let b:VM_LastBackup = {}
                                let b:VM_LastBackup.extend = g:Vm.extend_mode
                                let b:VM_LastBackup.regions = map(deepcopy(s:R()), "{'A': v:val.A, 'B': v:val.B}")
                                let b:VM_LastBackup.search = s:v.search
                                let b:VM_LastBackup.index = s:v.index
                                let s:v.direction = 1
                            endfun
                            
                            
    1              0.000001 fun! s:Global.collapse_regions() abort
                                " Collapse regions to cursors and turn off extend mode.
                            
                                call self.reset_byte_map(0)
                            
                                for r in s:R() | call r.update_cursor([r.l, (r.dir? r.a : r.b)]) | endfor
                                let g:Vm.extend_mode = 0
                                call self.update_highlight()
                            endfun
                            
                            
    1              0.000002 fun! s:Global.select_region(i) abort
                                " Adjust cursor position of the region at index, then return region.
                            
                                if !len(s:R()) | return | endif
                            
                                let i = a:i >= len(s:R())? 0 : a:i
                            
                                let R = s:R()[i]
                                call cursor(R.cur_ln(), R.cur_col())
                                call s:F.Scroll.restore()
                                let s:v.index = R.index
                                return R
                            endfun
                            
                            
    1              0.000002 fun! s:Global.select_region_at_pos(pos) abort
                                " Try to select a region at the given position.
                            
                                let r = self.region_at_pos(a:pos)
                                if !empty(r)
                                    return self.select_region(r.index)
                                else
                                    return self.select_region(self.nearest_region().index)
                                endif
                            endfun
                            
                            
    1              0.000001 fun! s:Global.region_at_pos(...) abort
                                " Return the region at position, or an empty dict if not found.
                            
                                let pos = a:0 ? s:F.pos2byte(a:1) : s:F.curs2byte()
                                if s:X() && !has_key(s:V.Bytes, pos) | return {} | endif
                            
                                for r in s:R()
                                    if pos >= r.A && pos <= r.B
                                        return r
                                    endif
                                endfor
                                return {}
                            endfun
                            
                            
    1              0.000001 fun! s:Global.nearest_region(...) abort
                                " Return the nearest region at position.
                            
                                let Rs = s:R() | if !len(Rs) | return {} | endif
                            
                                let pos = a:0 ? s:F.pos2byte(a:1) : s:F.curs2byte()
                            
                                if pos <= Rs[0].A  | return Rs[0]  | endif
                                if pos >= Rs[-1].B | return Rs[-1] | endif
                            
                                for r in Rs
                                    if pos <= r.B
                                        return r
                                    endif
                                endfor
                            endfun
                            
                            
    1              0.000001 fun! s:Global.reset_index() abort
                                " Reset index to current region, 0, or max - 1.
                            
                                if !len(s:R())
                                    let s:v.index = -1
                                    return
                                endif
                                let r = self.region_at_pos()
                                if !empty(r)
                                    let s:v.index = r.index
                                elseif line('.') >= s:R()[-1].L
                                    let s:v.index = len(s:R()) - 1
                                else
                                    let s:v.index = 0
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Global.overlapping_regions(R) abort
                                " Check if two regions are overlapping.
                            
                                let B = range(a:R.A, a:R.B)
                                for b in B
                                    if s:V.Bytes[b] > 1 | return 1 | endif
                                endfor
                            endfun
                            
                            
    1              0.000002 fun! s:Global.merge_overlapping(R) abort
                                " Return merged regions if region had overlapping regions.
                            
                                let overlap = self.overlapping_regions(a:R)
                                return overlap ? self.merge_regions() : a:R
                            endfun
                            
                            
    1              0.000001 fun! s:Global.remove_empty_lines() abort
                                " Remove regions that consist of the endline marker only.
                            
                                for r in self.active_regions()
                                    if r.a == 1 && r.A == r.B && col([r.l, '$']) == 1
                                        call r.clear()
                                    endif
                                endfor
                            endfun
                            
                            
    1              0.000002 fun! s:Global.reset_byte_map(update) abort
                                " Reset byte map for all regions.
                            
                                let s:V.Bytes = {}
                            
                                if a:update
                                    for r in self.active_regions() | call r.update_bytes_map() | endfor
                                endif
                            endfun
                            
                            
    1              0.000001 fun! s:Global.reset_vars() abort
                                " Reset variables during final regions update.
                                "Note: this eco/auto check is old and seems wrong. Keeping for now but it should go
                            
                                if !( s:v.eco || s:v.auto ) | return | endif
                            
                                let s:v.auto = 0    | let s:v.eco = 0
                                let s:v.no_search = 0
                                call s:F.restore_reg()
                            endfun
                            
                            
    1              0.000001 fun! s:Global.remove_last_region(...) abort
                                " Remove last region and reselect the previous one.
                                for r in s:R()
                                    if r.id == ( a:0? a:1 : s:v.IDs_list[-1] )
                                        call r.clear()
                                        break
                                    endif
                                endfor
                            
                                if s:F.should_quit()
                                    return vm#reset()
                                else
                                    "reselect previous region
                                    let i = a:0? (r.index > 0? r.index-1 : 0) : s:v.index
                                    return self.select_region(i)
                                endif
                            endfun
                            
                            
    1              0.000001 fun! s:Global.update_indices(...) abort
                                " Adjust region indices.
                            
                                if a:0
                                    let i = a:1
                                    for r in s:R()[i:]
                                        let r.index = i
                                        let i += 1
                                    endfor
                                    return
                                endif
                            
                                let i = 0
                                for r in s:R()
                                    let r.index = i
                                    let i += 1
                                endfor
                            endfun
                            
                            
    1              0.000002 fun! s:Global.update_region_patterns(pat) abort
                                " Update the patterns for the appropriate regions.
                            
                                for r in s:R()
                                    if a:pat =~ r.pat || r.pat =~ a:pat
                                        let r.pat = a:pat
                                    endif
                                endfor
                            endfun
                            
                            
    1              0.000001 fun! s:Global.regions_text() abort
                                " Return a list with all regions' contents.
                            
                                let t = []
                                for r in self.active_regions() | call add(t, r.txt) | endfor
                                return t
                            endfun
                            
                            
    1              0.000002 fun! s:Global.check_mutliline(all, ...) abort
                                " Check if multiline must be enabled.
                            
                                for r in a:0? [a:1] : s:R()
                                    if !s:v.multiline && r.h
                                        call s:F.toggle_option('multiline') | break
                                    endif
                                endfor
                            endfun
                            
                            
    1              0.000002 fun! s:Global.lines_with_regions(reverse, ...) abort
                                " Find lines with regions.""
                            
                                let lines = {}
                                for r in s:R()
                                    "called for a specific line
                                    if a:0 && r.l != a:1 | continue | endif
                            
                                    "add region index to indices for that line
                                    let lines[r.l] = get(lines, r.l, [])
                                    call add(lines[r.l], r.index)
                                endfor
                            
                                for line in keys(lines)
                                    "sort list so that lower indices are put farther in the list
                            
                                    if len(lines[line]) > 1
                                        if a:reverse | call reverse(sort(lines[line], 'n'))
                                        else         | call sort(lines[line], 'n')
                                        endif
                                    endif
                                endfor
                                return lines
                            endfun
                            
                            
    1              0.000002 fun! s:Global.one_region_per_line() abort
                                " Remove all regions in each line, except the first one.
                            
                                let new_regions = []
                                let lines = []
                                for r in s:R()
                                    if index(lines, r.l) < 0
                                        call add(new_regions, r)
                                        call add(lines, r.l)
                                    endif
                                endfor
                                call self.erase_regions()
                                let s:V.Regions = new_regions
                                call self.update_indices()
                            endfun
                            
                            
    1              0.000001 fun! s:Global.reorder_regions() abort
                                " Reorder regions, so that their byte offsets are consecutive.
                            
                                let As = sort(map(copy(s:R()), 'v:val.A'), 'n')
                                let Regions = []
                                while 1
                                    for r in s:R()
                                        if r.A == As[0]
                                            call add(Regions, r)
                                            call remove(As, 0)
                                            break
                                        endif
                                    endfor
                                    if !len(As) | break | endif
                                endwhile
                                let s:V.Regions = Regions
                                call self.update_indices()
                                call self.reset_index()
                            endfun
                            
                            
    1              0.000001 fun! s:Global.split_lines() abort
                                " Split regions, so that each is contained in a single line.
                            
                                let prev = s:v.index
                            
                                "make a list of regions to split
                                let lts = filter(copy(self.active_regions()), 'v:val.h')
                            
                                for r in lts
                                    let R = s:R()[r.index].remove()
                            
                                    for n in range(R.h+1)
                                        if n == 0  "first line
                                            call vm#region#new(0, R.l, R.l, R.a, len(getline(R.l)))
                                        elseif n < R.h
                                            call vm#region#new(0, R.l+n, R.l+n, 1, len(getline(R.l+n)))
                                        else
                                            call vm#region#new(0, R.L, R.L, 1, R.b)
                                        endif
                                    endfor
                                endfor
                            endfun
                            
                            
    1              0.000002 fun! s:Global.filter_by_expression(exp, type) abort
                                " Filter out regions that don't match an expression or a pattern.
                            
                                let ids_to_remove = []
                                if a:type == 'pattern'
                                    let exp = "r.txt =~ '".a:exp."'"
                                elseif a:type == '!pattern'
                                    let exp = "r.txt !~ '".a:exp."'"
                                else
                                    let exp = s:F.get_expr(a:exp)
                                endif
                                try
                                    for r in s:R()
                                        if !eval(exp)
                                            call add(ids_to_remove, r.id)
                                        endif
                                    endfor
                                catch
                                    echohl ErrorMsg | echo "\tinvalid expression" | echohl None | return
                                endtry
                                call self.remove_regions_by_id(ids_to_remove)
                            endfun
                            
                            
    1              0.000002 fun! s:Global.remove_regions_by_id(list) abort
                                " Remove a list of regions by id.
                            
                                for id in a:list
                                    call s:F.region_with_id(id).remove()
                                endfor
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Merging regions
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Global.merge_cursors() abort
                                " Merge overlapping cursors.
                            
                                let ids_to_remove = [] | let last_A = 0 | let pos = getpos('.')[1:2]
                            
                                " we only check offset r.A, since for cursors r.A == r.B
                                for r in s:R()
                                    if r.A == last_A | call add(ids_to_remove, r.id) | endif
                                    let last_A = r.A
                                endfor
                            
                                call self.remove_regions_by_id(ids_to_remove)
                                return self.update_and_select_region(pos)
                            endfun
                            
                            
    1              0.000001 fun! s:Global.merge_regions(...) abort
                                " Merge overlapping regions.
                            
                                if !len(s:R()) | return {}                   | endif
                                if !s:X()      | return self.merge_cursors() | endif
                            
                                let s:v.eco = 1
                                let pos = getpos('.')[1:2]
                                call self.rebuild_from_map(s:V.Bytes)
                                return self.update_map_and_select_region(pos)
                            endfun
                            
                            
    1              0.000002 fun! s:Global.merge_maps(map) abort
                                " Merge temporary and primary regions maps.
                            
                                for b in keys(a:map)
                                    let s:V.Bytes[b] = get(s:V.Bytes, b, 0) + a:map[b]
                                endfor
                                if empty(s:V.Bytes) | return {} | endif
                                let pos = getpos('.')[1:2]
                                call self.rebuild_from_map(s:V.Bytes)
                                return self.update_map_and_select_region(pos)
                            endfun
                            
                            
    1              0.000002 fun! s:Global.subtract_maps(map) abort
                                " Subtract temporary map from primary region map.
                            
                                for b in keys(a:map)
                                    silent! unlet s:V.Bytes[b]
                                endfor
                                return self.merge_regions()
                            endfun
                            
                            
    1              0.000002 fun! s:Global.rebuild_from_map(map, ...) abort
                                " Rebuild regions from bytes map.
                            
                                let By = sort(map(keys(a:map), 'str2nr(v:val)'), 'n')
                                if a:0
                                    let [start, end] = a:1
                                    call filter(By, 'v:val >= start && v:val <= end')
                                endif
                                let A = By[0] | let B = By[0]
                            
                                call self.erase_regions()
                            
                                for i in By[1:]
                                    if i == B+1
                                        let B = i
                                    else
                                        call vm#region#new(0, A, B)
                                        let A = i | let B = i
                                    endif
                                endfor
                                call vm#region#new(0, A, B)
                            endfun
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " python section (functions here will overwrite previous ones)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000005 if !g:VM_use_python | finish | endif
                            
                            fun! s:Global.rebuild_from_map(map, ...) abort
                                let l:dict = a:map
                                let l:range = a:0 ? a:1 : []
                                python3 vm.py_rebuild_from_map()
                            endfun
                            
                            fun! s:Global.lines_with_regions(reverse, ...) abort
                                let l:specific_line = a:0 ? a:1 : 0
                                python3 vm.py_lines_with_regions()
                                return lines
                            endfun
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=indent fdn=1

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/search.vim
Sourced 1 time
Total time:   0.000213
 Self time:   0.000213

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Initialize
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 fun! vm#search#init() abort
                                let s:V        = b:VM_Selection
                                let s:v        = s:V.Vars
                                let s:F        = s:V.Funcs
                                let s:G        = s:V.Global
                                return s:Search
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Search
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 let s:Search = {}
    1              0.000007 let s:R = { -> s:V.Regions }
    1              0.000007 let s:no_visual = { p -> substitute(p, '\\%V', '', 'g') }
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:update_search(p) abort
                                " Update search patterns, unless s:v.no_search is set.
                                if s:v.no_search | return | endif
                            
                                if !empty(a:p) && index(s:v.search, a:p) < 0   "not in list
                                    call insert(s:v.search, a:p)
                                endif
                            
                                if s:v.eco | let @/ = s:v.search[0]
                                else       | call s:Search.join()
                                endif
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Search.get_pattern(register) abort
                                let t = getreg(a:register)
                                let t = self.escape_pattern(t)
                                let p = s:v.whole_word ? '\<'.t.'\>' : t
                                "if whole word, ensure pattern can be found
                                let p = search(p, 'ncw')? p : t
                                return p
                            endfun
                            
                            
    1              0.000002 fun! s:Search.add(...) abort
                                " Add a new search pattern.
                                let pat = a:0? a:1 : self.get_pattern(s:v.def_reg)
                                call s:update_search(pat)
                            endfun
                            
                            
    1              0.000001 fun! s:Search.add_if_empty(...) abort
                                " Add a new search pattern, only if no pattern is set.
                                if empty(s:v.search)
                                    if a:0 | call self.add(a:1)
                                    else   | call self.add(s:R()[s:v.index].pat)
                                    endif
                                endif
                            endfun
                            
                            
    1              0.000001 fun! s:Search.ensure_is_set(...) abort
                                " Ensure there is an active search.
                                if empty(s:v.search)
                                    if !len(s:R()) || empty(s:R()[0].txt)
                                        call self.get_slash_reg()
                                    else
                                        call self.add(self.escape_pattern(s:R()[0].txt))
                                    endif
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Search.get_from_region() abort
                                " Get a new search pattern from the selected region, with a fallback.
                                let r = s:G.region_at_pos()
                                if !empty(r)
                                    let pat = self.escape_pattern(r.txt)
                                    call s:update_search(pat) | return
                                endif
                            
                                "fallback to first region.txt or @/, if no active search
                                if empty(s:v.search) | call self.ensure_is_set() | endif
                            endfun
                            
                            
    1              0.000001 fun! s:Search.get_slash_reg(...) abort
                                " Get pattern from current "/" register. Use backup register if empty.
                                if a:0 | let @/ = a:1 | endif
                                call s:update_search(s:no_visual(getreg('/')))
                                if empty(s:v.search)
                                    call s:update_search(s:no_visual(s:v.oldsearch[0]))
                                endif
                            endfun
                            
                            
    1              0.000001 fun! s:Search.validate() abort
                                " Check whether the current search is valid, if not, clear the search.
                                if s:v.eco || empty(s:v.search) | return v:false | endif
                            
                                call self.join()
                            
                                "pattern found, ok
                                if search(@/, 'cnw') | return v:true | endif
                            
                                while 1
                                    let i = 0
                                    for p in s:v.search
                                        if !search(@/, 'cnw') | call remove(s:v.search, i) | break | endif
                                        let i += 1
                                    endfor
                                    break
                                endwhile
                                call self.join()
                                return v:true
                            endfun
                            
                            
    1              0.000002 fun! s:Search.update_patterns(...) abort
                                " Update the search patterns if the active search isn't listed.
                                let current = a:0? [a:1] : split(@/, '\\|')
                                for p in current
                                    if index(s:v.search, p) >= 0 | return | endif
                                endfor
                                if a:0 | call self.get_from_region()
                                else   | call self.get_slash_reg()
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Search.escape_pattern(t) abort
                                return substitute(escape(a:t, '\/.*$^~[]'), "\n", '\\n', "g")
                            endfun
                            
                            
    1              0.000001 fun! s:Search.join(...) abort
                                " Join current patterns, optionally replacing them.
                                if a:0 | let s:v.search = a:1 | endif
                                let @/ = join(s:v.search, '\|')
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Search menu and options
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:pattern_rewritten(t, i) abort
                                " Return true if a pattern has been rewritten.
                                if @/ == '' | return | endif
                            
                                let p = s:v.search[a:i]
                                if a:t =~ p || p =~ a:t
                                    let old = s:v.search[a:i]
                                    let s:v.search[a:i] = a:t
                                    call s:G.update_region_patterns(a:t)
                                    call s:Search.join()
                                    let [ wm, L ] = [ 'WarningMsg', 'Label' ]
                                    call s:F.msg([['Pattern updated:   [', wm ], [old, L],
                                                \     [']  ->  [', wm],          [a:t, L],
                                                \     ["]\n", wm]])
                                    return 1
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Search.rewrite(last) abort
                                " Rewrite patterns, if substrings of the selected text.
                                let r = s:G.region_at_pos() | if empty(r) | return | endif
                            
                                let t = self.escape_pattern(r.txt)
                            
                                if a:last
                                    "add a new pattern if not found
                                    if !s:pattern_rewritten(t, 0)
                                        call self.add(t)
                                    endif
                                else
                                    "rewrite if found among any pattern, else do nothing
                                    for i in range ( len(s:v.search) )
                                        if s:pattern_rewritten(t, i) | break | endif
                                    endfor
                                endif
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:update_current(...) abort
                                " Update current search pattern to index 0 or <arg>.
                            
                                if empty(s:v.search)          | let @/ = ''
                                elseif !a:0                   | let @/ = s:v.search[0]
                                elseif a:1 < 0                | let @/ = s:v.search[0]
                                elseif a:1 >= len(s:v.search) | let @/ = s:v.search[a:1-1]
                                else                          | let @/ = s:v.search[a:1]
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Search.remove(also_regions) abort
                                " Remove a search pattern, and optionally its associated regions.
                                let pats = s:v.search
                            
                                if !empty(pats)
                                    let s1 = ['Which index? ', 'WarningMsg']
                                    let s2 = [string(s:v.search), 'Type']
                                    call s:F.msg([s1,s2])
                                    let i = nr2char(getchar())
                                    if ( i == "\<esc>" ) | return s:F.msg("\tCanceled.\n")             | endif
                                    if ( i < 0 || i >= len(pats) ) | return s:F.msg("\tWrong index\n") | endif
                                    call s:F.msg("\n")
                                    let pat = pats[i]
                                    call remove(pats, i)
                                    call s:update_current()
                                else
                                    return s:F.msg('No search patters yet.')
                                endif
                            
                                if a:also_regions
                                    let i = len(s:R()) - 1 | let removed = 0
                                    while i>=0
                                        if s:R()[i].pat ==# pat
                                            call s:R()[i].remove()
                                            let removed += 1
                                        endif
                                        let i -= 1
                                    endwhile
                            
                                    if removed | call s:G.update_and_select_region() | endif
                                endif
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Search.case() abort
                                " Cycle case settings.
                                if &smartcase              "smartcase        ->  case sensitive
                                    set nosmartcase
                                    set noignorecase
                                    call s:F.msg([['Search -> ', 'WarningMsg'], ['  case sensitive', 'Label']])
                            
                                elseif !&ignorecase        "case sensitive   ->  ignorecase
                                    set ignorecase
                                    call s:F.msg([['Search -> ', 'WarningMsg'], ['  ignore case', 'Label']])
                            
                                else                       "ignore case      ->  smartcase
                                    set smartcase
                                    set ignorecase
                                    call s:F.msg([['Search -> ', 'WarningMsg'], ['  smartcase', 'Label']])
                                endif
                            endfun
                            
                            
    1              0.000001 fun! s:Search.menu() abort
                                echohl WarningMsg | echo "1 - " | echohl Type | echon "Rewrite Last Search"   | echohl None
                                echohl WarningMsg | echo "2 - " | echohl Type | echon "Rewrite All Search"    | echohl None
                                echohl WarningMsg | echo "3 - " | echohl Type | echon "Read From Search"      | echohl None
                                echohl WarningMsg | echo "4 - " | echohl Type | echon "Add To Search"         | echohl None
                                echohl WarningMsg | echo "5 - " | echohl Type | echon "Remove Search"         | echohl None
                                echohl WarningMsg | echo "6 - " | echohl Type | echon "Remove Search Regions" | echohl None
                                echohl Directory | echo "Enter an option: " | echohl None
                                let c = nr2char(getchar())
                                echon c "\t"
                                if c == 1
                                    call self.rewrite(1)
                                elseif c == 2
                                    call self.rewrite(0)
                                elseif c == 3
                                    call self.get_slash_reg()
                                elseif c == 4
                                    call self.get_from_region()
                                elseif c == 5
                                    call self.remove(0)
                                elseif c == 6
                                    call self.remove(1)
                                endif
                                call feedkeys("\<cr>", 'n')
                            endfun
                            
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=indent fdn=1

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/edit.vim
Sourced 1 time
Total time:   0.000312
 Self time:   0.000312

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Edit class
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000007 let s:Edit = {'skip_index': -1}
                            
    1              0.000002 fun! vm#edit#init() abort
                                " Initialize script variables
                                let s:V = b:VM_Selection
                                let s:v = s:V.Vars
                                let s:G = s:V.Global
                                let s:F = s:V.Funcs
                            
                                let s:v.new_text     = []
                                let s:v.W            = []
                                let s:v.storepos     = []
                                let s:v.extra_spaces = []
                                let s:can_multiline  = 0
                            
                                call vm#icmds#init()
                                return extend(s:Edit, vm#ecmds1#init())
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 let s:R = { -> s:V.Regions }
    1              0.000004 let s:X = { -> g:Vm.extend_mode }
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Commands at cursors
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.run_normal(cmd, ...) abort
                                " Run normal command over regions.
                                " optional arg is a dictionary with options
                                "-----------------------------------------------------------------------
                            
                                if a:cmd == -1
                                    call s:F.special_statusline('NORMAL')
                                    let bang = a:0 && !get(a:1, 'recursive', 1) ? '!' : ''
                                    let cmd = input(':normal'.bang.' ')
                                    unlet s:v.statusline_mode
                                    if empty(cmd) | return s:F.msg('Normal command aborted.') | endif
                            
                                elseif a:cmd == '~' && s:X()
                                    return self.run_visual('~', 0)
                            
                                elseif empty(a:cmd)
                                    return s:F.msg('No last command.')
                            
                                else
                                    let cmd = a:cmd
                                endif
                            
                                "-----------------------------------------------------------------------
                            
                                " defaults: commands are recursive, count=1, vim registers untouched
                                let args = {
                                            \'recursive': 1, 'count': 1, 'vimreg': 0, 'gcount': 0,
                                            \'silent': get(g:, 'VM_silent_ex_commands', 0)
                                            \}
                            
                                if a:0 | call extend(args, a:1) | endif
                            
                                " if it's a VM internal operation, never use recursive mappings
                                if has_key(args, 'store') && args.store == '§'
                                    let args.recursive = 0
                                endif
                            
                                let n = args.count > 1 ? args.count : ''
                                let c = args.recursive ? ("normal ".n.cmd) : ("normal! ".n.cmd)
                                let c = args.silent    ? ("silent! ".c) : c
                            
                                call s:G.cursor_mode()
                                call self.before_commands()
                                let errors = ''
                            
                                try
                                    if a:cmd ==? 'x'   | call s:bs_del(n . a:cmd)
                                    elseif args.gcount | call self.process(a:cmd, args)
                                    else               | call self.process(c, args)
                                    endif
                                catch
                                    let errors = v:errmsg
                                endtry
                            
                                let g:Vm.last_normal = [cmd, args.recursive]
                                let s:v.dot = [cmd, args.recursive]
                                let s:v.merge = 1
                                call self.after_commands(0)
                            
                                if !empty(errors)
                                    call s:F.msg('[visual-multi] errors while executing '.c)
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.run_visual(cmd, recursive, ...) abort
                                " Run visual command over selections.
                                "-----------------------------------------------------------------------
                            
                                if !s:X()
                                    return s:F.msg('Not possible in cursor mode.')
                            
                                elseif !a:0 && a:cmd == -1
                                    call s:F.special_statusline('VISUAL')
                                    let bang = !a:recursive ? '!' : ''
                                    let cmd = input(':visual'.bang.' ')
                                    unlet s:v.statusline_mode
                                    if empty(cmd) | return s:F.msg('Visual command aborted.') | endif
                            
                                elseif empty(a:cmd)
                                    return s:F.msg('Command not found.')
                            
                                elseif !a:0
                                    let cmd = a:cmd
                                endif
                            
                                "-----------------------------------------------------------------------
                            
                                call self.before_commands()
                                let errors = ''
                            
                                try
                                    call self.process_visual(cmd, a:recursive)
                                catch
                                    let errors = v:errmsg
                                endtry
                            
                                let g:Vm.last_visual = [cmd, a:recursive]
                                call self.after_commands(0)
                                if !s:visual_reselect(cmd) | call s:G.change_mode() | endif
                            
                                if !empty(errors)
                                    call s:F.msg('[visual-multi] errors while executing '.cmd)
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.run_ex(...) abort
                                " Run Ex command over regions.
                                "-----------------------------------------------------------------------
                            
                                if !empty(a:1)
                                    let cmd = a:1
                                else
                                    return s:F.msg('Invalid command')
                                endif
                            
                                "-----------------------------------------------------------------------
                            
                                if has_key(g:VM_commands_aliases, cmd)
                                    let cmd = g:VM_commands_aliases[cmd]
                                endif
                            
                                let g:Vm.last_ex = cmd
                                call s:G.cursor_mode()
                                let errors = ''
                            
                                call self.before_commands()
                            
                                try
                                    call self.process(cmd)
                                catch
                                    let errors = v:errmsg
                                endtry
                            
                                let s:v.merge = 1
                                call self.after_commands(0)
                            
                                if !empty(errors)
                                    call s:F.msg('[visual-multi] errors while executing '.cmd)
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Edit.ex_done() abort
                                " Remove command mode mappings.
                                silent! cunmap <buffer> <cr>
                                silent! cunmap <buffer> <esc><esc>
                                silent! cunmap <buffer> <esc>
                                call histdel(':', -1)
                                unlet s:v.statusline_mode
                                if empty(@") | return s:F.msg('Ex command aborted.') | endif
                                call s:V.Edit.run_ex(@")
                            endfun
                            
                            
    1              0.000001 fun! s:Edit.ex_get() abort
                                " Get command line as entered by user.
                                let @" = getcmdline()
                                if !empty(@") | call histadd(':', @") | endif
                                return ''
                            endfun
                            
                            
    1              0.000001 fun! s:Edit.ex() abort
                                " Set command mode mappings.
                                cnoremap <silent><nowait><buffer> <cr>  <c-r>=b:VM_Selection.Edit.ex_get()<cr><c-u>call b:VM_Selection.Edit.ex_done()<cr>
                                cnoremap <silent><nowait><buffer> <esc><esc> <c-u>let @" = ''<cr>:call b:VM_Selection.Edit.ex_done()<cr>
                                cnoremap <silent><nowait><buffer> <esc> <c-u>let @" = ''<cr>:call b:VM_Selection.Edit.ex_done()<cr>
                                call s:F.special_statusline('EX')
                                return ':'
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Macros
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Edit.run_macro() abort
                                " Run macro over regions. Change to cursor mode if necessary.
                                call s:F.msg('Register? ')
                                let reg = nr2char(getchar())
                                if reg == "\<esc>"
                                    return s:F.msg('Macro aborted.')
                                endif
                            
                                call self.before_commands()
                                call s:G.cursor_mode()
                            
                                call self.process('normal! @'.reg)
                                let s:v.merge = 1
                                call self.after_commands(0)
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Dot
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Edit.dot() abort
                                " Run dot command over regions.
                                let dot = s:v.dot
                                if !s:X() && !empty(dot)
                                    if type(dot) == v:t_list                    " a VM normal command
                                        call self.run_normal(dot[0], {'recursive': dot[1]})
                                    elseif dot[0] ==? 'c' && dot[1] !=? 's'     "repeat last change operator
                                        call vm#operators#select(1, dot[1:])
                                        normal ".p
                                        call s:G.cursor_mode()
                                    else
                                        call self.run_normal(dot)
                                    endif
                                else
                                    call self.run_normal('.', {'count': v:count1, 'recursive': 0})
                                endif
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Region processing
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.process(cmd, ...) abort
                                " Execute command at cursors.
                                let s:v.eco = 1             " turn on eco mode
                                let change  = 0             " each cursor will update this value
                                let txt     = []            " if text is deleted, it will be stored here
                                let size    = s:F.size()    " initial buffer size
                            
                                if empty(s:v.storepos) | let s:v.storepos = getpos('.')[1:2] | endif
                            
                                let backup_txt      = a:0 && has_key(a:1, 'store')      " deleting regions, store their text
                                let write_reg       = backup_txt && a:1.store != '_'    " also write vim register unless _
                                let stay_put        = a:0 && has_key(a:1, 'stay_put')   " don't move the cursors after command
                                let do_cursor_moved = !exists("##TextYankPost")         " we want CursorMoved, even if cursor doesn't move
                            
                                " used by g<C-A>, g<C-X>
                                let gcount = a:0 && get(a:1, 'gcount', 0) ? a:1.count ? a:1.count : 1 : 0
                            
                                " if we are planning to store regions text, it's because commands can delete them
                                " but not all commands will alter vim registers, even if text changes
                                "
                                " then there's a bug: if user has mappings that redirect to _ register,
                                " they will be falsely interpreted as using " register
                                " if we just assume that " register contains deleted text and we store it,
                                " we'd concatenate instead the old unchanged register, that will become
                                " exponentially bigger in the process, because we write it back too
                                "
                                " so what we do is:
                                "
                                " - store the old " register
                                " - clear it
                                " - if commands change the register
                                "       regions text must be stored
                                "       the old " register will not be restored
                                " - if after command " register is still empty
                                "       don't store anything
                                "       the old " register will be restored
                            
                                if backup_txt
                                    let oldreg = [@", getregtype('"')]
                                    let @" = ''
                                endif
                                let must_restore_register = v:false
                            
                                call s:G.backup_regions()
                            
                                for r in s:R()
                                    " used in non-live edit, currently disabled
                                    if !s:v.auto && r.index == self.skip_index | continue | endif
                            
                                    " update cursor position on the base of previous text changes
                                    call r.shift(change, change)
                            
                                    " execute command at cursor
                                    call cursor(r.l, r.a)
                            
                                    if gcount
                                        let tick = b:changedtick
                                        exe 'normal! ' . gcount . a:cmd
                                        if b:changedtick > tick
                                            let gcount += a:1.count
                                        endif
                                    else
                                        exe a:cmd
                                    endif
                            
                                    " store deleted text during deletions/changes at cursors
                                    if backup_txt
                                        if @" == ''
                                            let backup_txt = v:false
                                            let write_reg = v:false
                                            let must_restore_register = v:true
                                        else
                                            call add(txt, getreg(s:v.def_reg))
                                        endif
                                    endif
                            
                                    " update new cursor position after the command, unless specified
                                    let diff = s:F.curs2byte() - r.A
                                    if !stay_put
                                        call r.shift(diff, diff)
                                    endif
                            
                                    " update changed size
                                    let change = s:F.size() - size
                            
                                    " let's force CursorMoved in case some yank command needs it
                                    if !diff && do_cursor_moved
                                        silent! doautocmd <nomodeline> CursorMoved
                                    endif
                                endfor
                            
                                if must_restore_register
                                    call setreg('"', oldreg[0], oldreg[1])
                            
                                elseif write_reg
                                    " fill VM register after deletions/changes at cursors
                                    " overwrite vim register if requested
                                    call self.fill_register(a:1.store, txt, a:1.vimreg)
                                endif
                            
                                " the original regions text could used by commands
                                if backup_txt
                                    let s:v.changed_text = txt
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Edit.process_visual(cmd, recursive) abort
                                " Process a 'visual' command over selections.
                                let s:v.eco = 1             " turn on eco mode
                                let change  = 0             " each cursor will update this value
                                let size    = s:F.size()    " initial buffer size
                                let s:v.storepos = getpos('.')[1:2]
                            
                                let cmd = a:recursive ? 'normal '.a:cmd : 'normal! '.a:cmd
                            
                                call s:G.backup_regions()
                            
                                for r in s:R()
                                    call r.shift(change, change)
                                    call cursor(r.L, r.b) | normal! m`
                                    call cursor(r.l, r.a) | normal! v``
                                    exe cmd
                            
                                    "update changed size
                                    let change = s:F.size() - size
                                endfor
                            endfun
                            
                            
    1              0.000002 fun! s:Edit.post_process(reselect, ...) abort
                                " Operations to be performed after the command has been executed.
                                if a:reselect
                                    call s:G.extend_mode()
                                    for r in s:R()
                                        call r.shift(a:1, a:1 + s:v.W[r.index])
                                    endfor
                                endif
                            
                                "remove extra spaces that may have been added
                                call self.extra_spaces.remove()
                            
                                "update, restore position and clear vars
                                let pos = empty(s:v.storepos)? '.' : s:v.storepos
                                call s:G.update_and_select_region(pos) | let s:v.storepos = []
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Extra spaces
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 let s:Edit.extra_spaces = {}
                            
    1              0.000002 fun! s:Edit.extra_spaces.remove(...) abort
                                " Extra spaces at EOL may have been added and must be removed.
                                " remove the extra space only if it comes after r.b, and it's just before \n
                                for i in s:v.extra_spaces
                                    "some region has been removed for some reason(merge, ...)
                                    if i >= len(s:R()) | break | endif
                            
                                    let l = s:R()[i].L + (a:0? a:1 : 0)
                                    let Line = getline(l)
                                    if Line[-1:-1] ==# ' '
                                        call setline(l, Line[:-2])
                                    endif
                                endfor
                                let s:v.extra_spaces = []
                            endfun
                            
                            
    1              0.000002 fun! s:Edit.extra_spaces.add(r, ...) abort
                                " It may be necessary to add spaces over empty lines, or if at EOL.
                                " add space if empty line(>) or eol(=)
                                " optional arg is when called in insert mode (cursors are different)
                                let [end, line] = a:0? [a:r._a, a:r.l] : [a:r.b, a:r.L]
                                let L = getline(line)
                                " use strwidth because multibyte chars cause problems at EOL
                                " this will result in more extra spaces than necessary but no big deal
                                if end >= strwidth(L)
                                    call setline(line, L.' ')
                                    call add(s:v.extra_spaces, a:r.index)
                                endif
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Before/after processing
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.before_commands() abort
                                " Disable mappings and run user autocommand before running commands.
                                let s:v.auto = 1 | let s:v.eco = 1
                            
                                let s:old_multiline = s:v.multiline
                                let s:v.multiline = s:can_multiline
                                let s:can_multiline = 0
                            
                                silent doautocmd <nomodeline> User visual_multi_before_cmd
                                call s:V.Maps.disable(0)
                                call s:V.Maps.unmap_esc_and_toggle()
                            endfun
                            
                            
    1              0.000002 fun! s:Edit.after_commands(reselect, ...) abort
                                " Trigger post processing and reenable mappings.
                                let s:v.multiline = s:old_multiline
                                if a:reselect
                                    call s:V.Edit.post_process(1, a:1)
                                else
                                    call s:V.Edit.post_process(0)
                                endif
                            
                                call s:V.Maps.enable()
                                call s:V.Maps.map_esc_and_toggle()
                                silent doautocmd <nomodeline> User visual_multi_after_cmd
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Helpers
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:bs_del(cmd) abort
                                " Special handler for x/X normal commands, and <BS>/<Del> insert commands.
                                if s:v.insert
                                    return vm#icmds#x(a:cmd)
                                else
                                    call s:V.Edit.process('normal! '.a:cmd)
                                endif
                            
                                if a:cmd ==# 'x'
                                    for r in s:R()
                                        if r.a == col([r.L, '$'])
                                            call r.shift(-1,-1)
                                        endif
                                    endfor
                                endif
                            
                                call s:G.merge_regions()
                            endfun
                            
                            
    1              0.000002 fun! s:visual_reselect(cmd) abort
                                " Ensure selections are reselected after some commands.
                                let reselect = a:cmd == '~' || a:cmd =~? 'u'
                                return s:X() && reselect
                            endfun
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=indent fdn=1

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/icmds.vim
Sourced 1 time
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
                            "script to handle several insert mode commands
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 fun! vm#icmds#init() abort
                                let s:V = b:VM_Selection
                                let s:v = s:V.Vars
                                let s:G = s:V.Global
                                let s:F = s:V.Funcs
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000008 let s:R = { -> s:V.Regions }
    1              0.000013 let s:X = { -> g:Vm.extend_mode }
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#icmds#x(cmd) abort
                                let size = s:F.size()
                                let change = 0 | let s:v.eco = 1
                                if empty(s:v.storepos) | let s:v.storepos = getpos('.')[1:2] | endif
                                let active = s:R()[s:V.Insert.index]
                            
                                for r in s:R()
                                    if s:v.single_region && r isnot active
                                        if r.l == active.l
                                            call r.shift(change, change)
                                        endif
                                        continue
                                    endif
                            
                                    call r.shift(change, change)
                                    call s:F.Cursor(r.A)
                            
                                    " we want to emulate the behaviour that <del> and <bs> have in insert
                                    " mode, but implemented as normal mode commands
                            
                                    if s:V.Insert.replace
                                        " in replace mode, we don't allow line joining
                                        if a:cmd ==# 'X' && r.a > 1
                                            let original = s:V.Insert._lines[r.l] " the original line
                                            if strpart(getline(r.l), r.a) =~ '\s*$' " at EOL
                                                call search('\s*$', '', r.l)
                                            endif
                                            "FIXME this part is bugged with multibyte chars
                                            call r.shift(-1,-1)
                                            if r.a > 1
                                                let t1 = strpart(getline('.'), 0, r.a - 1)
                                                let wd = strwidth(t1)
                                                let tc = strcharpart(original, wd, 1)
                                                let t2 = strcharpart(original, wd + 1)
                                                call setline(r.l, t1 . tc . t2)
                                            else
                                                let pre = ''
                                                let post = original
                                                call setline(r.l, pre . post)
                                            endif
                                        endif
                                    elseif a:cmd ==# 'x' && s:eol(r)    "at eol, join lines
                                        keepjumps normal! gJ
                                    elseif a:cmd ==# 'x'                "normal delete
                                        keepjumps normal! x
                                    elseif a:cmd ==# 'X' && r.a == 1    "at bol, go up and join lines
                                        keepjumps normal! kgJ
                                        call r.shift(-1,-1)
                                    else                                "normal backspace
                                        keepjumps normal! X
                                        let w = strlen(@-)
                                        call r.shift(-w, -w)
                                    endif
                            
                                    "update changed size
                                    let change = s:F.size() - size
                                endfor
                            
                                call s:G.merge_regions()
                                call s:G.select_region(s:V.Insert.index)
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#icmds#cw(ctrlu) abort
                                let size = s:F.size()
                                let change = 0 | let s:v.eco = 1
                                let s:v.storepos = getpos('.')[1:2]
                                let keep_line = get(g:, 'VM_icw_keeps_line', 1)
                            
                                for r in s:R()
                                    call r.shift(change, change)
                            
                                    "TODO: deletion to line above can be bugged for now
                                    if keep_line && r.a == 1 | continue | endif
                            
                                    call s:F.Cursor(r.A)
                            
                                    if r.a > 1 && s:eol(r) "add extra space and move right
                                        call s:V.Edit.extra_spaces.add(r)
                                        call r.move('l')
                                    endif
                            
                                    let L = getline(r.l)
                                    let ws_only = r.a > 1 && match(L[:(r.a-2)], '[^ \t]') < 0
                            
                                    if a:ctrlu          "ctrl-u
                                        keepjumps normal! d^
                                    elseif r.a == 1     "at bol, go up and join lines
                                        keepjumps normal! kgJ
                                    elseif ws_only      "whitespace only before, delete it
                                        keepjumps normal! d0
                                    else                "normal deletion
                                        keepjumps normal! db
                                    endif
                                    call r.update_cursor_pos()
                            
                                    "update changed size
                                    let change = s:F.size() - size
                                endfor
                                call s:V.Insert.start(1)
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! vm#icmds#paste() abort
                                call s:G.select_region(-1)
                                call s:V.Edit.paste(1, 0, 1, '"')
                                call s:G.select_region(s:V.Insert.index)
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! vm#icmds#return() abort
                                "invert regions order, so that they are processed from bottom to top
                                let s:V.Regions = reverse(s:R())
                            
                                for r in s:R()
                                    call cursor(r.l, r.a)
                                    let rline = getline('.')
                            
                                    "we also consider at EOL cursors that have trailing spaces after them
                                    "if not at EOL, CR will cut the line and carry over the remaining text
                                    let at_eol = match(strpart(rline, r.a-1, len(rline)), '\s*$') == 0
                            
                                    "if carrying over some text, delete it now, for better indentexpr
                                    "otherwise delete the trailing spaces that would be left at EOL
                                    if !at_eol  | keepjumps normal! d$
                                    else        | keepjumps normal! "_d$
                                    endif
                            
                                    "append a line and get the indent
                                    noautocmd exe "silent keepjumps normal! o\<C-R>=<SID>get_indent()\<CR>"
                            
                                    "fill the line with tabs or spaces, according to the found indent
                                    "an extra space must be added, if not carrying over any text
                                    "also keep the indent whitespace only, removing any non-space character
                                    "such as comments, and everything after them
                                    let extra_space = at_eol ? ' ' : ''
                                    let indent = substitute(g:Vm.indent, '\S\+.*', '', 'g')
                                    call setline('.', indent . extra_space)
                            
                                    "if carrying over some text, paste it after the indent
                                    "but strip preceding whitespace found in the text
                                    if !at_eol
                                        let @" = substitute(@", '^\s*', '', '')
                                        keepjumps normal! $p
                                    endif
                            
                                    "cursor line will be moved down by the next cursors
                                    call r.update_cursor([line('.') + r.index, len(indent) + 1])
                                endfor
                            
                                "reorder regions
                                let s:V.Regions = reverse(s:R())
                            
                                "ensure cursors are at indent level
                                keepjumps normal ^
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#icmds#insert_line(above) abort
                                "invert regions order, so that they are processed from bottom to top
                                let s:V.Regions = reverse(s:R())
                            
                                for r in s:R()
                                    "append a line below or above
                                    call cursor(r.l, r.a)
                                    noautocmd exe "silent keepjumps normal!" (a:above ? 'O' : 'o')."\<C-R>=<SID>get_indent()\<CR>"
                            
                                    "remove comment or other chars, fill the line with tabs or spaces
                                    let indent = substitute(g:Vm.indent, '[^ \t].*', '', 'g')
                                    call setline('.', indent . ' ')
                            
                                    "cursor line will be moved down by the next cursors
                                    call r.update_cursor([line('.') + r.index, len(indent) + 1])
                                    call add(s:v.extra_spaces, r.index)
                                endfor
                            
                                "reorder regions
                                let s:V.Regions = reverse(s:R())
                            
                                "ensure cursors are at indent level
                                keepjumps normal ^
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#icmds#goto(next) abort
                              """Used in single region mode.
                              let s:v.single_mode_running = 1
                              let t = ":call b:VM_Selection.Insert.key('".s:V.Insert.type."')\<cr>"
                              if a:next
                                  return "\<Esc>:call vm#commands#find_next(0,1)\<cr>".t
                              else
                                  return "\<Esc>:call vm#commands#find_prev(0,1)\<cr>".t
                              endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:get_indent() abort
                                let g:Vm.indent = getline('.')
                                return ''
                            endfun
                            
    1              0.000002 fun! s:eol(r)
                                return a:r.a == (col([a:r.l, '$']) - 1)
                            endfun
                            " vim: et ts=4 sw=4 sts=4 :

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/ecmds1.vim
Sourced 1 time
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Edit commands #1 (yank, delete, paste, replace)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 let s:Edit = {}
    1              0.000002 let s:old_text = []
                            
    1              0.000002 fun! vm#ecmds1#init() abort
                                let s:V       = b:VM_Selection
                                let s:v       = s:V.Vars
                                let s:G       = s:V.Global
                                let s:F       = s:V.Funcs
                            
                                return extend(s:Edit, vm#ecmds2#init())
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000006 let s:R   = { -> s:V.Regions }
    1              0.000004 let s:X   = { -> g:Vm.extend_mode }
    1              0.000007 let s:min = { n -> s:X() && len(s:R()) >= n }
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Yank
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000003 fun! s:Edit.yank(reg, silent, ...) abort
                                " Yank the regions contents in a VM register. {{{1
                                let register = (s:v.use_register != s:v.def_reg) ? s:v.use_register : a:reg
                            
                                if !s:X()    | return vm#cursors#operation('y', v:count, register) | endif
                                if !s:min(1) | return s:F.msg('No regions selected.')              | endif
                            
                                "write custom and possibly vim registers.
                                let [text, type] = self.fill_register(register, s:G.regions_text(), 0)
                            
                                "restore default register if a different register was provided
                                if register !=# s:v.def_reg | call s:F.restore_reg() | endif
                            
                                "reset temp register
                                let s:v.use_register = s:v.def_reg
                            
                                if !a:silent
                                    call s:F.msg('Yanked the content of '.len(s:R()).' regions.')
                                endif
                                if a:0 | call s:G.change_mode() | endif
                            endfun " }}}
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Delete
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Edit.delete(X, register, count, manual) abort
                                " Delete the selected text and change to cursor mode.
                                " Return the deleted text.
                                " {{{1
                                if s:F.no_regions() | return | endif
                                if !s:v.direction | call vm#commands#invert_direction() | endif
                            
                                if !a:X     "ask for motion
                                    return vm#cursors#operation('d', a:count, a:register)
                                endif
                            
                                let winline      = winline()
                                let size         = s:F.size()
                                let change       = 0
                                let ix           = s:G.select_region_at_pos('.').index
                                let s:old_text   = s:G.regions_text()
                                let retVal       = copy(s:old_text)
                                let s:v.deleting = 1
                            
                                " manual deletion: backup current regions
                                if a:manual | call s:G.backup_regions() | endif
                            
                                for r in s:R()
                                    call r.shift(change, change)
                                    call self.extra_spaces.add(r)
                                    call cursor(r.l, r.a)
                                    if r.w == 1
                                      normal! "_dl
                                    else
                                      normal! m[
                                      call cursor(r.L, r.b>1? r.b+1 : 1)
                                      normal! m]`["_d`]
                                    endif
                            
                                    "update changed size
                                    let change = s:F.size() - size
                                endfor
                            
                                "write custom and possibly vim registers.
                                call self.fill_register(a:register, s:old_text, a:manual)
                            
                                call s:G.change_mode()
                                call s:G.select_region(ix)
                            
                                if a:manual
                                    call self.extra_spaces.remove()
                                    call s:G.update_and_select_region()
                                endif
                                if a:register == "_" | call s:F.restore_reg() | endif
                                call s:F.Scroll.force(winline)
                                let s:old_text = []
                                return retVal
                            endfun " }}}
                            
                            
    1              0.000002 fun! s:Edit.xdelete(key, cnt) abort
                                " Delete with 'x' or 'X' key, use black hole register in extend mode {{{1
                                if s:X()
                                    call self.delete(1, '_', a:cnt, 1)
                                else
                                    call self.run_normal(a:key, {'count': a:cnt, 'recursive': 0})
                                endif
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Paste
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000003 fun! s:Edit.paste(before, vim_reg, reselect, register, ...) abort
                                " Perform a paste of the appropriate type. {{{1
                                " @param before: 'P' or 'p' behaviour
                                " @param vim_reg: if forcing regular vim registers
                                " @param reselect: trigger reselection if run from extend mode
                                " @param register: the register being used
                                " @param ...: optional list with replacement text for regions
                                let X                = s:X()
                                let s:v.use_register = a:register
                                let vim_reg          = a:vim_reg || !has_key(g:Vm.registers, a:register) ||
                                            \          empty(g:Vm.registers[a:register])
                                let vim_V            = vim_reg && getregtype(a:register) ==# 'V'
                            
                                if empty(s:old_text) | let s:old_text = s:G.regions_text() | endif
                            
                                if vim_V
                                    return self.run_normal('"' . a:register . 'p', {'recursive': 0})
                            
                                elseif a:0     | let s:v.new_text = a:1
                                elseif vim_reg | let s:v.new_text = self.convert_vimreg(a:vim_reg)
                                else           | let s:v.new_text = s:fix_regions_text(g:Vm.registers[a:register])
                                endif
                            
                                call s:G.backup_regions()
                            
                                if X | call self.delete(1, "_", 1, 0) | endif
                            
                                call self.block_paste(a:before)
                            
                                let s:v.W = self.store_widths(s:v.new_text)
                                call self.post_process((X? 1 : a:reselect), !a:before)
                                let s:old_text = []
                            endfun " }}}
                            
                            
    1              0.000002 fun! s:Edit.block_paste(before) abort
                                " Paste the new text (list-type) at cursors. {{{1
                                let size = s:F.size()
                                let text = copy(s:v.new_text)
                                let change = 0
                                let s:v.eco = 1
                            
                                for r in s:R()
                                    if !empty(text)
                                        call r.shift(change, change)
                                        call cursor(r.l, r.a)
                                        let s = remove(text, 0)
                                        call s:F.set_reg(s)
                            
                                        if a:before
                                            normal! P
                                        else
                                            normal! p
                                            if !exists('s:v.dont_move_cursors')
                                                call r.update_cursor_pos()
                                            endif
                                        endif
                            
                                        "update changed size
                                        let change = s:F.size() - size
                                    else
                                        break
                                    endif
                                endfor
                                silent! unlet s:v.dont_move_cursors
                                call s:F.restore_reg()
                            endfun " }}}
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Replace
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Edit.replace_chars() abort
                                " Replace single characters or selections with character. {{{1
                                if s:X()
                                    let char = nr2char(getchar())
                                    if char ==? "\<esc>" | return | endif
                            
                                    if s:v.multiline
                                        call s:F.toggle_option('multiline')
                                        call s:G.remove_empty_lines()
                                    endif
                            
                                    let s:v.W = self.store_widths() | let s:v.new_text = []
                            
                                    for i in range(len(s:v.W))
                                        let r = ''
                                        while len(r) < s:v.W[i] | let r .= char | endwhile
                                        let s:v.W[i] -= 1
                                        call add(s:v.new_text, r)
                                    endfor
                            
                                    call self.delete(1, "_", 1, 0)
                                    call self.block_paste(1)
                                    call self.post_process(1, 0)
                                else
                                    call s:F.msg('Replace char... ')
                                    let char = nr2char(getchar())
                                    if char ==? "\<esc>" | return s:F.msg('Canceled.') | endif
                                    call self.run_normal('r'.char, {'recursive': 0, 'stay_put': 1})
                                endif
                            endfun " }}}
                            
                            
    1              0.000001 fun! s:Edit.replace() abort
                                " Replace a pattern in all regions, or start replace mode. {{{1
                                if !s:X()
                                    let s:V.Insert.replace = 1
                                    return s:V.Insert.key('i')
                                endif
                            
                                let ix = s:v.index
                                call s:F.Scroll.get()
                            
                                echohl Type
                                let pat = input('Pattern to replace > ')
                                if empty(pat)
                                    return s:F.msg('Command aborted.')
                                endif
                                let repl = input('Replacement > ')
                                if empty(repl)
                                    call s:F.msg('Hit Enter for an empty replacement... ')
                                    if getchar() != 13
                                        return s:F.msg('Command aborted.')
                                    endif
                                endif
                                echohl None
                            
                                let text = s:G.regions_text()
                                let T = []
                                for t in text
                                    call add(T, substitute(t, '\C' . pat, repl, 'g'))
                                endfor
                                call self.replace_regions_with_text(T)
                                call s:G.select_region(ix)
                            endfun " }}}
                            
                            
    1              0.000002 fun! s:Edit.replace_expression() abort
                                " Replace all regions with the result of an expression. {{{1
                                if !s:X() | return | endif
                                let ix = s:v.index | call s:F.Scroll.get()
                            
                                echohl Type    | let expr = input('Expression > ', '', 'expression') | echohl None
                                if empty(expr) | return s:F.msg('Command aborted.') | endif
                            
                                let T = [] | let expr = s:F.get_expr(expr)
                                for r in s:R()
                                    call add(T, eval(expr))
                                endfor
                                call map(T, 'type(v:val) != v:t_string ? string(v:val) : v:val')
                                call self.replace_regions_with_text(T)
                                call s:G.select_region(ix)
                            endfun " }}}
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Helper functions
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:fix_regions_text(replacement) abort
                                " Ensure there are enough elements for all regions. {{{1
                                let L = a:replacement
                                let i = len(s:R()) - len(L)
                            
                                while i>0
                                    call add(L, empty(s:old_text)? '' : s:old_text[-i])
                                    let i -= 1
                                endwhile
                                return L
                            endfun " }}}
                            
                            
    1              0.000002 fun! s:Edit.convert_vimreg(as_block) abort
                                " Fill the content to paste with the chosen vim register. {{{1
                                let text = []
                                let block = char2nr(getregtype(s:v.use_register)[0]) == 22
                            
                                if block
                                    "default register is of block type, assign a line to each region
                                    let width   = getregtype(s:v.use_register)[1:]
                                    let content = split(getreg(s:v.use_register), "\n")
                            
                                    "ensure all regions have the same width, fill the rest with spaces
                                    if a:as_block
                                        for t in range(len(content))
                                            while len(content[t]) < width | let content[t] .= ' ' | endwhile
                                        endfor
                                    endif
                            
                                    call s:fix_regions_text(content)
                            
                                    for n in range(len(s:R()))
                                        call add(text, content[n])
                                    endfor
                                else
                                    for n in range(len(s:R())) | call add(text, getreg(s:v.use_register)) | endfor
                                endif
                                return text
                            endfun " }}}
                            
                            
    1              0.000002 fun! s:Edit.store_widths(...) abort
                                " Build a list that holds the widths(integers) of each region {{{1
                                " It will be used for various purposes (reselection, paste as block...)
                            
                                let W = [] | let x = s:X()
                                let use_text = 0
                                let use_list = 0
                            
                                if a:0
                                    if type(a:1) == type("") | let text = len(a:1)-1 | let use_text = 1
                                    else                     | let list = a:1        | let use_list = 1
                                    endif
                                endif
                            
                                "mismatching blocks must be corrected
                                if use_list | call s:fix_regions_text(list) | endif
                            
                                for r in s:R()
                                    "if using list, w must be len[i]-1, but always >= 0, set it to 0 if empty
                                    if use_list | let w = len(list[r.index]) | endif
                                    call add( W, use_text? text : use_list? (w? w-1 : 0) : r.w )
                                endfor
                                return W
                            endfun " }}}
                            
                            
    1              0.000002 fun! s:Edit.fill_register(reg, text, force_ow) abort
                                " Write custom and possibly vim registers. {{{1
                            
                                "if doing a change/deletion, write the VM - register
                                if s:v.deleting
                                    let g:Vm.registers['-'] = a:text
                                    let s:v.deleting = 0
                                endif
                            
                                if a:reg == "_" | return | endif
                            
                                let text      = a:text
                                let reg       = empty(a:reg) ? '"' : a:reg
                                let temp_reg  = reg == '§'
                                let overwrite = reg ==# s:v.def_reg || reg == '+' || ( a:force_ow && !temp_reg )
                                let maxw      = max(map(copy(text), 'len(v:val)'))
                                let type      = s:v.multiline? 'V' : ( len(s:R())>1? 'b'.maxw : 'v' )
                            
                                " set VM register, overwrite backup register unless temporary
                                if !temp_reg
                                    let g:Vm.registers[s:v.def_reg] = text
                                    let s:v.oldreg = [s:v.def_reg, join(text, "\n"), type]
                                endif
                                " don't store the system register
                                if reg != '+'
                                    let g:Vm.registers[reg] = text
                                endif
                            
                                "vim register is overwritten if unnamed, or if forced
                                if overwrite
                                    call setreg(reg, join(text, "\n"), type)
                                endif
                            
                                return [text, type]
                            endfun " }}}
                            
                            
    1              0.000002 fun! s:Edit.replace_regions_with_text(text, ...) abort
                                " Paste a custom list of strings into current regions. {{{1
                                call self.fill_register('"', a:text, 0)
                                let before = !a:0 || !a:1
                                call self.paste(before, 0, s:X(), '"')
                            endfun " }}}
                            
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=marker

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/ecmds2.vim
Sourced 1 time
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Edit commands #2 (special commands)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000007 let s:Edit = {}
                            
    1              0.000003 fun! vm#ecmds2#init() abort
                                let s:V       = b:VM_Selection
                                let s:v       = s:V.Vars
                                let s:G       = s:V.Global
                                let s:F       = s:V.Funcs
                                return s:Edit
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000007 let s:R = { -> s:V.Regions }
    1              0.000004 let s:X = { -> g:Vm.extend_mode }
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Duplicate
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.duplicate() abort
                                if !s:min(1) | return | endif
                            
                                call self.yank('§', 1)
                                call s:G.change_mode()
                                call self.paste(1, 0, 1, '§')
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Change
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! s:Edit.change(X, count, reg, smart_case) abort
                                if !len(s:R()) | return | endif
                                if !s:v.direction | call vm#commands#invert_direction() | endif
                                if a:smart_case && !exists('s:v.smart_case_change')
                                    let s:v.smart_case_change = 1
                                endif
                                if a:X
                                    "delete existing region contents and leave the cursors
                                    let reg = a:reg != s:v.def_reg? a:reg : "_"
                                    let s:v.changed_text = self.delete(1, reg, 1, 0)
                                    call s:V.Insert.key('i')
                                else
                                    call vm#cursors#operation('c', a:count, a:reg)
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Non-live edit mode
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.apply_change() abort
                                call s:V.Insert.auto_end()
                                let self.skip_index = s:v.index
                                call self.process('normal! .')
                                "reset index to skip
                                let self.skip_index = -1
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Special commands
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Edit.surround() abort
                                if !len(s:R()) | return | endif
                                if !s:X() | call vm#operators#select(1, 'iw') | endif
                            
                                if !s:v.direction | call vm#commands#invert_direction() | endif
                                let s:v.W = self.store_widths()
                                let reselect = 1
                            
                                let c = nr2char(getchar())
                            
                                if c == '<' || c ==# 't'
                                    let reselect = 0
                                    let c = self.surround_tags()
                                    if c == ''
                                        redraw
                                        echo
                                        return
                                    endif
                                endif
                            
                                nunmap <buffer> S
                            
                                call self.run_visual('S'.c, 1)
                                if index(['[', '{', '('], c) >= 0
                                    call map(s:v.W, 'v:val + 3')
                                else
                                    call map(s:v.W, 'v:val + 1')
                                endif
                                if reselect
                                    call self.post_process(1, 0)
                                else
                                    call self.post_process(0)
                                endif
                            
                                nmap <silent> <nowait> <buffer> S <Plug>(VM-Surround)
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.surround_tags() abort
                                let c = '<'
                                echo c
                            
                                while v:true
                                    let ch = getchar()
                                    if ch == 27 "esc
                                        return ''
                                    endif
                                    if ch == "\<BS>"
                                        if strlen(c) > 1
                                            let c = c[:-2]
                                        else
                                            "no more chars
                                            return ''
                                        endif
                                    else
                                        let c .= nr2char(ch)
                                        if ch == 62 || ch == 13 "> or CR
                                            break
                                        endif
                                    endif
                                    redraw
                                    echo c
                                endwhile
                            
                                return c
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.rotate() abort
                                """Non-inline transposition.
                                if !s:min(2) | return | endif
                            
                                call self.yank('"', 1)
                            
                                let t = remove(g:Vm.registers[s:v.def_reg], 0)
                                call add(g:Vm.registers[s:v.def_reg], t)
                                call self.paste(1, 0, 1, '"')
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Edit.transpose() abort
                                if !s:min(2) | return | endif
                                let rlines = s:G.lines_with_regions(0)
                                let klines = sort(keys(rlines), 'n')
                            
                                "check if there is the same nr of regions in each line
                                let inline = len(klines) > 1
                                if inline
                                    let n = 0
                                    for l in klines
                                        let nr = len(rlines[l])
                            
                                        if     nr == 1 | let inline = 0 | break     "line with 1 region
                                        elseif !n      | let n = nr                 "set required n regions x line
                                        elseif nr != n | let inline = 0 | break     "different number of regions
                                        endif
                                    endfor
                                endif
                            
                                "non-inline transposition
                                if !inline
                                    return self.rotate()
                                endif
                            
                                call self.yank('"', 1)
                            
                                "inline transpositions
                                for l in klines
                                    let t = remove(g:Vm.registers[s:v.def_reg], rlines[l][-1])
                                    call insert(g:Vm.registers[s:v.def_reg], t, rlines[l][0])
                                endfor
                                call self.delete(1, "_", 0, 0)
                                call self.paste(1, 0, 1, '"')
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Edit.align() abort
                                if s:v.multiline
                                    return s:F.msg('Not possible, multiline is enabled.')
                                endif
                                call s:G.cursor_mode()
                            
                                call self.run_normal('D', {'store': '§'})
                                let max = max(map(copy(s:R()), 'virtcol([v:val.l, v:val.a])'))
                                let reg = g:Vm.registers['§']
                                for r in s:R()
                                    let spaces = ''
                                    let L = getline(r.l)
                                    if empty(L)
                                        while len(spaces) < max | let spaces .= ' ' | endwhile
                                        call setline(r.l, L[:r.a-1] . spaces . L[r.a:] . reg[r.index])
                                        call r.update_cursor([r.l, r.a + len(spaces) - 1])
                                    else
                                        while len(spaces) < (max - virtcol([r.l, r.a])) | let spaces .= ' ' | endwhile
                                        call setline(r.l, L[:r.a-1] . spaces . L[r.a:] . reg[r.index])
                                        call r.update_cursor([r.l, r.a + len(spaces)])
                                    endif
                                endfor
                                call s:G.update_and_select_region()
                                call vm#commands#motion('l', 1, 0, 0)
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit.shift(dir) abort
                                if !s:min(1) | return | endif
                            
                                call self.yank('"', 1)
                                if a:dir
                                    let s:v.dont_move_cursors = 1
                                    call self.paste(0, 0, 1, '"')
                                else
                                    call self.delete(1, "_", 0, 0)
                                    call vm#commands#motion('h', 1, 0, 0)
                                    call self.paste(1, 0, 1, '"')
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Insert numbers
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Edit._numbers(start, step, separator, append) abort
                                let start = str2nr(a:start)
                                let step = str2nr(a:step)
                            
                                "------------------------------------------------
                                " build string from expression
                            
                                let text = []
                                for n in range(len(s:R()))
                                  if a:append
                                      let t = a:separator . string(start + step * n)
                                  else
                                      let t = string(start + step * n) . a:separator
                                  endif
                                  call add(text, t)
                                endfor
                            
                                "------------------------------------------------
                                " paste string before/after the cursor/selection
                            
                                if s:X()
                                    let text = map(copy(s:R()), a:append
                                                \ ? '(v:val.txt).text[v:key]'
                                                \ : 'text[v:key].(v:val.txt)')
                                    call self.replace_regions_with_text(text)
                                else
                                    call self.replace_regions_with_text(text, a:append)
                                endif
                            endfun
                            
    1              0.000002 fun! s:Edit.numbers(start, app) abort
                                if !len(s:R()) | return | endif
                            
                                " fill the command line with [count]/default_step
                                let x = input('Expression > ', a:start . '/1/')
                            
                                if empty(x) | return s:F.msg('Canceled') | endif
                            
                                "first char must be a digit or a negative sign
                                if match(x, '^\d') < 0 && match(x, '^\-') < 0
                                    return s:F.msg('Invalid expression')
                                endif
                            
                                "evaluate terms of the expression
                                "/ is the separator, it must be escaped \/ to be used
                                let x = split(x, '/', 1)
                                let i = 0
                                while i < len(x)-1
                                    if x[i][-1:-1] == '\'
                                        let x[i] = x[i][:-2].'/'.remove(x, i+1)
                                    else
                                        let i += 1
                                    endif
                                endwhile
                                call filter(x, '!empty(v:val)')
                                let n = len(x)
                            
                                " true for a number, false for a separator
                                let l:Num = { x -> match(x, '^\d') >= 0 || match(x, '^\-\d') >= 0 }
                            
                                "------------------------------------------- start  step   separ.   append?
                                if     n == 1        | call self._numbers (  x[0],   1,     '',     a:app  )
                            
                                elseif n == 2
                            
                                    if l:Num(x[1])   | call self._numbers (  x[0],   x[1],  '',     a:app  )
                                    else             | call self._numbers (  x[0],   1,     x[1],   a:app  )
                                    endif
                            
                                elseif n == 3        | call self._numbers (  x[0],   x[1],  x[2],   a:app  )
                                endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:min(n) abort
                                return s:X() && len(s:R()) >= a:n
                            endfun
                            
                            " vim: et ts=4 sw=4 sts=4 :

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim
Sourced 1 time
Total time:   0.000395
 Self time:   0.000395

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Insert class
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000010 let s:Insert = {'index': -1, 'cursors': [], 'replace': 0, 'type': ''}
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#insert#init() abort
                                " Init script variables.
                                let s:V    = b:VM_Selection
                                let s:v    = s:V.Vars
                                let s:G    = s:V.Global
                                let s:F    = s:V.Funcs
                                let s:v.restart_insert = 0
                                return s:Insert
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000007 let s:R = { -> s:V.Regions }
    1              0.000004 let s:X = { -> g:Vm.extend_mode }
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Insert mode start
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! s:Insert.key(type) abort
                                " Starting insert mode with a key (i,I,a,A...), make adjustments if needed.
                                if empty(self.type)
                                    let self.type = a:type
                                endif
                            
                                if self.replace
                                    call s:G.one_region_per_line()
                                endif
                            
                                call vm#comp#icmds()        "compatibility tweaks
                                call s:map_single_mode(0)
                            
                                if a:type ==# 'I'
                                    call vm#commands#merge_to_beol(0)
                                    call self.key('i')
                            
                                elseif a:type ==# 'A'
                                    call vm#commands#merge_to_beol(1)
                                    call self.key('a')
                            
                                elseif a:type ==# 'o'
                                    call vm#commands#merge_to_beol(1)
                                    call vm#icmds#insert_line(0)
                                    call self.start(1)
                            
                                elseif a:type ==# 'O'
                                    call vm#commands#merge_to_beol(0)
                                    call vm#icmds#insert_line(1)
                                    call self.start(1)
                            
                                elseif a:type ==# 'a'
                                    if s:X()
                                        if s:v.direction | call vm#commands#invert_direction() | endif
                                        call s:G.change_mode()
                                        let s:v.direction = 1
                                    endif
                                    for r in s:R() | call s:V.Edit.extra_spaces.add(r) | endfor
                                    call vm#commands#motion('l', 1, 0, 0)
                                    call self.start(1)
                            
                                else
                                    if s:X()
                                        if !s:v.direction | call vm#commands#invert_direction() | endif
                                        call s:G.change_mode()
                                    endif
                            
                                    call self.start()
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Insert.start(...) abort
                                " Initialize and then start insert mode.
                                "--------------------------------------------------------------------------
                            
                                "Initialize Insert Mode dict. 'begin' is the initial ln/col, and will be
                                "used to track all changes from that point, to apply them on all cursors
                            
                                "--------------------------------------------------------------------------
                                call s:G.merge_cursors()
                            
                                let I = self
                                let I._index = get(I, '_index', -1)
                            
                                let R = I.apply_settings()
                            
                                let I.index     = R.index
                                let I.begin     = [R.l, R.a]
                                let I.cursors   = []
                                let I.lines     = {}
                                let I.change    = 0         " text change, only if g:VM_live_editing
                                let I.col       = col('.')
                                let I.reupdate  = v:false   " set by InsertCharPre and CompleteDone
                            
                                " remove current regions highlight
                                call s:G.remove_highlight()
                            
                                " create cursors and line objects
                                for r in s:R()
                                    let C = s:Cursor.new(r.l, r.a)
                                    call add(I.cursors, C)
                            
                                    " if cursor is at EOL/empty line, an extra space will be added
                                    " if starting with keys 'a/A', spaces have been added already
                                    if !a:0
                                        call s:V.Edit.extra_spaces.add(r)
                                    endif
                            
                                    if !has_key(I.lines, r.l)
                                        let I.lines[r.l] = s:Line.new(r.l, C)
                                        let nth = 0 | let C.nth = 0
                                    else
                                        if !s:v.single_region
                                            let nth += 1
                                        endif
                                        let C.nth = nth
                                        call add(I.lines[r.l].cursors, C)
                                    endif
                                    if C.index == I.index | let I.nth = C.nth | endif
                                endfor
                            
                                " create a backup of the original lines
                                if self.replace && !exists('I._lines')
                                    let I._lines = map(copy(I.lines), 'v:val.txt')
                                endif
                            
                                "start tracking text changes
                                let s:v.insert = 1 | call I.auto_start()
                            
                                "change/update cursor highlight
                                call s:G.update_cursor_highlight()
                            
                                "start insert mode
                                if self.replace
                                    startreplace
                                else
                                    startinsert
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Insert.apply_settings() abort
                                " Apply/disable settings related to insert mode. Return current region.
                            
                                " get winline and backup regions when insert mode is entered the first time
                                if !exists('s:v.winline_insert')
                                    let s:v.winline_insert = winline()
                                    call s:G.backup_regions()
                                endif
                            
                                " syn minlines/synmaxcol settings
                                if !s:v.insert
                                    if g:VM_disable_syntax_in_imode
                                        let &l:synmaxcol = 1
                                    elseif get(g:, 'VM_reduce_sync_minlines', 1) && len(b:VM_sync_minlines)
                                        if get(b:, 'VM_minlines', 0)
                                            exe 'syn sync minlines='.b:VM_minlines
                                        else
                                            syn sync minlines=1
                                        endif
                                    endif
                                endif
                            
                                if g:VM_use_first_cursor_in_line || self.replace
                                    let R = s:G.select_region_at_pos('.')
                                    let ix = s:G.lines_with_regions(0, R.l)[R.l][0]
                                    let R = s:G.select_region(ix)
                                elseif s:v.insert
                                    let i = self.index >= len(s:R())? len(s:R())-1 : self.index
                                    let R = s:G.select_region(i)
                                else
                                    let R = s:G.select_region_at_pos('.')
                                endif
                            
                                " restore winline anyway, because it could have been auto-restarted
                                call s:F.Scroll.force(s:v.winline_insert)
                                call s:F.Scroll.get(1)
                            
                                "disable indentkeys and other settings that may mess up the text
                                "keep o,O to detect indent for <CR>, though
                                setlocal indentkeys=o,O
                                setlocal cinkeys=o,O
                                setlocal textwidth=0
                                if !&expandtab
                                    setlocal softtabstop=0
                                endif
                                return R
                            endfun
                            
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Insert mode update
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Insert.update_text(insert_leave) abort
                                " Update the text on TextChangedI event, and just after InsertLeave.
                            
                                if s:F.not_VM() || !g:VM_live_editing && !a:insert_leave | return | endif
                            
                                call vm#comp#TextChangedI()  "compatibility tweaks
                            
                                let I = self
                                let L = I.lines
                            
                                " this is the current cursor position
                                let ln   = line('.')
                                let coln = col('.')
                            
                                " we're now evaluating the current (original) line
                                " we're only interested in column changes, since we insert text horizontally
                            
                                " I.begin is the starting column, when insert mode is entered
                                " I.change is the total length of the newly inserted text up to this moment
                                " I.nth refers to the n. of cursors in the same line: it's 0 if there is only
                                " a cursor, but if there are more cursors in the line, their changes add up
                                " In fact, even if it's the original cursor, there may be cursors behind it,
                                " and it will be 'pushed' forward by them
                            
                                " Given the above, the adjusted initial position will then be:
                                "   initial position + ( current change  * number of cursors behind it)
                                let pos = I.begin[1] + I.change*I.nth
                            
                                " find out the actual text that has been inserted up to this point:
                                " it's a slice of the current line, between the updated initial position
                                " (pos) and the current cursor position (coln)
                            
                                " coln needs some adjustments though:
                                "   -  in insert mode, 1 is subtracted to find the current cursor position
                                "   -  but when insert mode stops (a:insert_leave == 1) this isn't true
                            
                                " when exiting insert mode (a:insert_leave), if the last last inserted
                                " character is multibyte, any extra bytes will have to be added to the
                                " final column
                                if a:insert_leave
                                    let extra = s:cur_char_bytes() - 1
                                    let text = getline(ln)[ (pos-1) : (coln-1 + extra) ]
                                    let coln += extra
                                elseif coln > 1
                                    let text = getline(ln)[ (pos-1) : (coln-2) ]
                                else
                                    let text = ''
                                endif
                            
                                " now update the current change: secondary cursors need this value updated
                                let I.change = coln - pos + a:insert_leave
                            
                                " update the lines (also the current line is updated with setline(), this
                                " should ensure that the same text is entered everywhere)
                                if I.replace
                                    let width = strwidth(text)
                                    for l in sort(keys(L))
                                        call L[l].replace(I.change, text, width)
                                    endfor
                                else
                                    for l in sort(keys(L))
                                        call L[l].update(I.change, text)
                                    endfor
                                endif
                            
                                " put the cursor where it should stay after the lines update
                                " as said before, the actual cursor can be pushed by cursors behind it
                                call cursor(ln, I.col)
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Insert mode stop
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Insert.stop(...) abort
                                " Called on InsertLeave.
                                if s:F.not_VM() | return | endif
                            
                                " text must be updated again after InsertLeave, to take into account
                                " changes that don't trigger TextChangedI, for example when exiting
                                " insert mode immediately after CompleteDone or abbreviation expansion
                                " the only case we don't do this, it's when no characters are typed, nor
                                " completion has been performed
                                if self.reupdate
                                    call self.update_text(1)
                                    let self.reupdate = v:false
                                endif
                            
                                call self.clear_hi() | call self.auto_end() | let i = 0
                            
                                if s:v.single_region
                                    let active_line = 0
                                    let s:cursors_after = []
                                    for r in s:R()
                                        let c = self.cursors[i]
                                        if c.active
                                            let active_line = c.l
                                            call r.update_cursor([c.l, c._a])
                                            let s:v.storepos = [r.l, r.a]
                                        elseif active_line == c.l
                                            call r.update_cursor([c.l, c._a])
                                            call add(s:cursors_after, c)
                                        endif
                                        let i += 1
                                    endfor
                                else
                                    for r in s:R()
                                        let c = self.cursors[i]
                                        call r.update_cursor([c.l, c._a])
                                        if r.index == self.index | let s:v.storepos = [r.l, r.a] | endif
                                        let i += 1
                                    endfor
                                endif
                            
                                " NOTE:
                                " - s:v.insert is true if re-entering insert mode after BS/CR/arrows etc;
                                "   it is true until an insert session is really over.
                                "
                                " - s:v.restart_insert is only temporarily true when commands need to exit
                                "   insert mode to update cursors, and enter it again; it is set in plugs,
                                "   to avoid postprocessing.
                            
                                if s:v.restart_insert | let s:v.restart_insert = 0 | return | endif
                            
                                " reset insert mode variables
                                let s:v.eco    = 1
                                let s:v.insert = 0
                            
                                call s:step_back()
                                call s:V.Edit.post_process(0,0)
                            
                                let &l:indentkeys   = s:v.indentkeys
                                let &l:cinkeys      = s:v.cinkeys
                                let &l:synmaxcol    = s:v.synmaxcol
                                let &l:textwidth    = s:v.textwidth
                                let &l:softtabstop  = s:v.softtabstop
                            
                                "restore sync minlines if possible
                                if len(b:VM_sync_minlines)
                                    exe 'syn sync minlines='.b:VM_sync_minlines
                                endif
                            
                                "reindent all and adjust cursors position, only if filetype/options allow
                                if s:do_reindent() | call s:V.Edit.run_normal('==', {'recursive': 0, 'stay_put': 1}) | endif
                            
                                if g:VM_reselect_first
                                    call s:G.select_region(0)
                                elseif self._index >= 0
                                    call s:G.select_region(self._index)
                                else
                                    call s:G.select_region(self.index)
                                endif
                            
                                " now insert mode has really ended, restore winline and clear variable
                                if !g:VM_reselect_first
                                    call s:F.Scroll.force(s:v.winline_insert)
                                endif
                                unlet s:v.winline_insert
                                silent! unlet s:v.smart_case_change
                            
                                " unmap single mode mappings, if they had been mapped
                                call s:map_single_mode(1)
                            
                                " reset type and replace mode last, but not in single region mode
                                if !s:v.single_region
                                    let self.replace = 0
                                    let self.type = ''
                                    silent! unlet self._lines
                                endif
                            
                                if get(g:, 'VM_quit_after_leaving_insert_mode', 0)
                                    call vm#reset()
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Insert.clear_hi() abort
                                " Clear cursors highlight.
                                for c in self.cursors
                                    silent! call matchdelete(c.hl)
                                endfor
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Cursor class
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 let s:Cursor = {}
                            
                            "--------------------------------------------------------------------------
                            
                            "in Insert Mode we will forget about the regions, and work with cursors at
                            "positions; from the final positions, we'll update the real regions later
                            
                            "--------------------------------------------------------------------------
                            
                            
    1              0.000002 fun! s:Cursor.new(ln, col) abort
                                " Create new cursor.
                                let C        = copy(self)
                                let C.index  = len(s:Insert.cursors)
                                let C.txt    = ''
                                let C.l      = a:ln
                                let C.L      = a:ln
                                let C.a      = a:col
                                let C._a     = C.a
                                let C.active = ( C.index == s:Insert.index )
                                let C.hl     = matchaddpos('MultiCursor', [[C.l, C.a]], 40)
                            
                                return C
                            endfun
                            
                            
    1              0.000002 fun! s:Cursor.update(ln, change) abort
                                " Update cursor position and highlight.
                                let C = self
                                let C._a = C.a + a:change
                            
                                silent! call matchdelete(C.hl)
                                let C.hl  = matchaddpos('MultiCursor', [[C.l, C._a]], 40)
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Line class
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 let s:Line = {}
                            
                            
    1              0.000002 fun! s:Line.new(line, cursor) abort
                                " Line object constructor.
                                let L         = copy(self)
                                let L.l       = a:line
                                let L.txt     = getline(a:line)
                                let L.cursors = [a:cursor]
                                return L
                            endfun
                            
                            
    1              0.000002 fun! s:Line.update(change, text) abort
                                " Update a line in insert mode.
                                let text     = self.txt
                                let I        = s:V.Insert
                                let extraChg = 0  " cumulative change for additional cursors in same line
                            
                                " self.txt is the initial text of the line, when insert mode starts
                                " it is not updated: the new text will be inserted inside of it
                                " 'text' is the updated content of the line
                            
                                " self.cursors are the cursors in this line
                            
                                " when created, cursors are relative to normal mode, but in insert mode
                                " 1 must be subtracted from their column (c.a)
                            
                                " a:change is the length of the text inserted by the main cursor
                                " if there are more cursors in the same line, changes add up (== extraChg)
                            
                                " to sum it up, if:
                                "     t1 is the original line, before the insertion point
                                "     t2 is the original line, after the insertion point
                                "     // is the insertion point (== c.a - 1 + nth*a:change)
                                "     \\ is the end of the inserted text
                                " then:
                                "     line = t1 // inserted text \\ t2
                            
                                for c in self.cursors
                                    if s:v.single_region && !c.active
                                        call c.update(self.l, extraChg)
                                        continue
                                    endif
                            
                                    let inserted = exists('s:v.smart_case_change') ?
                                                \ s:smart_case_change(c, a:text) : a:text
                            
                                    if c.a > 1
                                        let insPoint = c.a + extraChg - 1
                                        let t1 = text[ 0 : (insPoint - 1) ]
                                        let t2 = text[ insPoint : ]
                                        let text = t1 . inserted . t2
                                        " echo strtrans(t1) . "█" . strtrans(inserted) . "█" . strtrans(t2)
                                    else
                                        " echo "█" . strtrans(inserted) . "█" . strtrans(text)
                                        let text = inserted . text
                                    endif
                            
                                    " increase the cumulative extra change
                                    let extraChg += a:change
                                    call c.update(self.l, extraChg)
                            
                                    " c._a is the updated cursor position, c.a stays the same
                                    if c.active | let I.col = c._a | endif
                                endfor
                                call setline(self.l, text)
                            endfun
                            
                            
    1              0.000002 fun! s:Line.replace(change, replacementText, width) abort
                                " Update a line in replace mode.
                                let c        = self.cursors[0]         " there's a single cursor in replace mode
                                let original = s:Insert._lines[self.l] " the original line
                                let replaced = a:replacementText       " the typed replacement
                            
                                if c.a > 1
                                    let t1 = strpart(getline(c.l), 0, c.a - 1)
                                    let t2 = strcharpart(original, strwidth(t1) + a:width)
                                    let text = t1 . replaced . t2
                                else
                                    let text = replaced . strcharpart(original, a:width)
                                endif
                            
                                call c.update(self.l, a:change)
                            
                                " c._a is the updated cursor position, c.a stays the same
                                if c.active | let s:Insert.col = c._a | endif
                                call setline(self.l, text)
                            
                                if c._a >= col([c.l, '$'])
                                    call s:V.Edit.extra_spaces.add(c, 1)
                                endif
                            endfun
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Autocommands
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Insert.auto_start() abort
                                " Initialize autocommands.
                                augroup VM_insert
                                    au!
                                    au TextChangedI  <buffer> call b:VM_Selection.Insert.update_text(0)
                                    au InsertLeave   <buffer> call b:VM_Selection.Insert.stop()
                                    au InsertCharPre <buffer> let b:VM_Selection.Insert.reupdate = v:true
                                    au CompleteDone  <buffer> let b:VM_Selection.Insert.reupdate = v:true
                                augroup END
                            endfun
                            
                            
    1              0.000001 fun! s:Insert.auto_end() abort
                                " Terminate autocommands.
                                autocmd! VM_insert
                                augroup! VM_insert
                            endfun
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Helpers
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:smart_case_change(cursor, txt) abort
                                " the active cursor isn't affected, text is entered as typed
                                if a:cursor.active
                                    return a:txt
                                endif
                                try
                                    let original = s:v.changed_text[a:cursor.index]
                                    if match(original, '\u') >= 0 && match(original, '\U') < 0
                                        return toupper(a:txt)
                                    elseif match(original, '\u') == 0
                                        return toupper(a:txt[:0]) . a:txt[1:]
                                    else
                                        return a:txt
                                    endif
                                catch
                                    return a:txt
                                endtry
                            endfun
                            
                            
    1              0.000002 fun! s:cur_char_bytes()
                                " Bytesize of character under cursor
                                return strlen(matchstr(getline('.'), '\%' . col('.') . 'c.'))
                            endfun
                            
                            
    1              0.000002 fun! s:do_reindent() abort
                                " Check if lines must be reindented when exiting insert mode.
                                if empty(&ft) | return | endif
                            
                                return index(vm#comp#no_reindents(), &ft) < 0 &&
                                            \ index(g:VM_reindent_filetypes, &ft) >= 0
                            endfun
                            
                            
    1              0.000002 fun! s:step_back() abort
                                " Go back one char after exiting insert mode, as vim does.
                                if s:v.single_region && s:Insert.type ==? 'i'
                                    return
                                endif
                            
                                for r in s:v.single_region ? [s:R()[s:Insert.index]] : s:R()
                                    if r.a != col([r.l, '$']) && r.a > 1
                                        " move one byte back
                                        call r.shift(-1,-1)
                                        " fix column in case of multibyte chars by using a motion
                                        call r.move('lh')
                                    endif
                                endfor
                            endfun
                            
                            
    1              0.000002 fun! s:map_single_mode(stop) abort
                                " If single_region is active, map Tab to cycle regions.
                                if !s:v.single_region || !get(g:, 'VM_single_mode_maps', 1) | return | endif
                            
                                let next = get(g:VM_maps, 'I Next', '<Tab>')
                                let prev = get(g:VM_maps, 'I Prev', '<S-Tab>')
                            
                                if a:stop
                                    exe 'iunmap <buffer>' next
                                    exe 'iunmap <buffer>' prev
                                    if exists('s:v.single_mode_running')
                                        if s:v.single_mode_running
                                            let s:v.single_mode_running = 0
                                        else
                                            if get(g:, 'VM_single_mode_auto_reset', 1)
                                                call s:F.toggle_option('single_region')
                                            endif
                                            unlet s:v.single_mode_running
                                        endif
                                    endif
                                else
                                    exe 'imap <buffer>' next '<Plug>(VM-I-Next)'
                                    exe 'imap <buffer>' prev '<Plug>(VM-I-Prev)'
                                endif
                            endfun
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=indent fdn=1

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/special/case.vim
Sourced 1 time
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
                            "mostly from abolish.vim, with some minor additions
                            "abolish.vim by Tim Pope <http://tpo.pe/>
                            "https://github.com/tpope/vim-abolish
                            
    1              0.000004 fun! vm#special#case#init() abort
                              let s:V = b:VM_Selection
                              return s:Case
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000008 let s:X = { -> g:Vm.extend_mode }
    1              0.000006 let s:R = { -> s:V.Regions }
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 let s:Case = {}
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Case.pascal(word) abort
                              return substitute(self.camel(a:word),'^.','\u&','')
                            endfun
                            
    1              0.000002 fun! s:Case.camel(word) abort
                              let word = substitute(a:word,'[.-]','_','g')
                              let word = substitute(word,' ','_','g')
                              if word !~# '_' && word =~# '\l'
                                return substitute(word,'^.','\l&','')
                              else
                                return substitute(word,'\C\(_\)\=\(.\)','\=submatch(1)==""?tolower(submatch(2)) : toupper(submatch(2))','g')
                              endif
                            endfun
                            
    1              0.000001 fun! s:Case.snake(word) abort
                              let word = substitute(a:word,'::','/','g')
                              let word = substitute(word,'\(\u\+\)\(\u\l\)','\1_\2','g')
                              let word = substitute(word,'\(\l\|\d\)\(\u\)','\1_\2','g')
                              let word = substitute(word,'[.-]','_','g')
                              let word = substitute(word,' ','_','g')
                              let word = tolower(word)
                              return word
                            endfun
                            
    1              0.000002 fun! s:Case.snake_upper(word) abort
                              return toupper(self.snake(a:word))
                            endfun
                            
    1              0.000001 fun! s:Case.dash(word) abort
                              return substitute(self.snake(a:word),'_','-','g')
                            endfun
                            
    1              0.000002 fun! s:Case.space(word) abort
                              return substitute(self.snake(a:word),'_',' ','g')
                            endfun
                            
    1              0.000001 fun! s:Case.dot(word) abort
                              return substitute(self.snake(a:word),'_','.','g')
                            endfun
                            
    1              0.000001 fun! s:Case.title(word) abort
                              return substitute(self.space(a:word), '\(\<\w\)','\=toupper(submatch(1))','g')
                            endfun
                            
    1              0.000001 fun! s:Case.lower(word) abort
                              return tolower(a:word)
                            endfun
                            
    1              0.000001 fun! s:Case.upper(word) abort
                              return toupper(a:word)
                            endfun
                            
    1              0.000002 fun! s:Case.capitalize(word) abort
                              return toupper(a:word[0:0]) . tolower(a:word[1:])
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! s:Case.menu() abort
                              if get(g:, 'VM_verbose_commands', 0)
                                echohl WarningMsg | echo "\tCase Conversion\n---------------------------------"
                                echohl WarningMsg | echo "u         " | echohl Type | echon "lowercase"       | echohl None
                                echohl WarningMsg | echo "U         " | echohl Type | echon "UPPERCASE"       | echohl None
                                echohl WarningMsg | echo "C         " | echohl Type | echon "Captialize"      | echohl None
                                echohl WarningMsg | echo "t         " | echohl Type | echon "Title Case"      | echohl None
                                echohl WarningMsg | echo "c         " | echohl Type | echon "camelCase"       | echohl None
                                echohl WarningMsg | echo "P         " | echohl Type | echon "PascalCase"      | echohl None
                                echohl WarningMsg | echo "s         " | echohl Type | echon "snake_case"      | echohl None
                                echohl WarningMsg | echo "S         " | echohl Type | echon "SNAKE_UPPERCASE" | echohl None
                                echohl WarningMsg | echo "-         " | echohl Type | echon "dash-case"       | echohl None
                                echohl WarningMsg | echo ".         " | echohl Type | echon "dot.case"        | echohl None
                                echohl WarningMsg | echo "<space>   " | echohl Type | echon "space case"      | echohl None
                                echohl WarningMsg | echo "---------------------------------"
                                echohl Directory  | echo "Enter an option: " | echohl None
                              else
                                echohl Constant   | echo "Case conversion: " | echohl None | echon '(u/U/C/t/c/P/s/S/-/./ )'
                              endif
                              let c = nr2char(getchar())
                              let case = {
                                    \ "u": 'lower',      "U": 'upper',
                                    \ "C": 'capitalize', "t": 'title',
                                    \ "c": 'camel',      "P": 'pascal',
                                    \ "s": 'snake',      "S": 'snake_upper',
                                    \ "-": 'dash',       "k": 'remove',
                                    \ ".": 'dot',        " ": 'space',
                                    \}
                              if has_key(case, c)
                                call self.convert(case[c])
                              endif
                              if get(g:, 'VM_verbose_commands', 0)
                                call feedkeys("\<cr>", 'n')
                              endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:Case.convert(type) abort
                              if !len(s:R()) | return | endif
                              if !s:X()
                                call vm#operators#select(1, 'iw')
                              endif
                            
                              let text = [] | let g:Vm.registers['"'] = text
                              for r in s:R()
                                call add(text, eval("self.".a:type."(r.txt)"))
                              endfor
                              call b:VM_Selection.Edit.paste(1, 0, 1, '"')
                            endfun
                            " vim: et ts=2 sw=2 sts=2 :

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim
Sourced 1 time
Total time:   0.000432
 Self time:   0.000432

count  total (s)   self (s)
                            
    1              0.000008 fun! vm#region#init() abort
                                let s:V = b:VM_Selection
                                let s:v = s:V.Vars
                                let s:G = s:V.Global
                                let s:F = s:V.Funcs
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000007 let s:X = { -> g:Vm.extend_mode }
    1              0.000004 let s:R = { -> s:V.Regions }
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Region class
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " A new region will only been created if not already existent at position.
                            
                            " b:VM_Selection (= s:V) contains Regions, Matches, Vars (= s:v = plugin variables)
                            
                            " s:V.Global    : holds the Global class methods
                            " s:V.Regions   : contains the regions with their contents
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! vm#region#new(cursor, ...) abort
                                " Create region from marks, offsets or positions.
                            
                                "----------------------------------------------------------------------
                            
                                if a:0
                                    if a:0 == 2             "making a new region from offsets
                                        let a = byte2line(a:1) | let c = a:1 - line2byte(a) + 1
                                        let b = byte2line(a:2) | let d = a:2 - line2byte(b) + 1
                            
                                    else                    "making a new region from positions
                                        let a = a:1 | let b = a:2 | let c = a:3 | let d = a:4
                                    endif
                                endif
                            
                                "----------------------------------------------------------------------
                            
                                let cursor = a:cursor || ( a:0 && c==d && a==b )          "cursor or region?
                            
                                if !g:Vm.buffer | call vm#init_buffer(cursor) | endif     "activate if needed
                            
                                if !a:0 | let R = s:Region.new(cursor)                    "create region
                                else    | let R = s:Region.new(0, a, b, c, d)
                                endif
                            
                                "----------------------------------------------------------------------
                            
                                "update region index and ID count
                                let s:v.index = R.index | let s:v.ID += 1
                            
                                "keep regions list ordered
                                if empty(s:R()) || s:R()[s:v.index-1].A < R.A
                                    call add(s:R(), R)
                                else
                                    let i = 0
                                    for r in s:R()
                                        if r.A > R.A
                                            call insert(s:R(), R, i)
                                            break
                                        endif
                                        let i += 1
                                    endfor
                                    let s:v.index = i
                                    call s:G.update_indices(i)
                                endif
                            
                                call s:G.update_cursor_highlight()
                                return R
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 let s:Region = {}
                            
                            
    1              0.000002 fun! s:Region.new(cursor, ...) abort
                                " Initialize region variables and methods.
                                "
                                " Uppercase variables (A,B,K) are for byte offsets, except L (end line).
                            
                                " a/b/k/l/L    : start, end, anchor, first line, end line
                                " R.cur_col()  : returns the current cursor column(a or b), based on direction.
                                " R.cur_Col()  : cur_col() in byte offset form
                                " R.cur_ln()   : the line where cur_col() is located
                                " R.char()     : returns the char under the active head, '' in cursor mode.
                                " R.id         : an individual incremental id, that will never change.
                                " R.dir        : is the current orientation for the region.
                                " R.txt        : is the text content.
                                " R.pat        : is the search pattern associated with the region
                                " R.matches    : holds the highlighting matches
                            
                                let R         = copy(self)
                                let R.index   = len(s:R())
                                let R.dir     = s:v.direction
                                let R.id      = s:v.ID + 1
                            
                                let R.matches = {'region': [], 'cursor': 0}
                            
                                if !a:0                "/////// FROM MAPPINGS ///////
                            
                                    call s:region_vars(R, a:cursor)
                            
                                else                   "///////// FROM ARGS ///////////
                            
                                    call s:region_vars(R, a:cursor, a:1, a:2, a:3, a:4)
                                endif
                            
                                call add(s:v.IDs_list, R.id)
                            
                                if !s:v.eco
                                    call R.highlight()
                                endif
                                call R.update_bytes_map()
                            
                                return R
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Region methods
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Region.empty() abort
                                return self.A == self.B
                            endfun
                            
                            
    1              0.000001 fun! s:Region.A_() abort
                                return line2byte(self.l) + self.a - 1
                            endfun
                            
                            
    1              0.000001 fun! s:Region.B_() abort
                                " Last byte of the last character in the region.
                                " This will be greater than the column, if character is multibyte.
                                let bytes = len(self.txt) ? strlen(self.txt[-1:-1]) : 1
                                return line2byte(self.L) + self.b + bytes - 2
                            endfun
                            
                            
    1              0.000001 fun! s:Region.cur_ln() abort
                                return self.dir ? self.L : self.l
                            endfun
                            
                            
    1              0.000001 fun! s:Region.cur_col() abort
                                return self.dir ? self.b : self.a
                            endfun
                            
                            
    1              0.000001 fun! s:Region.cur_Col() abort
                                return self.cur_col() == self.b ? self.B : self.A
                            endfun
                            
                            
    1              0.000001 fun! s:Region.char() abort
                                return s:X()? s:F.char_at_pos(self.l, self.cur_col()) : ''
                            endfun
                            
                            
    1              0.000002 fun! s:Region.shift(x, y) abort
                                " Shift region offsets by integer values.
                                "TODO: this will surely cause trouble in insert mode with multibyte chars
                                "all r.shift() in insert mode should be replaced with r.update_cursor()
                                let r = self
                            
                                let r.A += a:x | let r.B += a:y
                            
                                let r.l = byte2line(r.A)
                                let r.L = byte2line(r.B)
                                let r.a = r.A - line2byte(r.l) + 1
                                let r.b = r.B - line2byte(r.L) + 1
                            
                                if !s:v.eco | call r.update() | endif
                                return [r.l, r.L, r.a, r.b]
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Remove region
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Region.remove() abort
                                " Remove a region and its id, then update indices.
                                call self.remove_highlight()
                                call remove(s:R(), self.index)
                                call remove(s:v.IDs_list, index(s:v.IDs_list, self.id))
                            
                                if len(s:R()) | call s:G.update_indices()
                                else          | let s:v.index = -1
                                endif
                            
                                if s:v.index >= len(s:R()) | let s:v.index = len(s:R()) - 1 | endif
                                return self
                            endfun
                            
                            
    1              0.000002 fun! s:Region.clear(...) abort
                                " Called if it's necessary to clear the byte map as well.
                                call self.remove_from_byte_map(a:0)
                                return self.remove()
                            endfun
                            
                            
    1              0.000002 fun! s:Region.remove_from_byte_map(all) abort
                                " Remove a region from the bytes map.
                                if !s:X() | return | endif
                            
                                if a:all
                                    for b in range(self.A, self.B) | call remove(s:V.Bytes, b) | endfor
                                else
                                    for b in range(self.A, self.B)
                                        if s:V.Bytes[b] > 1 | let s:V.Bytes[b] -= 1
                                        else                | call remove(s:V.Bytes, b)
                                        endif
                                    endfor
                                endif
                            endfun
                            
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Region motions
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000001 fun! s:Region.move(...) abort
                                " Move cursors, or extend regions by motion.
                                let s:motion = a:0? a:1 : s:v.motion
                            
                                if !s:X()
                                    call s:move_cursor(self)
                                else
                                    call s:move_region(self)
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Region.set_vcol(...) abort
                                " Set vertical column if motion is j or k, and vcol not previously set.
                                if !s:vertical()
                                    let self.vcol = 0
                                elseif !self.vcol
                                    let before = getline('.')[:col('.')-1]
                                    let self.bdiff = strlen(before) - strchars(before)
                                    let self.vcol = col('.')
                                    if !&expandtab
                                        let self.ntabs = count(before, "\t")
                                    endif
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:vertical() abort
                                return index(['j', 'k'], s:motion[0]) >=0
                            endfun
                            
                            
    1              0.000002 fun! s:move_cursor(r) abort
                                " If not in extend mode, just move the cursors.
                            
                                call cursor(a:r.l, a:r.a)
                                call a:r.set_vcol()
                                exe "keepjumps normal! ".s:motion
                            
                                "keep line or column
                                if s:vertical()       | call s:keep_vertical_col(a:r)
                                elseif !s:v.multiline | call s:keep_line(a:r, line('.'))
                                endif
                            
                                call a:r.update_cursor_pos()
                            endfun
                            
                            
    1              0.000002 fun! s:keep_line(r, ln) abort
                                " Ensure line boundaries aren't crossed. Force cursor merging.
                                let r = a:r
                            
                                if     ( a:ln > r.l ) | call cursor ( r.l, col([r.l, '$'])-1 ) | let s:v.merge = s:X()? s:v.merge : 1
                                elseif ( a:ln < r.l ) | call cursor ( r.l, col([r.l, 1]) )     | let s:v.merge = s:X()? s:v.merge : 1
                                else                  | call cursor ( r.l, col('.') )
                                endif
                            endfun
                            
                            
    1              0.000003 fun! s:keep_vertical_col(r) abort
                                " Keep the vertical column if moving vertically.
                                let before = getline('.')[:col('.')-1]
                                let bdiff = strlen(before) - strchars(before)
                            
                                let vcol    = a:r.vcol - a:r.bdiff + bdiff
                                let lnum    = line('.')
                                let endline = (col('$') > 1)? col('$') - 1 : 1
                            
                                if !&expandtab
                                    let ntabs = count(before, "\t")
                                    let tabsdiff = ntabs - a:r.ntabs
                                    let vcol -= &tabstop * tabsdiff - tabsdiff
                                endif
                            
                                if ( vcol < endline )
                                    call cursor ( lnum, vcol )
                                elseif ( a:r.cur_col() < endline )
                                    call cursor ( lnum, endline )
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:move_region(r) abort
                                " Perform the motion.
                                let r = a:r | let a = r.a | let b = r.b | let up = 0 | let down = 0
                            
                                "move the cursor to the current head and perform the motion
                                call cursor(r.cur_ln(), r.cur_col())
                                call a:r.set_vcol()
                                exe "keepjumps normal! ".s:motion
                            
                                if s:vertical() | call s:keep_vertical_col(r) | endif
                            
                                "check the line
                                let nl = line('.')
                            
                                if !s:v.multiline  | call s:keep_line(r, nl)
                            
                                elseif   nl < r.l                        |   let r.l = nl
                                elseif   nl > r.L                        |   let r.L = nl
                                elseif   nl > r.l && r.cur_ln() == r.l   |   let r.l = nl
                                elseif   nl < r.L && r.cur_ln() == r.L   |   let r.L = nl
                                endif
                            
                                "get the new position and see if there's been inversion
                                let newcol = col('.')
                                if !s:v.multiline
                                    let went_back  =   newcol < r.k
                                    let went_forth =   newcol > r.k
                                else
                                    let New = s:F.curs2byte()
                                    let went_back  =   ( New <  r.K )  &&  ( New <  r.cur_Col() )
                                    let went_forth =   ( New >= r.K )  &&  ( New >= r.cur_Col() )
                                endif
                            
                                "assign new values
                                if went_back
                                    let r.dir = 0
                                    let r.a = newcol
                                    let r.b = r.k
                            
                                elseif went_forth
                                    let r.dir = 1
                                    let r.b = newcol
                                    let r.a = r.k
                            
                                elseif r.dir
                                    let r.b = col('.')
                                else
                                    let r.a = col('.')
                                endif
                            
                                call r.update_region()
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Update functions
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:Region.update() abort
                                " Update region.
                                if s:X() | call self.update_region()
                                else     | call self.update_cursor()
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:Region.update_cursor(...) abort
                                " Update cursor vars from position [line, col] or offset.
                                let r = self
                            
                                if a:0 && !type(a:1)
                                    let r.l = byte2line(a:1)
                                    let r.a = a:1 - line2byte(r.l) + 1
                                elseif a:0
                                    let r.l = a:1[0]
                                    let r.a = a:1[1]
                                endif
                            
                                call s:fix_pos(r)
                                call self.update_vars()
                            endfun
                            
                            
    1              0.000002 fun! s:Region.update_cursor_pos() abort
                                " Update cursor to current position.
                                let [ self.l, self.a ] = getpos('.')[1:2]
                                call s:fix_pos(self)
                                call self.update_vars()
                            endfun
                            
                            
    1              0.000001 fun! s:Region.update_content() abort
                                " Get region content if in extend mode.
                                let r = self
                                call cursor(r.l, r.a)   | keepjumps normal! m[
                                call cursor(r.L, r.b+1) | silent keepjumps normal! m]`[y`]
                                let r.txt = getreg(s:v.def_reg)
                            
                                if s:v.multiline && r.b == col([r.L, '$'])
                                    let r.txt .= "\n"
                                else
                                    " if last character is multibyte, it won't be yanked, add it manually
                                    let lastchar = s:F.char_at_pos(r.L, r.b)
                                    if strlen(lastchar) > 1
                                        let r.txt .= lastchar
                                    endif
                                endif
                                let r.pat = s:pattern(r)
                            endfun
                            
                            
    1              0.000001 fun! s:Region.update_region(...) abort
                                " Update the main region positions.
                                let r = self
                            
                                if a:0 == 4
                                    let [ r.l, r.L, r.a, r.b ] = [ a:1, a:2, a:3, a:4 ]
                                endif
                            
                                call s:fix_pos(r)
                                call self.update_content()
                                call self.update_vars()
                            endfun
                            
                            
    1              0.000002 fun! s:Region.update_vars() abort
                                " Update the rest of the region variables.
                            
                                let r         = self
                                let s:v.index = r.index
                            
                                "   "--------- cursor mode ----------------------------
                            
                                if !s:X()
                                    let r.L   = r.l              | let r.b = r.a
                                    let r.A   = r.A_()           | let r.B = r.A
                                    let r.k   = r.a              | let r.K = r.A
                                    let r.w   = 0                | let r.h = 0
                                    let r.txt = ''               | let r.pat = s:pattern(r)
                            
                                    "--------- extend mode ----------------------------
                            
                                else
                                    let r.A   = r.A_()           | let r.B = r.B_()
                                    let r.w   = r.B - r.A + 1    | let r.h = r.L - r.l
                                    let r.k   = r.dir? r.a : r.b | let r.K   = r.dir? r.A : r.B
                            
                                    call r.update_bytes_map()
                                endif
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Highlight functions
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000001 fun! s:Region.highlight() abort
                                " Create the highlight entries.
                            
                                if s:v.eco | return | endif
                                let R = self
                            
                                "------------------ cursor mode ----------------------------
                            
                                if !s:X()
                                    let R.matches.cursor = R.a == 1
                                                \ ? matchadd('MultiCursor', '\%' . R.l . 'l\%1c')
                                                \ : matchaddpos('MultiCursor', [[R.l, R.a]], 40)
                                    return
                                endif
                            
                                "------------------ extend mode ----------------------------
                            
                                let max    = R.L - R.l
                                let region = []
                                let cursor = [R.cur_ln(), R.cur_col()]
                            
                                "skip the for loop if single line
                                if !max | let region = [[R.l, R.a, R.w]] | else | let max += 1 | endif
                            
                                "define highlight
                                for n in range(max)
                                    let line =    n==0    ? [R.l, R.a, len(getline(R.l))] :
                                                \ n<max-1 ? [R.l + n] :
                                                \           [R.L, 1, R.b]
                            
                                    call add(region, line)
                                endfor
                            
                                "build a list of highlight entries, one for each possible line
                                for line in region
                                    call add(R.matches.region, matchaddpos(g:Vm.hi.extend, [line], 30))
                                endfor
                                let R.matches.cursor = matchaddpos('MultiCursor', [cursor], 40)
                            endfun
                            
                            
    1              0.000002 fun! s:Region.remove_highlight() abort
                                " Remove the highlight entries.
                                let r       = self.matches.region
                                let c       = self.matches.cursor
                            
                                for m in r | silent! call matchdelete(m) | endfor
                                silent! call matchdelete(c)
                            endfun
                            
                            
    1              0.000001 fun! s:Region.update_highlight() abort
                                " Update the region highlight.
                                call self.remove_highlight()
                                call self.highlight()
                            endfun
                            
                            
    1              0.000001 fun! s:Region.update_bytes_map() abort
                                " Update bytes map for region.
                                if !s:X() | return | endif
                            
                                for b in range(self.A, self.B)
                                    let s:V.Bytes[b] = get(s:V.Bytes, b, 0) + 1
                                endfor
                            endfun
                            
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Misc functions
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000002 fun! s:pattern(r) abort
                                " Find the search pattern associated with the region.
                            
                                if empty(s:v.search) | return s:V.Search.escape_pattern(a:r.txt) | endif
                            
                                for p in s:v.search
                                    if a:r.txt =~ p | return p | endif
                                endfor
                            
                                "return current search pattern in regex mode
                                if !has_key(a:r, 'pat')
                                    return s:v.using_regex ? s:v.search[0] : ''
                                endif
                            
                                "return current pattern if one is present (in cursor mode text is empty)
                                return a:r.pat
                            endfun
                            
                            
    1              0.000002 fun! s:fix_pos(r) abort
                                " Fix positions at end of line.
                                let r = a:r
                                let eol = col([r.l, '$']) - 1
                                let eoL = col([r.L, '$']) - 1
                            
                                if !s:v.multiline
                                    if r.a > eol    | let r.a = eol? eol : 1 | endif
                                    if r.b > eoL    | let r.b = eoL? eoL : 1 | endif
                                else
                                    if r.a > eol+1  | let r.a = eol? eol+1 : 1 | endif
                                    if r.b > eoL+1  | let r.b = eoL? eoL+1 : 1 | endif
                                endif
                            endfun
                            
                            
    1              0.000002 fun! s:region_vars(r, cursor, ...) abort
                                " Update region variables.
                                let R = a:r
                            
                                if !a:0 && a:cursor    "/////////// CURSOR ////////////
                            
                                    let R.l     = line('.')
                                    let R.L     = R.l
                                    let R.a     = col('.')
                                    let R.b     = R.a
                            
                                    call s:fix_pos(R)
                            
                                    let R.txt   = R.char()              " character under cursor in extend mode
                                    let R.pat   = s:pattern(R)
                            
                                    let R.A     = R.A_()                " byte offset a
                                    let R.B     = s:X() ? R.B_() : R.A  " byte offset b
                                    let R.w     = R.B - R.A + 1         " width
                                    let R.h     = R.L - R.l             " height
                                    let R.k     = R.dir? R.a : R.b      " anchor
                                    let R.K     = R.dir? R.A : R.B      " anchor offset
                            
                                elseif !a:0            "/////////// REGION ////////////
                            
                                    let R.l     = line("'[")            " starting line
                                    let R.L     = line("']")            " ending line
                                    let R.a     = col("'[")             " begin
                                    let R.b     = col("']")             " end
                            
                                    call s:fix_pos(R)
                            
                                    let R.txt   = getreg(s:v.def_reg)   " text content
                                    let R.pat   = s:pattern(R)          " associated search pattern
                            
                                    let R.A     = R.A_()                " byte offset a
                                    let R.B     = R.B_()                " byte offset b
                                    let R.w     = R.B - R.A + 1         " width
                                    let R.h     = R.L - R.l             " height
                                    let R.k     = R.dir? R.a : R.b      " anchor
                                    let R.K     = R.dir? R.A : R.B      " anchor offset
                            
                                else                   "///////// FROM ARGS ///////////
                            
                                    let R.l     = a:1
                                    let R.L     = a:2
                                    let R.a     = a:3
                                    let R.b     = a:4
                            
                                    call s:fix_pos(R)
                                    call R.update_content()
                            
                                    let R.A     = R.A_()                " byte offset a
                                    let R.B     = R.B_()                " byte offset b
                                    let R.w     = R.B - R.A + 1         " width
                                    let R.h     = R.L - R.l             " height
                                    let R.k     = R.dir? R.a : R.b      " anchor
                                    let R.K     = R.dir? R.A : R.B      " anchor offset
                                endif
                            
                                " used to keep the column during vertical cursors movement
                                let R.vcol  = 0 " vertical column
                                let R.ntabs = 0 " number of tabs before cursor if noexpandtab
                                let R.bdiff = 0 " bytes diff if multibyte characters before cursor
                            endfun
                            
                            
                            " vim: et sw=4 ts=4 sts=4 fdm=indent fdn=1

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/operators.vim
Sourced 1 time
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Select operator
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000010 fun! vm#operators#init() abort
                                let s:V = b:VM_Selection
                                let s:v = s:V.Vars
                                let s:G = s:V.Global
                                let s:F = s:V.Funcs
                            endfun
                            
    1              0.000013 fun! s:init() abort
                                let g:Vm.extend_mode = 1
                                if !g:Vm.buffer | call vm#init_buffer(0) | endif
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Lambdas
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000006 let s:R      = { -> s:V.Regions }
    1              0.000007 let s:single = { c -> index(split('hljkwebWEB$^0{}()%nN', '\zs'), c) >= 0 }
    1              0.000005 let s:double = { c -> index(split('iafFtTg', '\zs'), c) >= 0              }
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#operators#select(count, ...) abort
                                call s:init()
                                let pos = getpos('.')[1:2]
                                call s:F.Scroll.get(1)
                            
                                if a:0 | return s:select(a:1) | endif
                            
                                let [ abort, s, n ] = [ 0, '', '' ]
                                let x = a:count>1? a:count : 1
                                echo "Selecting: ".(x>1? x : '')
                            
                                while 1
                                    let c = getchar()
                            
                                    if c == 27 | let abort = 1      | break
                                    else       | let c = nr2char(c) | endif
                            
                                    if str2nr(c) > 0
                                        let n .= c    | echon c
                            
                                    elseif s:single(c)
                                        let s .= c    | echon c | break
                            
                                    elseif s:double(c) || len(s)
                                        let s .= c    | echon c
                                        if len(s) > 1 | break   | endif
                            
                                    else
                                        let abort = 1 | break
                                    endif
                                endwhile
                            
                                if abort | return | endif
                            
                                " change $ in g_
                                let s = substitute(s, '\$', 'g_', 'g')
                            
                                let n = n<1? 1 : n
                                let n = n*x>1? n*x : ''
                                call s:select(n . s)
                                call s:G.update_and_select_region(pos)
                                call s:F.Scroll.restore()
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:select(obj) abort
                                call s:updatetime()
                                call s:V.Maps.disable(1)
                            
                                if a:obj =~ '"' || a:obj =~ "'"
                                    let cmd = 'v' . a:obj . 'y'
                                else
                                    let cmd = 'y' . a:obj
                                endif
                            
                                silent! nunmap <buffer> y
                            
                                let Rs = map(copy(s:R()), '[v:val.l, v:val.a]')
                                call s:G.erase_regions()
                            
                                for r in Rs
                                    call cursor(r[0], r[1])
                                    exe "normal" cmd
                                    call s:get_region(0)
                                endfor
                            
                                call s:V.Maps.enable()
                                call s:G.check_mutliline(1)
                            
                                nmap <silent><nowait><buffer> y <Plug>(VM-Yank)
                            
                                if empty(s:v.search) | let @/ = '' | endif
                                call s:old_updatetime()
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#operators#after_yank() abort
                                "find operator
                                if g:Vm.finding
                                    let g:Vm.finding = 0
                                    call vm#operators#find(0, s:v.visual_regex)
                                    let s:v.visual_regex = 0
                                    call s:old_updatetime()
                                    nmap <silent> <nowait> <buffer> y <Plug>(VM-Yank)
                                endif
                            endfun
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:get_region(add_pattern) abort
                                """Create region with select operator.
                                let R = s:G.region_at_pos()
                                if !empty(R) | return R | endif
                            
                                let R = vm#region#new(0)
                                "R.txt can be different because yank != visual yank
                                call R.update_content()
                                if a:add_pattern
                                    call s:V.Search.add_if_empty()
                                endif
                                call s:F.restore_reg()
                                return R
                            endfun
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Find operator
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#operators#find(start, visual, ...) abort
                                if a:start
                                    if !g:Vm.buffer
                                        call s:backup_map_find()
                                        if a:visual
                                            "use search register if just starting from visual mode
                                            call s:V.Search.get_slash_reg(s:v.oldsearch[0])
                                        endif
                                    else
                                        call s:V.Search.ensure_is_set()
                                        call s:backup_map_find()
                                    endif
                            
                                    call s:updatetime()
                                    let g:Vm.finding = 1
                                    let s:vblock = a:visual && mode() == "\<C-v>"
                                    silent! nunmap <buffer> y
                                    return 'y'
                                endif
                            
                                "set the cursor to the start of the yanked region, then find occurrences until end mark is met
                                let [endline, endcol] = getpos("']")[1:2]
                                keepjumps normal! `[
                                let [startline, startcol] = getpos('.')[1:2]
                            
                                if !search(join(s:v.search, '\|'), 'znp', endline)
                                    call s:merge_find()
                                    if !len(s:R())
                                        call vm#reset(1)
                                    endif
                                    return
                                endif
                            
                                let ows = &wrapscan
                                set nowrapscan
                                silent keepjumps normal! ygn
                                if s:vblock
                                    let R = getpos('.')[2]
                                    if !( R < startcol || R > endcol )
                                        call s:G.new_region()
                                    endif
                                else
                                    call s:G.new_region()
                                endif
                            
                                while 1
                                    if !search(join(s:v.search, '\|'), 'znp', endline) | break | endif
                                    silent keepjumps normal! nygn
                                    if getpos("'[")[1] > endline
                                        break
                                    elseif s:vblock
                                        let R = getpos('.')[2]
                                        if ( R < startcol || R > endcol )
                                            continue
                                        endif
                                    endif
                                    call s:G.new_region()
                                endwhile
                                let &wrapscan = ows
                                call s:merge_find()
                            endfun
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Helpers
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! s:updatetime() abort
                                """If not using TextYankPost, use CursorHold and reduce &updatetime.
                                if g:Vm.oldupdate
                                    let &updatetime = 100
                                endif
                            endfun
                            
    1              0.000002 fun! s:old_updatetime() abort
                                """Restore old &updatetime value.
                                if g:Vm.oldupdate
                                    let &updatetime = g:Vm.oldupdate
                                endif
                            endfun
                            
    1              0.000002 fun! s:backup_map_find() abort
                                "use temporary regions, they will be merged later
                                call s:init()
                                let s:Bytes = copy(s:V.Bytes)
                                let s:V.Regions = []
                                let s:V.Bytes = {}
                                let s:v.index = -1
                                let s:v.no_search = 1
                                let s:v.eco = 1
                            endfun
                            
    1              0.000001 fun! s:merge_find() abort
                                let new_map = copy(s:V.Bytes)
                                let s:V.Bytes = s:Bytes
                                call s:G.merge_maps(new_map)
                                unlet new_map
                            endfun
                            
                            " vim: et ts=4 sw=4 sts=4 :

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/special/commands.vim
Sourced 1 time
Total time:   0.000312
 Self time:   0.000312

count  total (s)   self (s)
                            " Special commands that can be selected through the Tools Menu (<leader>x)
                            
    1              0.000017 let s:R = { -> s:V.Regions }
    1              0.000009 let s:X = { -> g:Vm.extend_mode }
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 fun! vm#special#commands#menu() abort
                              " Tools menu. {{{1
                              let opts = [
                                    \['"    - ', "Show VM registers"],
                                    \['i    - ', "Show regions info"],
                                    \["\n", ""],
                                    \['f    - ', "Filter regions by pattern or expression"],
                                    \['l    - ', "Filter lines with regions"],
                                    \['r    - ', "Regions contents to buffer"],
                                    \['q    - ', "Fill quickfix with regions lines"],
                                    \['Q    - ', "Fill quickfix with regions positions and contents"],
                                    \]
                              for o in opts
                                echohl WarningMsg | echo o[0] | echohl Type | echon o[1]
                              endfor
                              echohl Directory  | echo "Enter an option: " | echohl None
                              let c = nr2char(getchar())
                              if c ==# '"'
                                redraw!
                                call vm#special#commands#show_registers(0, '')
                              elseif c ==# 'i'
                                redraw!
                                call s:F.regions_contents()
                              elseif c ==# 'r'
                                call feedkeys("\<cr>", 'n')
                                call vm#special#commands#regions_to_buffer()
                              elseif c ==# 'f'
                                redraw!
                                call vm#special#commands#filter_regions(0, '', 1)
                              elseif c ==# 'l'
                                call feedkeys("\<cr>", 'n')
                                call vm#special#commands#filter_lines()
                              elseif c ==# 'q'
                                call feedkeys("\<cr>", 'n')
                                call vm#special#commands#qfix(1)
                              elseif c ==# 'Q'
                                call feedkeys("\<cr>", 'n')
                                call vm#special#commands#qfix(0)
                              else
                                call feedkeys("\<cr>", 'n')
                              endif
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#special#commands#filter_lines() abort
                              " Filter lines containing regions, and paste them in a new buffer. {{{1
                              if !len(s:R()) | return | endif
                            
                              let lines = sort(keys(s:G.lines_with_regions(0)))
                              let txt = []
                              for l in lines
                                call add(txt, getline(l))
                              endfor
                              call vm#reset(1)
                              let s:buf = bufnr("%")
                              noautocmd keepalt botright new! VM\ Filtered\ Lines
                              let &l:statusline = '%#WarningMsg#VM Filtered Lines (:w updates lines!)'
                              let b:VM_lines = lines
                              for t in txt
                                put = t
                              endfor
                              1d _
                              call s:temp_buffer()
                              autocmd BufWriteCmd <buffer> call s:save_lines()
                            endfun
                            
                            
    1              0.000002 fun! s:save_lines() abort
                              setlocal nomodified
                              if len(b:VM_lines) != line("$")
                                return s:F.msg("Number of lines doesn't match, aborting")
                              endif
                              let lnums = copy(b:VM_lines)
                              let lines = map(range(line("$")), 'getline(v:key + 1)')
                              let buf = b:VM_buf
                              quit
                              exe buf."b"
                              let i = 0
                              for l in lnums
                                call setline(l, lines[i])
                                let i += 1
                              endfor
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#special#commands#regions_to_buffer() abort
                              " Paste selected regions in a new buffer. {{{1
                              if !s:X() || !len(s:R()) | return | endif
                            
                              let txt = []
                              for r in s:R()
                                let t = r.txt
                                if t[-1:-1] != "\n" | let t .= "\n" | endif
                                call add(txt, r.txt)
                              endfor
                              call vm#reset(1)
                              let s:buf = bufnr("%")
                              noautocmd keepalt botright new! VM\ Filtered\ Regions
                              let &l:statusline = '%#WarningMsg#VM Filtered Regions (:w updates regions!)'
                              let b:VM_regions = copy(s:R())
                              for t in txt
                                put = t
                              endfor
                              1d _
                              call s:temp_buffer()
                              autocmd BufWriteCmd <buffer> call s:save_regions()
                            endfun
                            
                            
    1              0.000002 fun! s:save_regions() abort
                              setlocal nomodified
                              if len(b:VM_regions) != line("$")
                                return s:F.msg("Number of lines doesn't match number of regions")
                              endif
                              let R = copy(b:VM_regions)
                              let lines = map(range(line("$")), 'getline(v:key + 1)')
                              let buf = b:VM_buf
                              quit
                              exe buf."b"
                              for r in R
                                call vm#region#new(0, r.l, r.L, r.a, r.b)
                              endfor
                              call s:G.extend_mode()
                              call s:V.Edit.replace_regions_with_text(lines)
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 fun! vm#special#commands#filter_regions(type, exp, prompt) abort
                              " Filter regions based on pattern or expression. {{{1
                              if a:type == 0 || a:type > 2
                                let s:filter_type = 0
                              else
                                let s:filter_type = a:type
                              endif
                              let type = ['pattern', '!pattern', 'expression'][s:filter_type]
                              if a:prompt
                                cnoremap <buffer><nowait><silent><expr> <C-x> <sid>filter_regions(getcmdline())
                                echohl Label
                                let exp = input('Enter a filter (^X '.type.') > ', a:exp, 'command')
                                echohl None
                                cunmap <buffer> <C-x>
                              else
                                let exp = a:exp
                              endif
                              if empty(exp)
                                call s:F.msg('Canceled.')
                              else
                                call s:G.filter_by_expression(exp, type)
                                call s:G.update_and_select_region()
                              endif
                            endfun
                            
                            
    1              0.000002 fun! s:filter_regions(fill) abort
                              let s:filter_type += 1
                              let args = s:filter_type . ", '" . a:fill . "', 1"
                              return "\<C-U>\<Esc>:call vm#special#commands#filter_regions(".args.")\<cr>"
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#special#commands#mass_transpose()
                              " Mass transpose. {{{1
                              let VM = b:VM_Selection
                              if len(VM.Regions) == 1 || !g:Vm.extend_mode
                                echo "Not possible"
                                return
                              endif
                            
                              let txt = VM.Global.regions_text()
                            
                              " create a list of the unique regions contents
                              let unique = uniq(copy(txt))
                            
                              if len(unique) == 1
                                echo "Regions have the same content"
                                return
                              endif
                            
                              " move first unique text to the bottom of the stack, but make a copy first
                              let old = copy(unique)
                              call add(unique, remove(unique, 0))
                            
                              " create new text
                              let new_text = []
                              for t in txt
                                call add(new_text, old[index(unique, t)])
                              endfor
                            
                              " fill register and paste new text
                              call VM.Edit.fill_register('"', new_text, 0)
                              call VM.Edit.paste(1, 0, 1, '"')
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! vm#special#commands#debug() abort
                              " Debug. {{{1
                              if !exists('b:VM_Debug')
                                return
                              elseif empty(b:VM_Debug.lines)
                                echomsg '[visual-multi] No errors'
                                return
                              endif
                            
                              for line in b:VM_Debug.lines
                                if !empty(line)
                                  echom line
                                endif
                              endfor
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000018 let s:root = fnamemodify(expand('<sfile>'), ':p:h:h:h:h')
                            
    1              0.000002 fun! vm#special#commands#new_test() abort
                              " Create directory and files for a new test. {{{1
                              let name = input('Name of test: ')
                              if name == '' | return | endif
                              let dir = s:root . '/test/tests/' . name . '/'
                              exe 'tabedit' fnameescape(dir . 'input_file.txt')
                              put ='Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'
                              set tw=79
                              normal! gg"_ddgq_
                              exe 'split' fnameescape(dir . 'expected_output_file.txt')
                              exe 'topleft vsplit' fnameescape(dir . 'commands.py')
                              call append('$', "keys(r'\\<C-Down>')")
                              call feedkeys('ggO# ', 'n')
                            endfun "}}}
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#special#commands#qfix(full_line)
                              " Regions to qfix list. {{{1
                              call vm#reset()
                              let qfix = []
                              if a:full_line
                                for line in sort(keys(s:G.lines_with_regions(0)))
                                  call add(qfix, { "bufnr": bufnr(''), "lnum": line, "col": 1, "text": getline(line), "valid":1 })
                                endfor
                              else
                                for r in s:R()
                                  call add(qfix, { "bufnr": bufnr(''), "lnum": r.l, "col": r.a, "text": r.txt, "valid":1 })
                                endfor
                              endif
                              call setqflist(qfix)
                              copen
                              cc
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#special#commands#show_registers(delete, args) abort
                              " Show VM registers in the command line. {{{1
                              if a:delete
                                if a:args != ''
                                  " don't delete " or - registers, they are reset anyway at VM restart
                                  if a:args != '"' && a:args != '-'
                                    silent! unlet g:Vm.registers[a:args]
                                  endif
                                else
                                  let g:Vm.registers = {'"': [], '-': []}
                                endif
                                return
                              elseif a:args != ''
                                if !has_key(g:Vm.registers, a:args)
                                  echo '[visual-multi] invalid register'
                                  return
                                else
                                  let registers = [a:args]
                                endif
                              else
                                let registers = keys(g:Vm.registers)
                              endif
                            
                              echohl Label | echo " Register\tLine\t--- Register contents ---" | echohl None
                            
                              for r in registers
                                "skip temporary register
                                if r == '§' | continue | endif
                            
                                echohl Directory  | echo "\n    ".r
                                let l = 1
                                for s in g:Vm.registers[r]
                                  echohl WarningMsg | echo "\t\t".l."\t"
                                  echohl None  | echon s
                                  let l += 1
                                endfor
                              endfor
                              echohl None
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#special#commands#search(bang, l1, l2, pattern) abort
                              " Search pattern in range. {{{1
                              let just_started = !exists('b:visual_multi')
                              let pat = a:pattern != '' ? a:pattern : @/
                              let pos = getcurpos()[1:2]
                              let view = winsaveview()
                              try
                                call vm#init_buffer(1)
                                let g:Vm.extend_mode = 1
                                if search(pat, 'n')
                                  if just_started
                                    call s:V.Search.get_slash_reg(pat)
                                  else
                                    call s:V.Search.add(pat)
                                  endif
                                else
                                  throw 'not found'
                                endif
                                if a:bang
                                  let r = vm#commands#find_next(0, 0)
                                elseif a:l1 == 1 && a:l2 == line('$')
                                  call vm#commands#find_next(0, 0)
                                  let r = vm#commands#find_all(0, 0)
                                else
                                  let start = line2byte(a:l1)
                                  let end = line2byte(a:l2) + col([a:l2, '$']) - 1
                                  let r = s:G.get_all_regions(start, end)
                                endif
                                call vm#commands#reset_direction(1)
                                call winrestview(view)
                                call s:G.select_region_at_pos([r.l, r.a])
                              catch
                                if just_started
                                  VMClear
                                endif
                                call setpos('.', pos)
                                call winrestview(view)
                                redraw
                                echo '[visual multi] pattern not found'
                                if !just_started
                                  call s:G.select_region_at_pos('.')
                                endif
                              endtry
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! vm#special#commands#sort(...) abort
                              " Sort regions. {{{1
                              if a:0
                                call s:V.Edit.replace_regions_with_text(sort(s:G.regions_text(), a:1))
                              else
                                call s:V.Edit.replace_regions_with_text(sort(s:G.regions_text()))
                              endif
                            endfun "}}}
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001 fun! vm#special#commands#live()
                              " Toggle live editing {{{1
                              let g:VM_live_editing = !get(g:, 'VM_live_editing', 1)
                              let active = g:VM_live_editing ? 'active' : 'inactive'
                              echo '[VM] live editing is' active
                            endfun "}}}
                            
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Initializations and helpers
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
    1              0.000001 fun! vm#special#commands#init() abort
                              " Initialize {{{1
                              let s:V = b:VM_Selection
                              let s:F = s:V.Funcs
                              let s:G = s:V.Global
                              call s:set_commands()
                            endfun
                            
                            
    1              0.000002 fun! s:set_commands() abort
                              command! -buffer -bang -nargs=? VMFilterRegions call vm#special#commands#filter_regions(<bang>0, <q-args>, empty(<q-args>))
                              command! -buffer VMFilterLines                  call vm#special#commands#filter_lines()
                              command! -buffer VMRegionsToBuffer              call vm#special#commands#regions_to_buffer()
                              command! -buffer VMMassTranspose                call vm#special#commands#mass_transpose()
                              command! -buffer -bang VMQfix                   call vm#special#commands#qfix(!<bang>0)
                              command! -buffer -nargs=? VMSort                call vm#special#commands#sort(<args>)
                            endfun "}}}
                            
                            
    1              0.000001 fun! vm#special#commands#unset()
                              " Unset buffer commands. {{{1
                              delcommand VMFilterRegions
                              delcommand VMFilterLines
                              delcommand VMRegionsToBuffer
                              delcommand VMMassTranspose
                              delcommand VMQfix
                              delcommand VMSort
                            endfun "}}}
                            
                            
    1              0.000002 fun! s:temp_buffer() abort
                              " {{{1
                              setlocal buftype=acwrite
                              setlocal bufhidden=wipe
                              setlocal noswapfile
                              setlocal nobuflisted
                              setlocal nomodified
                              let b:VM_buf = s:buf
                            endfun "}}}
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000002 fun! vm#special#commands#deprecated(cmd) abort
                              let cmds = {'VMFromSearch': 'VMSearch'}
                              echohl WarningMsg
                              echo '[visual-multi]' a:cmd 'is deprecated, use' cmds[a:cmd] 'instead'
                              echohl None
                            endfun
                            
                            " vim: et sw=2 ts=2 sts=2 fdm=marker

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/markdown.vim
Sourced 2 times
Total time:   0.012627
 Self time:   0.007265

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:     Markdown
                            " Maintainer:   Tim Pope <https://github.com/tpope/vim-markdown>
                            " Last Change:  2022 Oct 13
                            
    2              0.000022 if exists("b:did_ftplugin")
                              finish
    2              0.000011 endif
                            
    2   0.011273   0.005912 runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
                            
    2              0.000019 let s:keepcpo= &cpo
    2              0.000020 set cpo&vim
                            
    2              0.000012 setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=<!--%s-->
    2              0.000020 setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
    2              0.000009 setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^\\s*[-*+]\\s\\+\\\|^\\[^\\ze[^\\]]\\+\\]:\\&^.\\{4\\}
                            
    2              0.000010 if exists('b:undo_ftplugin')
    2              0.000010   let b:undo_ftplugin .= "|setl cms< com< fo< flp< et< ts< sts< sw<"
                            else
                              let b:undo_ftplugin = "setl cms< com< fo< flp< et< ts< sts< sw<"
    2              0.000002 endif
                            
    2              0.000007 if get(g:, 'markdown_recommended_style', 1)
    2              0.000032   setlocal expandtab tabstop=4 softtabstop=4 shiftwidth=4
    2              0.000002 endif
                            
    2              0.000010 if !exists("g:no_plugin_maps") && !exists("g:no_markdown_maps")
    2              0.000024   nnoremap <silent><buffer> [[ :<C-U>call search('\%(^#\{1,5\}\s\+\S\\|^\S.*\n^[=-]\+$\)', "bsW")<CR>
    2              0.000016   nnoremap <silent><buffer> ]] :<C-U>call search('\%(^#\{1,5\}\s\+\S\\|^\S.*\n^[=-]\+$\)', "sW")<CR>
    2              0.000026   xnoremap <silent><buffer> [[ :<C-U>exe "normal! gv"<Bar>call search('\%(^#\{1,5\}\s\+\S\\|^\S.*\n^[=-]\+$\)', "bsW")<CR>
    2              0.000015   xnoremap <silent><buffer> ]] :<C-U>exe "normal! gv"<Bar>call search('\%(^#\{1,5\}\s\+\S\\|^\S.*\n^[=-]\+$\)', "sW")<CR>
    2              0.000009   let b:undo_ftplugin .= '|sil! nunmap <buffer> [[|sil! nunmap <buffer> ]]|sil! xunmap <buffer> [[|sil! xunmap <buffer> ]]'
    2              0.000002 endif
                            
    2              0.000007 function! s:NotCodeBlock(lnum) abort
                              return synIDattr(synID(a:lnum, 1, 1), 'name') !=# 'markdownCode'
                            endfunction
                            
    2              0.000003 function! MarkdownFold() abort
                              let line = getline(v:lnum)
                            
                              if line =~# '^#\+ ' && s:NotCodeBlock(v:lnum)
                                return ">" . match(line, ' ')
                              endif
                            
                              let nextline = getline(v:lnum + 1)
                              if (line =~ '^.\+$') && (nextline =~ '^=\+$') && s:NotCodeBlock(v:lnum + 1)
                                return ">1"
                              endif
                            
                              if (line =~ '^.\+$') && (nextline =~ '^-\+$') && s:NotCodeBlock(v:lnum + 1)
                                return ">2"
                              endif
                            
                              return "="
                            endfunction
                            
    2              0.000005 function! s:HashIndent(lnum) abort
                              let hash_header = matchstr(getline(a:lnum), '^#\{1,6}')
                              if len(hash_header)
                                return hash_header
                              else
                                let nextline = getline(a:lnum + 1)
                                if nextline =~# '^=\+\s*$'
                                  return '#'
                                elseif nextline =~# '^-\+\s*$'
                                  return '##'
                                endif
                              endif
                            endfunction
                            
    2              0.000003 function! MarkdownFoldText() abort
                              let hash_indent = s:HashIndent(v:foldstart)
                              let title = substitute(getline(v:foldstart), '^#\+\s*', '', '')
                              let foldsize = (v:foldend - v:foldstart + 1)
                              let linecount = '['.foldsize.' lines]'
                              return hash_indent.' '.title.' '.linecount
                            endfunction
                            
    2              0.000011 if has("folding") && get(g:, "markdown_folding", 0)
                              setlocal foldexpr=MarkdownFold()
                              setlocal foldmethod=expr
                              setlocal foldtext=MarkdownFoldText()
                              let b:undo_ftplugin .= "|setl foldexpr< foldmethod< foldtext<"
    2              0.000002 endif
                            
    2              0.000025 let &cpo = s:keepcpo
    2              0.000005 unlet s:keepcpo
                            
                            " vim:set sw=2:

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/html.vim
Sourced 2 times
Total time:   0.005330
 Self time:   0.004022

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:		HTML
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Dan Sharp
                            " Last Changed:		2022 Jul 20
                            
    2              0.000023 if exists("b:did_ftplugin")
                              finish
    2              0.000003 endif
    2              0.000012 let b:did_ftplugin = 1
                            
    2              0.000023 let s:save_cpo = &cpo
    2              0.000042 set cpo-=C
                            
    2              0.000013 setlocal matchpairs+=<:>
    2              0.000011 setlocal commentstring=<!--%s-->
    2              0.000011 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
    2              0.000007 let b:undo_ftplugin = "setlocal comments< commentstring< matchpairs<"
                            
    2              0.000010 if get(g:, "ft_html_autocomment", 0)
                              setlocal formatoptions-=t formatoptions+=croql
                              let b:undo_ftplugin ..= " | setlocal formatoptions<"
    2              0.000001 endif
                            
    2              0.000005 if exists('&omnifunc')
    2              0.000012   setlocal omnifunc=htmlcomplete#CompleteTags
    2   0.004022   0.002714   call htmlcomplete#DetectOmniFlavor()
    2              0.000007   let b:undo_ftplugin ..= " | setlocal omnifunc<"
    2              0.000002 endif
                            
                            " HTML: thanks to Johannes Zellner and Benji Fisher.
    2              0.000010 if exists("loaded_matchit") && !exists("b:match_words")
    2              0.000005   let b:match_ignorecase = 1
    2              0.000014   let b:match_words = '<!--:-->,' ..
                            	\	      '<:>,' ..
                            	\	      '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' ..
                            	\	      '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' ..
                            	\	      '<\@<=\([^/!][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
    2              0.000005   let b:html_set_match_words = 1
    2              0.000007   let b:undo_ftplugin ..= " | unlet! b:match_ignorecase b:match_words b:html_set_match_words"
    2              0.000002 endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
    2              0.000018 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let  b:browsefilter = "HTML Files (*.html *.htm)\t*.htm;*.html\n" ..
                            	\		"JavaScript Files (*.js)\t*.js\n" ..
                            	\		"Cascading StyleSheets (*.css)\t*.css\n" ..
                            	\		"All Files (*.*)\t*.*\n"
                              let b:html_set_browsefilter = 1
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter b:html_set_browsefilter"
    2              0.000001 endif
                            
    2              0.000027 let &cpo = s:save_cpo
    2              0.000009 unlet s:save_cpo

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/htmlcomplete.vim
Sourced 1 time
Total time:   0.001003
 Self time:   0.001003

count  total (s)   self (s)
                            " Vim completion script
                            " Language:	HTML and XHTML
                            " Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
                            " Last Change:	2019 Sep 27
                            
                            " Distinguish between HTML versions.
                            " To use with other HTML versions add another "elseif" condition to match
                            " proper DOCTYPE.
    1              0.000005 function! htmlcomplete#DetectOmniFlavor()
                              if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
                              else
                                let b:html_omni_flavor = 'html401t'
                              endif
                              let i = 1
                              let line = ""
                              while i < 10 && i < line("$")
                                let line = getline(i)
                                if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
                                let i += 1
                              endwhile
                              if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! htmlcomplete#CompleteTags(findstart, base)
                              if a:findstart
                                " locate the start of the word
                                let line = getline('.')
                                let start = col('.') - 1
                            	let curline = line('.')
                            	let compl_begin = col('.') - 2
                                while start >= 0 && line[start - 1] =~ '\(\k\|[!:.-]\)'
                            		let start -= 1
                                endwhile
                            	" Handling of entities {{{
                            	if start >= 0 && line[start - 1] =~ '&'
                            		let b:entitiescompl = 1
                            		let b:compl_context = ''
                            		return start
                            	endif
                            	" }}}
                            	" Handling of <style> tag {{{
                            	let stylestart = searchpair('<style\>', '', '<\/style\>', "bnW")
                            	let styleend   = searchpair('<style\>', '', '<\/style\>', "nW")
                            	if stylestart != 0 && styleend != 0
                            		if stylestart <= curline && styleend >= curline
                            			let start = col('.') - 1
                            			let b:csscompl = 1
                            			while start >= 0 && line[start - 1] =~ '\(\k\|-\)'
                            				let start -= 1
                            			endwhile
                            		endif
                            	endif
                            	" }}}
                            	" Handling of <script> tag {{{
                            	let scriptstart = searchpair('<script\>', '', '<\/script\>', "bnW")
                            	let scriptend   = searchpair('<script\>', '', '<\/script\>', "nW")
                            	if scriptstart != 0 && scriptend != 0
                            		if scriptstart <= curline && scriptend >= curline
                            			let start = col('.') - 1
                            			let b:jscompl = 1
                            			let b:jsrange = [scriptstart, scriptend]
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            			" We are inside of <script> tag. But we should also get contents
                            			" of all linked external files and (secondary, less probably) other <script> tags
                            			" This logic could possible be done in separate function - may be
                            			" reused in events scripting (also with option could be reused for
                            			" CSS
                            			let b:js_extfiles = []
                            			let l = line('.')
                            			let c = col('.')
                            			call cursor(1,1)
                            			while search('<\@<=script\>', 'W') && line('.') <= l
                            				if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            					let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            					if filereadable(sname)
                            						let b:js_extfiles += readfile(sname)
                            					endif
                            				endif
                            			endwhile
                            			call cursor(1,1)
                            			let js_scripttags = []
                            			while search('<script\>', 'W') && line('.') < l
                            				if matchstr(getline('.'), '<script[^>]*src') == ''
                            					let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            					let js_scripttags += js_scripttag
                            				endif
                            			endwhile
                            			let b:js_extfiles += js_scripttags
                            			call cursor(l,c)
                            			unlet! l c
                            		endif
                            	endif
                            	" }}}
                            	if !exists("b:csscompl") && !exists("b:jscompl")
                            		let b:compl_context = getline('.')[0:(compl_begin)]
                            		if b:compl_context !~ '<[^>]*$'
                            			" Look like we may have broken tag. Check previous lines.
                            			let i = 1
                            			while 1
                            				let context_line = getline(curline-i)
                            				if context_line =~ '<[^>]*$'
                            					" Yep, this is this line
                            					let context_lines = getline(curline-i, curline-1) + [b:compl_context]
                            					let b:compl_context = join(context_lines, ' ')
                            					break
                            				elseif context_line =~ '>[^<]*$' || i == curline
                            					" We are in normal tag line, no need for completion at all
                            					" OR reached first line without tag at all
                            					let b:compl_context = ''
                            					break
                            				endif
                            				let i += 1
                            			endwhile
                            			" Make sure we don't have counter
                            			unlet! i
                            		endif
                            		let b:compl_context = matchstr(b:compl_context, '.*\zs<.*')
                            
                            		" Return proper start for on-events. Without that beginning of
                            		" completion will be badly reported
                            		if b:compl_context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            		endif
                            		" If b:compl_context begins with <? we are inside of PHP code. It
                            		" wasn't closed so PHP completion passed it to HTML
                            		if &filetype =~? 'php' && b:compl_context =~ '^<?'
                            			let b:phpcompl = 1
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
                            				let start -= 1
                            			endwhile
                            		endif
                            	else
                            		let b:compl_context = getline('.')[0:compl_begin]
                            	endif
                                return start
                              else
                            	" Initialize base return lists
                                let res = []
                                let res2 = []
                            	" a:base is very short - we need context
                            	let context = b:compl_context
                            	" Check if we should do CSS completion inside of <style> tag
                            	" or JS completion inside of <script> tag or PHP completion in case of <?
                            	" tag AND &ft==php
                            	if exists("b:csscompl")
                            		unlet! b:csscompl
                            		let context = b:compl_context
                            		unlet! b:compl_context
                            		return csscomplete#CompleteCSS(0, context)
                            	elseif exists("b:jscompl")
                            		unlet! b:jscompl
                            		return javascriptcomplete#CompleteJS(0, a:base)
                            	elseif exists("b:phpcompl")
                            		unlet! b:phpcompl
                            		let context = b:compl_context
                            		return phpcomplete#CompletePHP(0, a:base)
                            	else
                            		if len(b:compl_context) == 0 && !exists("b:entitiescompl")
                            			return []
                            		endif
                            		let context = matchstr(b:compl_context, '.\zs.*')
                            	endif
                            	unlet! b:compl_context
                            	" Entities completion {{{
                            	if exists("b:entitiescompl")
                            		unlet! b:entitiescompl
                            
                            		if !exists("b:html_doctype")
                            			call htmlcomplete#CheckDoctype()
                            		endif
                            		if !exists("b:html_omni")
                            			"runtime! autoload/xml/xhtml10s.vim
                            			call htmlcomplete#LoadData()
                            		endif
                            
                            	    let entities =  b:html_omni['vimxmlentities']
                            
                            		if len(a:base) == 1
                            			for m in entities
                            				if m =~ '^'.a:base
                            					call add(res, m.';')
                            				endif
                            			endfor
                            			return res
                            		else
                            			for m in entities
                            				if m =~? '^'.a:base
                            					call add(res, m.';')
                            				elseif m =~? a:base
                            					call add(res2, m.';')
                            				endif
                            			endfor
                            
                            			return res + res2
                            		endif
                            
                            
                            	endif
                            	" }}}
                            	if context =~ '>'
                            		" Generally if context contains > it means we are outside of tag and
                            		" should abandon action - with one exception: <style> span { bo
                            		if context =~ 'style[^>]\{-}>[^<]\{-}$'
                            			return csscomplete#CompleteCSS(0, context)
                            		elseif context =~ 'script[^>]\{-}>[^<]\{-}$'
                            			let b:jsrange = [line('.'), search('<\/script\>', 'nW')]
                            			return javascriptcomplete#CompleteJS(0, context)
                            		else
                            			return []
                            		endif
                            	endif
                            
                            	" If context contains > it means we are already outside of tag and we
                            	" should abandon action
                            	" If context contains white space it is attribute.
                            	" It can be also value of attribute.
                            	" We have to get first word to offer proper completions
                            	if context =~ '^\s*$'
                            		" empty or whitespace line
                            		let tag = ''
                            	else
                            		let tag = split(context)[0]
                            		" Detect if tag is uppercase to return in proper case,
                            		" we need to make it lowercase for processing
                            		if tag =~ '^[A-Z]*$'
                            			let uppercase_tag = 1
                            			let tag = tolower(tag)
                            		else
                            			let uppercase_tag = 0
                            		endif
                            	endif
                            	" Get last word, it should be attr name
                            	let attr = matchstr(context, '.*\s\zs.*')
                            	" Possible situations where any prediction would be difficult:
                            	" 1. Events attributes
                            	if context =~ '\s'
                            		" Sort out style, class, and on* cases
                            		if context =~? "\\(on[a-z]*\\|id\\|style\\|class\\)\\s*=\\s*[\"']"
                            			" Id, class completion {{{
                            			if context =~? "\\(id\\|class\\)\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            				if context =~? "class\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            					let search_for = "class"
                            				elseif context =~? "id\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            					let search_for = "id"
                            				endif
                            				" Handle class name completion
                            				" 1. Find lines of <link stylesheet>
                            				" 1a. Check file for @import
                            				" 2. Extract filename(s?) of stylesheet,
                            				call cursor(1,1)
                            				let head = getline(search('<head\>'), search('<\/head>'))
                            				let headjoined = join(copy(head), ' ')
                            				if headjoined =~ '<style'
                            					" Remove possibly confusing CSS operators
                            					let stylehead = substitute(headjoined, '+>\*[,', ' ', 'g')
                            					if search_for == 'class'
                            						let styleheadlines = split(stylehead)
                            						let headclasslines = filter(copy(styleheadlines), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            					else
                            						let stylesheet = split(headjoined, '[{}]')
                            						" Get all lines which fit id syntax
                            						let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            						" Filter out possible color definitions
                            						call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            						" Filter out complex border definitions
                            						call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            						let templines = join(classlines, ' ')
                            						let headclasslines = split(templines)
                            						call filter(headclasslines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            					endif
                            					let internal = 1
                            				else
                            					let internal = 0
                            				endif
                            				let styletable = []
                            				let secimportfiles = []
                            				let filestable = filter(copy(head), "v:val =~ '\\(@import\\|link.*stylesheet\\)'")
                            				for line in filestable
                            					if line =~ "@import"
                            						let styletable += [matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")]
                            					elseif line =~ "<link"
                            						let styletable += [matchstr(line, "href\\s*=\\s*[\"']\\zs\\f\\+\\ze")]
                            					endif
                            				endfor
                            				for file in styletable
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let secimport = filter(copy(stylesheet), "v:val =~ '@import'")
                            						if len(secimport) > 0
                            							for line in secimport
                            								let secfile = matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")
                            								let secfile = fnamemodify(file, ":p:h").'/'.secfile
                            								let secimportfiles += [secfile]
                            							endfor
                            						endif
                            					endif
                            				endfor
                            				let cssfiles = styletable + secimportfiles
                            				let classes = []
                            				for file in cssfiles
                            				  	let classlines = []
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let stylefile = join(stylesheet, ' ')
                            						let stylefile = substitute(stylefile, '+>\*[,', ' ', 'g')
                            						if search_for == 'class'
                            							let stylesheet = split(stylefile)
                            							let classlines = filter(copy(stylesheet), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            						else
                            							let stylesheet = split(stylefile, '[{}]')
                            							" Get all lines which fit id syntax
                            							let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            							" Filter out possible color definitions
                            							call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            							" Filter out complex border definitions
                            							call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            							let templines = join(classlines, ' ')
                            							let stylelines = split(templines)
                            							let classlines = filter(stylelines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            
                            						endif
                            					endif
                            					" We gathered classes definitions from all external files
                            					let classes += classlines
                            				endfor
                            				if internal == 1
                            					let classes += headclasslines
                            				endif
                            
                            				if search_for == 'class'
                            					let elements = {}
                            					for element in classes
                            						if element =~ '^\.'
                            							let class = matchstr(element, '^\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let class = substitute(class, ':.*', '', '')
                            							if has_key(elements, 'common')
                            								let elements['common'] .= ' '.class
                            							else
                            								let elements['common'] = class
                            							endif
                            						else
                            							let class = matchstr(element, '[a-zA-Z1-6]*\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let tagname = tolower(matchstr(element, '[a-zA-Z1-6]*\ze.'))
                            							if tagname != ''
                            								if has_key(elements, tagname)
                            									let elements[tagname] .= ' '.class
                            								else
                            									let elements[tagname] = class
                            								endif
                            							endif
                            						endif
                            					endfor
                            
                            					if has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements[tag]." ".elements['common'])
                            					elseif has_key(elements, tag) && !has_key(elements, 'common')
                            						let values = split(elements[tag])
                            					elseif !has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements['common'])
                            					else
                            						return []
                            					endif
                            
                            				elseif search_for == 'id'
                            					" Find used IDs
                            					" 1. Catch whole file
                            					let filelines = getline(1, line('$'))
                            					" 2. Find lines with possible id
                            					let used_id_lines = filter(filelines, 'v:val =~ "id\\s*=\\s*[\"''][a-zA-Z0-9_-]\\+"')
                            					" 3a. Join all filtered lines
                            					let id_string = join(used_id_lines, ' ')
                            					" 3b. And split them to be sure each id is in separate item
                            					let id_list = split(id_string, 'id\s*=\s*')
                            					" 4. Extract id values
                            					let used_id = map(id_list, 'matchstr(v:val, "[\"'']\\zs[a-zA-Z0-9_-]\\+\\ze")')
                            					let joined_used_id = ','.join(used_id, ',').','
                            
                            					let allvalues = map(classes, 'matchstr(v:val, ".*#\\zs[a-zA-Z0-9_-]\\+")')
                            
                            					let values = []
                            
                            					for element in classes
                            						if joined_used_id !~ ','.element.','
                            							let values += [element]
                            						endif
                            
                            					endfor
                            
                            				endif
                            
                            				" We need special version of sbase
                            				let classbase = matchstr(context, ".*[\"']")
                            				let classquote = matchstr(classbase, '.$')
                            
                            				let entered_class = matchstr(attr, ".*=\\s*[\"']\\zs.*")
                            
                            				for m in sort(values)
                            					if m =~? '^'.entered_class
                            						call add(res, m . classquote)
                            					elseif m =~? entered_class
                            						call add(res2, m . classquote)
                            					endif
                            				endfor
                            
                            				return res + res2
                            
                            			elseif context =~? "style\\s*=\\s*[\"'][^\"']*$"
                            				return csscomplete#CompleteCSS(0, context)
                            
                            			endif
                            			" }}}
                            			" Complete on-events {{{
                            			if context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            				" We have to:
                            				" 1. Find external files
                            				let b:js_extfiles = []
                            				let l = line('.')
                            				let c = col('.')
                            				call cursor(1,1)
                            				while search('<\@<=script\>', 'W') && line('.') <= l
                            					if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            						let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            						if filereadable(sname)
                            							let b:js_extfiles += readfile(sname)
                            						endif
                            					endif
                            				endwhile
                            				" 2. Find at least one <script> tag
                            				call cursor(1,1)
                            				let js_scripttags = []
                            				while search('<script\>', 'W') && line('.') < l
                            					if matchstr(getline('.'), '<script[^>]*src') == ''
                            						let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            						let js_scripttags += js_scripttag
                            					endif
                            				endwhile
                            				let b:js_extfiles += js_scripttags
                            
                            				" 3. Proper call for javascriptcomplete#CompleteJS
                            				call cursor(l,c)
                            				let js_context = matchstr(a:base, '\k\+$')
                            				let js_shortcontext = substitute(a:base, js_context.'$', '', '')
                            				let b:compl_context = context
                            				let b:jsrange = [l, l]
                            				unlet! l c
                            				return javascriptcomplete#CompleteJS(0, js_context)
                            
                            			endif
                            
                            			" }}}
                            			let stripbase = matchstr(context, ".*\\(on[a-zA-Z]*\\|style\\|class\\)\\s*=\\s*[\"']\\zs.*")
                            			" Now we have context stripped from all chars up to style/class.
                            			" It may fail with some strange style value combinations.
                            			if stripbase !~ "[\"']"
                            				return []
                            			endif
                            		endif
                            		" Value of attribute completion {{{
                            		" If attr contains =\s*[\"'] we match value of attribute
                            		if attr =~ "=\s*[\"']" || attr =~ "=\s*$"
                            			" Let do attribute specific completion
                            			let attrname = matchstr(attr, '.*\ze\s*=')
                            			let entered_value = matchstr(attr, ".*=\\s*[\"']\\?\\zs.*")
                            			let values = []
                            			" Load data {{{
                            			if !exists("b:html_doctype")
                            				call htmlcomplete#CheckDoctype()
                            			endif
                            			if !exists("b:html_omni")
                            				"runtime! autoload/xml/xhtml10s.vim
                            				call htmlcomplete#LoadData()
                            			endif
                            			" }}}
                            			if attrname == 'href'
                            				" Now we are looking for local anchors defined by name or id
                            				if entered_value =~ '^#'
                            					let file = join(getline(1, line('$')), ' ')
                            					" Split it be sure there will be one id/name element in
                            					" item, it will be also first word [a-zA-Z0-9_-] in element
                            					let oneelement = split(file, "\\(meta \\)\\@<!\\(name\\|id\\)\\s*=\\s*[\"']")
                            					for i in oneelement
                            						let values += ['#'.matchstr(i, "^[a-zA-Z][a-zA-Z0-9%_-]*")]
                            					endfor
                            				endif
                            			else
                            				if has_key(b:html_omni, tag) && has_key(b:html_omni[tag][1], attrname)
                            					let values = b:html_omni[tag][1][attrname]
                            				else
                            					return []
                            				endif
                            			endif
                            
                            			if len(values) == 0
                            				return []
                            			endif
                            
                            			" We need special version of sbase
                            			let attrbase = matchstr(context, ".*[\"']")
                            			let attrquote = matchstr(attrbase, '.$')
                            			if attrquote !~ "['\"]"
                            				let attrquoteopen = '"'
                            				let attrquote = '"'
                            			else
                            				let attrquoteopen = ''
                            			endif
                            
                            			for m in values
                            				" This if is needed to not offer all completions as-is
                            				" alphabetically but sort them. Those beginning with entered
                            				" part will be as first choices
                            				if m =~ '^'.entered_value
                            					call add(res, attrquoteopen . m . attrquote)
                            				elseif m =~ entered_value
                            					call add(res2, attrquoteopen . m . attrquote)
                            				endif
                            			endfor
                            
                            			return res + res2
                            
                            		endif
                            		" }}}
                            		" Attribute completion {{{
                            		" Shorten context to not include last word
                            		let sbase = matchstr(context, '.*\ze\s.*')
                            
                            		" Load data {{{
                            		if !exists("b:html_doctype")
                            			call htmlcomplete#CheckDoctype()
                            		endif
                            		if !exists("b:html_omni")
                            			call htmlcomplete#LoadData()
                            		endif
                            		" }}}
                            
                            		if has_key(b:html_omni, tag)
                            			let attrs = keys(b:html_omni[tag][1])
                            		else
                            			return []
                            		endif
                            
                            		for m in sort(attrs)
                            			if m =~ '^'.attr
                            				call add(res, m)
                            			elseif m =~ attr
                            				call add(res2, m)
                            			endif
                            		endfor
                            		let menu = res + res2
                            		if has_key(b:html_omni, 'vimxmlattrinfo')
                            			let final_menu = []
                            			for i in range(len(menu))
                            				let item = menu[i]
                            				if has_key(b:html_omni['vimxmlattrinfo'], item)
                            					let m_menu = b:html_omni['vimxmlattrinfo'][item][0]
                            					let m_info = b:html_omni['vimxmlattrinfo'][item][1]
                            				else
                            					let m_menu = ''
                            					let m_info = ''
                            				endif
                            				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            					let m_menu = 'Bool'
                            				else
                            					let item .= '="'
                            				endif
                            				let final_menu += [{'word':item, 'menu':m_menu, 'info':m_info}]
                            			endfor
                            		else
                            			let final_menu = []
                            			for i in range(len(menu))
                            				let item = menu[i]
                            				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            				else
                            					let item .= '="'
                            				endif
                            				let final_menu += [item]
                            			endfor
                            			return final_menu
                            
                            		endif
                            		return final_menu
                            
                            	endif
                            	" }}}
                            	" Close tag {{{
                            	let b:unaryTagsStack = "base meta link hr br param img area input col"
                            	if context =~ '^\/'
                            		if context =~ '^\/.'
                            			return []
                            		else
                            			let opentag = xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
                            			return [opentag.">"]
                            		endif
                            	endif
                            	" }}}
                            	" Load data {{{
                            	if !exists("b:html_doctype")
                            		call htmlcomplete#CheckDoctype()
                            	endif
                            	if !exists("b:html_omni")
                            		"runtime! autoload/xml/xhtml10s.vim
                            		call htmlcomplete#LoadData()
                            	endif
                            	" }}}
                            	" Tag completion {{{
                            	" Deal with tag completion.
                            	let opentag = tolower(xmlcomplete#GetLastOpenTag("b:unaryTagsStack"))
                            	" MM: TODO: GLOT works always the same but with some weird situation it
                            	" behaves as intended in HTML but screws in PHP
                            	if opentag == '' || &filetype == 'php' && !has_key(b:html_omni, opentag)
                            		" Hack for sometimes failing GetLastOpenTag.
                            		" As far as I tested fail isn't GLOT fault but problem
                            		" of invalid document - not properly closed tags and other mish-mash.
                            		" Also when document is empty. Return list of *all* tags.
                            	    let tags = keys(b:html_omni)
                            		call filter(tags, 'v:val !~ "^vimxml"')
                            	else
                            		if has_key(b:html_omni, opentag)
                            			let tags = b:html_omni[opentag][0]
                            		else
                            			return []
                            		endif
                            	endif
                            	" }}}
                            
                            	if exists("uppercase_tag") && uppercase_tag == 1
                            		let context = tolower(context)
                            	endif
                            	" Handle XML keywords: DOCTYPE
                            	if opentag == ''
                            		let tags += [
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">'
                            				\ ]
                            	endif
                            
                            	for m in sort(tags)
                            		if m =~ '^'.context
                            			call add(res, m)
                            		elseif m =~ context
                            			call add(res2, m)
                            		endif
                            	endfor
                            	let menu = res + res2
                            	if has_key(b:html_omni, 'vimxmltaginfo')
                            		let final_menu = []
                            		for i in range(len(menu))
                            			let item = menu[i]
                            			if has_key(b:html_omni['vimxmltaginfo'], item)
                            				let m_menu = b:html_omni['vimxmltaginfo'][item][0]
                            				let m_info = b:html_omni['vimxmltaginfo'][item][1]
                            			else
                            				let m_menu = ''
                            				let m_info = ''
                            			endif
                            			if &filetype == 'html' && exists("uppercase_tag") && uppercase_tag == 1 && item !~ 'DOCTYPE'
                            				let item = toupper(item)
                            			endif
                            			if item =~ 'DOCTYPE'
                            				let abbr = 'DOCTYPE '.matchstr(item, 'DTD \zsX\?HTML .\{-}\ze\/\/')
                            			else
                            				let abbr = item
                            			endif
                            			let final_menu += [{'abbr':abbr, 'word':item, 'menu':m_menu, 'info':m_info}]
                            		endfor
                            	else
                            		let final_menu = menu
                            	endif
                            	return final_menu
                            
                            	" }}}
                              endif
                            endfunction
                            
    1              0.000002 function! htmlcomplete#LoadData() " {{{
                            	if !exists("b:html_omni_flavor")
                            		if &filetype == 'html'
                            			let b:html_omni_flavor = 'html401t'
                            		else
                            			let b:html_omni_flavor = 'xhtml10s'
                            		endif
                            	endif
                            	" With that if we still have bloated memory but create new buffer
                            	" variables only by linking to existing g:variable, not sourcing whole
                            	" file.
                            	if exists('g:xmldata_'.b:html_omni_flavor)
                            		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            	else
                            		exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
                            		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            	endif
                            endfunction
                            " }}}
    1              0.000002 function! htmlcomplete#CheckDoctype() " {{{
                            	if exists('b:html_omni_flavor')
                            		let old_flavor = b:html_omni_flavor
                            	else
                            		let old_flavor = ''
                            	endif
                            	let i = 1
                            	while i < 10 && i < line("$")
                            		let line = getline(i)
                            		if line =~ '<!DOCTYPE.*\<DTD HTML 3\.2'
                            			let b:html_omni_flavor = 'html32'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Transitional'
                            			let b:html_omni_flavor = 'html40t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Frameset'
                            			let b:html_omni_flavor = 'html40f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0'
                            			let b:html_omni_flavor = 'html40s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Transitional'
                            			let b:html_omni_flavor = 'html401t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Frameset'
                            			let b:html_omni_flavor = 'html401f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01'
                            			let b:html_omni_flavor = 'html401s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Transitional'
                            			let b:html_omni_flavor = 'xhtml10t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Frameset'
                            			let b:html_omni_flavor = 'xhtml10f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Strict'
                            			let b:html_omni_flavor = 'xhtml10s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.1'
                            			let b:html_omni_flavor = 'xhtml11'
                            			let b:html_doctype = 1
                            			break
                            		endif
                            		let i += 1
                            	endwhile
                            	if !exists("b:html_doctype")
                            		return
                            	else
                            		" Tie g:xmldata with b:html_omni this way we need to sourca data file only
                            		" once, not every time per buffer.
                            		if old_flavor == b:html_omni_flavor
                            			return
                            		else
                            			if exists('g:xmldata_'.b:html_omni_flavor)
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			else
                            				exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			endif
                            			return
                            		endif
                            	endif
                            endfunction
                            " }}}
                            " vim:set foldmethod=marker:

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/ruby.vim
Sourced 1 time
Total time:   0.035228
 Self time:   0.004131

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Ruby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:		2022 Mar 21
                            
    1              0.000017 if (exists("b:did_ftplugin"))
                              finish
    1              0.000002 endif
    1              0.000008 let b:did_ftplugin = 1
                            
    1              0.000020 let s:cpo_save = &cpo
    1              0.000032 set cpo&vim
                            
    1              0.000014 if has("gui_running") && !has("gui_win32")
                              setlocal keywordprg=ri\ -T\ -f\ bs
    1              0.000002 else
    1              0.000012   setlocal keywordprg=ri
    1              0.000003 endif
                            
                            " Matchit support
    1              0.000010 if exists("loaded_matchit") && !exists("b:match_words")
    1              0.000006   let b:match_ignorecase = 0
                            
    1              0.000020   let b:match_words =
                            	\ '{\|\<\%(if\|unless\|case\|while\|until\|for\|do\|class\|module\|def\|=\@<!begin\)\>=\@!' .
                            	\ ':' .
                            	\ '\<\%(else\|elsif\|ensure\|when\|rescue\|break\|redo\|next\|retry\)\>' .
                            	\ ':' .
                                    \ '}\|\%(^\|[^.\:@$=]\)\@<=\<end\:\@!\>' .
                                    \ ',^=begin\>:^=end\>,' .
                            	\ ',\[:\],(:)'
                            
    1              0.000021   let b:match_skip =
                            	\ "synIDattr(synID(line('.'),col('.'),0),'name') =~ '" .
                            	\ "\\<ruby\\%(String\\|.\+Delimiter\\|Character\\|.\+Escape\\|" .
                                    \ "Regexp\\|Interpolation\\|Comment\\|Documentation\\|" .
                            	\ "ConditionalModifier\\|RepeatModifier\\|RescueModifier\\|OptionalDo\\|" .
                            	\ "MethodName\\|BlockArgument\\|KeywordAsMethod\\|ClassVariable\\|" .
                            	\ "InstanceVariable\\|GlobalVariable\\|Symbol\\)\\>'"
    1              0.000002 endif
                            
    1              0.000014 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000009 setlocal include=^\\s*\\<\\(load\\>\\\|require\\>\\\|autoload\\s*:\\=[\"']\\=\\h\\w*[\"']\\=,\\)
    1              0.000010 setlocal suffixesadd=.rb
                            
    1   0.003506   0.001073 if exists("&ofu") && has("ruby")
                              setlocal omnifunc=rubycomplete#Complete
    1              0.000002 endif
                            
                            " TODO:
                            "setlocal define=^\\s*def
                            
    1              0.000013 setlocal comments=b:#
    1              0.000009 setlocal commentstring=#\ %s
                            
    1              0.000008 if !exists('g:ruby_version_paths')
    1              0.000007   let g:ruby_version_paths = {}
    1              0.000002 endif
                            
    1              0.000007 function! s:query_path(root) abort
                              let code = "print $:.join %q{,}"
                              if &shell =~# 'sh' && empty(&shellxquote)
                                let prefix = 'env PATH='.shellescape($PATH).' '
                              else
                                let prefix = ''
                              endif
                              if &shellxquote == "'"
                                let path_check = prefix.'ruby --disable-gems -e "' . code . '"'
                              else
                                let path_check = prefix."ruby --disable-gems -e '" . code . "'"
                              endif
                            
                              let cd = haslocaldir() ? 'lcd' : 'cd'
                              let cwd = fnameescape(getcwd())
                              try
                                exe cd fnameescape(a:root)
                                let path = split(system(path_check),',')
                                exe cd cwd
                                return path
                              finally
                                exe cd cwd
                              endtry
                            endfunction
                            
    1              0.000005 function! s:build_path(path) abort
                              let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
                              if &g:path =~# '\v^%(\.,)=%(/%(usr|emx)/include,)=,$'
                                let path = path . ',.,,'
                              elseif &g:path =~# ',\.,,$'
                                let path = &g:path[0:-4] . path . ',.,,'
                              elseif &g:path =~# ',,$'
                                let path = &g:path[0:-2] . path . ',,'
                              else
                                let path = substitute(&g:path, '[^,]\zs$', ',', '') . path
                              endif
                              return path
                            endfunction
                            
    1              0.000049 if !exists('b:ruby_version') && !exists('g:ruby_path') && isdirectory(expand('%:p:h'))
    1              0.000333   let s:version_file = findfile('.ruby-version', '.;')
    1              0.000010   if !empty(s:version_file) && filereadable(s:version_file)
                                let b:ruby_version = get(readfile(s:version_file, '', 1), '')
                                if !has_key(g:ruby_version_paths, b:ruby_version)
                                  let g:ruby_version_paths[b:ruby_version] = s:query_path(fnamemodify(s:version_file, ':p:h'))
                                endif
    1              0.000002   endif
    1              0.000001 endif
                            
    1              0.000006 if exists("g:ruby_path")
                              let s:ruby_path = type(g:ruby_path) == type([]) ? join(g:ruby_path, ',') : g:ruby_path
    1              0.000010 elseif has_key(g:ruby_version_paths, get(b:, 'ruby_version', ''))
                              let s:ruby_paths = g:ruby_version_paths[b:ruby_version]
                              let s:ruby_path = s:build_path(s:ruby_paths)
    1              0.000002 else
    1              0.000005   if !exists('g:ruby_default_path')
    1              0.000012     if has("ruby") && has("win32")
                                  ruby ::VIM::command( 'let g:ruby_default_path = split("%s",",")' % $:.join(%q{,}) )
    1              0.000076     elseif executable('ruby') && !empty($HOME)
    1   0.027758   0.000043       let g:ruby_default_path = s:query_path($HOME)
                                else
                                  let g:ruby_default_path = map(split($RUBYLIB,':'), 'v:val ==# "." ? "" : v:val')
    1              0.000001     endif
    1              0.000001   endif
    1              0.000005   let s:ruby_paths = g:ruby_default_path
    1   0.000149   0.000030   let s:ruby_path = s:build_path(s:ruby_paths)
    1              0.000002 endif
                            
    1              0.000006 if stridx(&l:path, s:ruby_path) == -1
    1              0.000015   let &l:path = s:ruby_path
    1              0.000001 endif
    1              0.000047 if exists('s:ruby_paths') && stridx(&l:tags, join(map(copy(s:ruby_paths),'v:val."/tags"'),',')) == -1
    1              0.000027   let &l:tags = &tags . ',' . join(map(copy(s:ruby_paths),'v:val."/tags"'),',')
    1              0.000002 endif
                            
    1              0.000012 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Ruby Source Files (*.rb)\t*.rb\n" .
                                                 \ "All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
    1              0.000009 let b:undo_ftplugin = "setl inc= sua= path= tags= fo< com< cms< kp="
                                  \."| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"
                                  \."| if exists('&ofu') && has('ruby') | setl ofu< | endif"
                            
    1              0.000005 if get(g:, 'ruby_recommended_style', 1)
    1              0.000021   setlocal shiftwidth=2 softtabstop=2 expandtab
    1              0.000008   let b:undo_ftplugin .= ' | setl sw< sts< et<'
    1              0.000001 endif
                            
                            " To activate, :set ballooneval
    1              0.000018 if exists('+balloonexpr') && get(g:, 'ruby_balloonexpr')
                              setlocal balloonexpr=RubyBalloonexpr()
                              let b:undo_ftplugin .= "| setl bexpr="
    1              0.000001 endif
                            
    1              0.000006 function! s:map(mode, flags, map) abort
                              let from = matchstr(a:map, '\S\+')
                              if empty(mapcheck(from, a:mode))
                                exe a:mode.'map' '<buffer>' a:flags a:map
                                let b:undo_ftplugin .= '|sil! '.a:mode.'unmap <buffer> '.from
                              endif
                            endfunction
                            
    1              0.000022 cmap <buffer><script><expr> <Plug><ctag> substitute(RubyCursorTag(),'^$',"\022\027",'')
    1              0.000013 cmap <buffer><script><expr> <Plug><cfile> substitute(RubyCursorFile(),'^$',"\022\006",'')
    1              0.000007 let b:undo_ftplugin .= "| sil! cunmap <buffer> <Plug><ctag>| sil! cunmap <buffer> <Plug><cfile>"
                            
    1              0.000006 if !exists("g:no_plugin_maps") && !exists("g:no_ruby_maps")
    1              0.000005   nmap <buffer><script> <SID>:  :<C-U>
    1              0.000008   nmap <buffer><script> <SID>c: :<C-U><C-R>=v:count ? v:count : ''<CR>
    1              0.000008   cmap <buffer> <SID><cfile> <Plug><cfile>
    1              0.000010   cmap <buffer> <SID><ctag>  <Plug><ctag>
                            
    1              0.000012   nnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'b','n')<CR>
    1              0.000010   nnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'','n')<CR>
    1              0.000009   nnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'b','n')<CR>
    1              0.000009   nnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'','n')<CR>
    1              0.000010   xnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'b','v')<CR>
    1              0.000009   xnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>',['rubyDefine'],'','v')<CR>
    1              0.000015   xnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'b','v')<CR>
    1              0.000009   xnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>',['rubyDefine'],'','v')<CR>
                            
    1              0.000014   nnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'b','n')<CR>
    1              0.000011   nnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'','n')<CR>
    1              0.000011   nnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'b','n')<CR>
    1              0.000008   nnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'','n')<CR>
    1              0.000012   xnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'b','v')<CR>
    1              0.000012   xnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>',['rubyModule','rubyClass'],'','v')<CR>
    1              0.000017   xnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'b','v')<CR>
    1              0.000009   xnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>',['rubyModule','rubyClass'],'','v')<CR>
                            
    1              0.000012   let b:undo_ftplugin = b:undo_ftplugin
                                    \."| sil! exe 'unmap <buffer> [[' | sil! exe 'unmap <buffer> ]]' | sil! exe 'unmap <buffer> []' | sil! exe 'unmap <buffer> ]['"
                                    \."| sil! exe 'unmap <buffer> [m' | sil! exe 'unmap <buffer> ]m' | sil! exe 'unmap <buffer> [M' | sil! exe 'unmap <buffer> ]M'"
                            
    1              0.000058   if maparg('im','x') == '' && maparg('im','o') == '' && maparg('am','x') == '' && maparg('am','o') == ''
    1              0.000010     onoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    1              0.000008     onoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    1              0.000006     xnoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    1              0.000007     xnoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    1              0.000020     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> im' | sil! exe 'ounmap <buffer> am'"
                                      \."| sil! exe 'xunmap <buffer> im' | sil! exe 'xunmap <buffer> am'"
    1              0.000001   endif
                            
    1              0.000038   if maparg('iM','x') == '' && maparg('iM','o') == '' && maparg('aM','x') == '' && maparg('aM','o') == ''
    1              0.000009     onoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    1              0.000007     onoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    1              0.000008     xnoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    1              0.000006     xnoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    1              0.000013     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> iM' | sil! exe 'ounmap <buffer> aM'"
                                      \."| sil! exe 'xunmap <buffer> iM' | sil! exe 'xunmap <buffer> aM'"
    1              0.000001   endif
                            
    1   0.000082   0.000019   call s:map('c', '', '<C-R><C-F> <Plug><cfile>')
                            
    1              0.000007   cmap <buffer><script><expr> <SID>tagzv &foldopen =~# 'tag' ? '<Bar>norm! zv' : ''
    1   0.000083   0.000015   call s:map('n', '<script><silent>', '<C-]>       <SID>:exe  v:count1."tag <SID><ctag>"<SID>tagzv<CR>')
    1   0.000074   0.000012   call s:map('n', '<script><silent>', 'g<C-]>      <SID>:exe         "tjump <SID><ctag>"<SID>tagzv<CR>')
    1   0.000066   0.000013   call s:map('n', '<script><silent>', 'g]          <SID>:exe       "tselect <SID><ctag>"<SID>tagzv<CR>')
    1   0.000079   0.000013   call s:map('n', '<script><silent>', '<C-W>]      <SID>:exe v:count1."stag <SID><ctag>"<SID>tagzv<CR>')
    1   0.000084   0.000013   call s:map('n', '<script><silent>', '<C-W><C-]>  <SID>:exe v:count1."stag <SID><ctag>"<SID>tagzv<CR>')
    1   0.000089   0.000013   call s:map('n', '<script><silent>', '<C-W>g<C-]> <SID>:exe        "stjump <SID><ctag>"<SID>tagzv<CR>')
    1   0.000072   0.000014   call s:map('n', '<script><silent>', '<C-W>g]     <SID>:exe      "stselect <SID><ctag>"<SID>tagzv<CR>')
    1   0.000069   0.000011   call s:map('n', '<script><silent>', '<C-W>}      <SID>:exe v:count1."ptag <SID><ctag>"<CR>')
    1   0.000067   0.000012   call s:map('n', '<script><silent>', '<C-W>g}     <SID>:exe        "ptjump <SID><ctag>"<CR>')
                            
    1   0.000055   0.000010   call s:map('n', '<script><silent>', 'gf           <SID>c:find <SID><cfile><CR>')
    1   0.000060   0.000011   call s:map('n', '<script><silent>', '<C-W>f      <SID>c:sfind <SID><cfile><CR>')
    1   0.000061   0.000010   call s:map('n', '<script><silent>', '<C-W><C-F>  <SID>c:sfind <SID><cfile><CR>')
    1   0.000065   0.000010   call s:map('n', '<script><silent>', '<C-W>gf   <SID>c:tabfind <SID><cfile><CR>')
    1              0.000001 endif
                            
    1              0.000019 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save
                            
    1              0.000005 if exists("g:did_ruby_ftplugin_functions")
                              finish
    1              0.000001 endif
    1              0.000003 let g:did_ruby_ftplugin_functions = 1
                            
    1              0.000003 function! RubyBalloonexpr() abort
                              if !exists('s:ri_found')
                                let s:ri_found = executable('ri')
                              endif
                              if s:ri_found
                                let line = getline(v:beval_lnum)
                                let b = matchstr(strpart(line,0,v:beval_col),'\%(\w\|[:.]\)*$')
                                let a = substitute(matchstr(strpart(line,v:beval_col),'^\w*\%([?!]\|\s*=\)\?'),'\s\+','','g')
                                let str = b.a
                                let before = strpart(line,0,v:beval_col-strlen(b))
                                let after  = strpart(line,v:beval_col+strlen(a))
                                if str =~ '^\.'
                                  let str = substitute(str,'^\.','#','g')
                                  if before =~ '\]\s*$'
                                    let str = 'Array'.str
                                  elseif before =~ '}\s*$'
                                    " False positives from blocks here
                                    let str = 'Hash'.str
                                  elseif before =~ "[\"'`]\\s*$" || before =~ '\$\d\+\s*$'
                                    let str = 'String'.str
                                  elseif before =~ '\$\d\+\.\d\+\s*$'
                                    let str = 'Float'.str
                                  elseif before =~ '\$\d\+\s*$'
                                    let str = 'Integer'.str
                                  elseif before =~ '/\s*$'
                                    let str = 'Regexp'.str
                                  else
                                    let str = substitute(str,'^#','.','')
                                  endif
                                endif
                                let str = substitute(str,'.*\.\s*to_f\s*\.\s*','Float#','')
                                let str = substitute(str,'.*\.\s*to_i\%(nt\)\=\s*\.\s*','Integer#','')
                                let str = substitute(str,'.*\.\s*to_s\%(tr\)\=\s*\.\s*','String#','')
                                let str = substitute(str,'.*\.\s*to_sym\s*\.\s*','Symbol#','')
                                let str = substitute(str,'.*\.\s*to_a\%(ry\)\=\s*\.\s*','Array#','')
                                let str = substitute(str,'.*\.\s*to_proc\s*\.\s*','Proc#','')
                                if str !~ '^\w'
                                  return ''
                                endif
                                silent! let res = substitute(system("ri -f rdoc -T \"".str.'"'),'\n$','','')
                                if res =~ '^Nothing known about' || res =~ '^Bad argument:' || res =~ '^More than one method'
                                  return ''
                                endif
                                return res
                              else
                                return ""
                              endif
                            endfunction
                            
    1              0.000004 function! s:searchsyn(pattern, syn, flags, mode) abort
                              let cnt = v:count1
                              norm! m'
                              if a:mode ==# 'v'
                                norm! gv
                              endif
                              let i = 0
                              call map(a:syn, 'hlID(v:val)')
                              while i < cnt
                                let i = i + 1
                                let line = line('.')
                                let col  = col('.')
                                let pos = search(a:pattern,'W'.a:flags)
                                while pos != 0 && index(a:syn, s:synid()) < 0
                                  let pos = search(a:pattern,'W'.a:flags)
                                endwhile
                                if pos == 0
                                  call cursor(line,col)
                                  return
                                endif
                              endwhile
                            endfunction
                            
    1              0.000002 function! s:synid() abort
                              return synID(line('.'),col('.'),0)
                            endfunction
                            
    1              0.000003 function! s:wrap_i(back,forward) abort
                              execute 'norm! k'
                              execute 'norm '.a:forward
                              let line = line('.')
                              execute 'norm '.a:back
                              if line('.') == line - 1
                                return s:wrap_a(a:back,a:forward)
                              endif
                              execute 'norm! jV'
                              execute 'norm '.a:forward
                              execute 'norm! k'
                            endfunction
                            
    1              0.000002 function! s:wrap_a(back,forward) abort
                              execute 'norm '.a:forward
                              if line('.') < line('$') && getline(line('.')+1) ==# ''
                                let after = 1
                              endif
                              execute 'norm '.a:back
                              while getline(line('.')-1) =~# '^\s*#' && line('.')
                                -
                              endwhile
                              if exists('after')
                                execute 'norm! V'
                                execute 'norm '.a:forward
                                execute 'norm! j'
                              elseif line('.') > 1 && getline(line('.')-1) =~# '^\s*$'
                                execute 'norm! kV'
                                execute 'norm '.a:forward
                              else
                                execute 'norm! V'
                                execute 'norm '.a:forward
                              endif
                            endfunction
                            
    1              0.000002 function! RubyCursorIdentifier() abort
                              let asciicode    = '\%(\w\|[]})\"'."'".']\)\@<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)'
                              let number       = '\%(\%(\w\|[]})\"'."'".']\s*\)\@<!-\)\=\%(\<[[:digit:]_]\+\%(\.[[:digit:]_]\+\)\=\%([Ee][[:digit:]_]\+\)\=\>\|\<0[xXbBoOdD][[:xdigit:]_]\+\>\)\|'.asciicode
                              let operator     = '\%(\[\]\|<<\|<=>\|[!<>]=\=\|===\=\|[!=]\~\|>>\|\*\*\|\.\.\.\=\|=>\|[~^&|*/%+-]\)'
                              let method       = '\%(\.[_a-zA-Z]\w*\s*=>\@!\|\<[_a-zA-Z]\w*\>[?!]\=\)'
                              let global       = '$\%([!$&"'."'".'*+,./:;<=>?@\`~]\|-\=\w\+\>\)'
                              let symbolizable = '\%(\%(@@\=\)\w\+\>\|'.global.'\|'.method.'\|'.operator.'\)'
                              let pattern      = '\C\s*\%('.number.'\|\%(:\@<!:\)\='.symbolizable.'\)'
                              let [lnum, col]  = searchpos(pattern,'bcn',line('.'))
                              let raw          = matchstr(getline('.')[col-1 : ],pattern)
                              let stripped     = substitute(substitute(raw,'\s\+=$','=',''),'^\s*[:.]\=','','')
                              return stripped == '' ? expand("<cword>") : stripped
                            endfunction
                            
    1              0.000002 function! RubyCursorTag() abort
                              return substitute(RubyCursorIdentifier(), '^[$@]*', '', '')
                            endfunction
                            
    1              0.000002 function! RubyCursorFile() abort
                              let isfname = &isfname
                              try
                                set isfname+=:
                                let cfile = expand('<cfile>')
                              finally
                                let isfname = &isfname
                              endtry
                              let pre = matchstr(strpart(getline('.'), 0, col('.')-1), '.*\f\@<!')
                              let post = matchstr(strpart(getline('.'), col('.')), '\f\@!.*')
                              if s:synid() ==# hlID('rubyConstant')
                                let cfile = substitute(cfile,'\.\w\+[?!=]\=$','','')
                                let cfile = substitute(cfile,'^::','','')
                                let cfile = substitute(cfile,'::','/','g')
                                let cfile = substitute(cfile,'\(\u\+\)\(\u\l\)','\1_\2', 'g')
                                let cfile = substitute(cfile,'\(\l\|\d\)\(\u\)','\1_\2', 'g')
                                return tolower(cfile) . '.rb'
                              elseif getline('.') =~# '^\s*require_relative\s*\(["'']\).*\1\s*$'
                                let cfile = expand('%:p:h') . '/' . matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1')
                                let cfile .= cfile !~# '\.rb$' ? '.rb' : ''
                              elseif getline('.') =~# '^\s*\%(require[( ]\|load[( ]\|autoload[( ]:\w\+,\)\s*\%(::\)\=File\.expand_path(\(["'']\)\.\./.*\1,\s*__FILE__)\s*$'
                                let target = matchstr(getline('.'),'\(["'']\)\.\.\zs/.\{-\}\ze\1')
                                let cfile = expand('%:p:h') . target
                                let cfile .= cfile !~# '\.rb$' ? '.rb' : ''
                              elseif getline('.') =~# '^\s*\%(require \|load \|autoload :\w\+,\)\s*\(["'']\).*\1\s*$'
                                let cfile = matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1')
                                let cfile .= cfile !~# '\.rb$' ? '.rb' : ''
                              elseif pre.post =~# '\<File.expand_path[( ].*[''"]\{2\}, *__FILE__\>' && cfile =~# '^\.\.'
                                let cfile = expand('%:p:h') . strpart(cfile, 2)
                              else
                                return substitute(cfile, '\C\v^(.*):(\d+)%(:in)=$', '+\2 \1', '')
                              endif
                              let cwdpat = '^\M' . substitute(getcwd(), '[\/]', '\\[\\/]', 'g').'\ze\[\/]'
                              let cfile = substitute(cfile, cwdpat, '.', '')
                              if fnameescape(cfile) !=# cfile
                                return '+ '.fnameescape(cfile)
                              else
                                return cfile
                              endif
                            endfunction
                            
                            "
                            " Instructions for enabling "matchit" support:
                            "
                            " 1. Look for the latest "matchit" plugin at
                            "
                            "         http://www.vim.org/scripts/script.php?script_id=39
                            "
                            "    It is also packaged with Vim, in the $VIMRUNTIME/macros directory.
                            "
                            " 2. Copy "matchit.txt" into a "doc" directory (e.g. $HOME/.vim/doc).
                            "
                            " 3. Copy "matchit.vim" into a "plugin" directory (e.g. $HOME/.vim/plugin).
                            "
                            " 4. Ensure this file (ftplugin/ruby.vim) is installed.
                            "
                            " 5. Ensure you have this line in your $HOME/.vimrc:
                            "         filetype plugin on
                            "
                            " 6. Restart Vim and create the matchit documentation:
                            "
                            "         :helptags ~/.vim/doc
                            "
                            "    Now you can do ":help matchit", and you should be able to use "%" on Ruby
                            "    keywords.  Try ":echo b:match_words" to be sure.
                            "
                            " Thanks to Mark J. Reed for the instructions.  See ":help vimrc" for the
                            " locations of plugin directories, etc., as there are several options, and it
                            " differs on Windows.  Email gsinclair@soyabean.com.au if you need help.
                            "
                            
                            " vim: nowrap sw=2 sts=2 ts=8:

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/ruby.vim
Sourced 1 time
Total time:   0.002391
 Self time:   0.001208

count  total (s)   self (s)
                            " The Ruby provider helper
    1              0.000017 if exists('g:loaded_ruby_provider')
                              finish
    1              0.000002 endif
    1              0.000007 let g:loaded_ruby_provider = 1
                            
    1              0.000006 function! provider#ruby#Detect() abort
                              let e = empty(s:prog) ? 'missing ruby or ruby-host' : ''
                              return [s:prog, e]
                            endfunction
                            
    1              0.000004 function! provider#ruby#Prog() abort
                              return s:prog
                            endfunction
                            
    1              0.000004 function! provider#ruby#Require(host) abort
                              let prog = provider#ruby#Prog()
                              let ruby_plugins = remote#host#PluginsForHost(a:host.name)
                            
                              for plugin in ruby_plugins
                                let prog .= " " . shellescape(plugin.path)
                              endfor
                            
                              return provider#Poll(prog, a:host.orig_name, '$NVIM_RUBY_LOG_FILE')
                            endfunction
                            
    1              0.000012 function! provider#ruby#Call(method, args) abort
                              if s:err != ''
                                echoerr s:err
                                return
                              endif
                            
                              if !exists('s:host')
                                try
                                  let s:host = remote#host#Require('legacy-ruby-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call('rpcrequest', insert(insert(a:args, 'ruby_'.a:method), s:host))
                            endfunction
                            
    1              0.000005 function! s:detect()
                              if exists("g:ruby_host_prog")
                                return expand(g:ruby_host_prog, v:true)
                              elseif has('win32')
                                return exepath('neovim-ruby-host.bat')
                              else
                                let p = exepath('neovim-ruby-host')
                                if empty(p)
                                  return ''
                                endif
                                " neovim-ruby-host could be an rbenv shim for another Ruby version.
                                call system(p)
                                return v:shell_error ? '' : p
                              end
                            endfunction
                            
    1              0.000005 let s:err = ''
    1   0.000972   0.000033 let s:prog = s:detect()
    1              0.000030 let s:plugin_path = expand('<sfile>:p:h') . '/script_host.rb'
    1              0.000010 let g:loaded_ruby_provider = empty(s:prog) ? 1 : 2
                            
    1              0.000005 if g:loaded_ruby_provider != 2
    1              0.000005   let s:err = 'Cannot find the neovim RubyGem. Try :checkhealth'
    1              0.000002 endif
                            
    1   0.000085   0.000032 call remote#host#RegisterClone('legacy-ruby-provider', 'ruby')
    1   0.000219   0.000028 call remote#host#RegisterPlugin('legacy-ruby-provider', s:plugin_path, [])

SCRIPT  /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/indent/ruby.vim
Sourced 1 time
Total time:   0.001599
 Self time:   0.001599

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Ruby
                            " Maintainer:		Andrew Radev <andrey.radev@gmail.com>
                            " Previous Maintainer:	Nikolai Weibull <now at bitwi.se>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:		2022 Mar 22
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    1              0.000012 if exists("b:did_indent")
                              finish
    1              0.000002 endif
    1              0.000007 let b:did_indent = 1
                            
    1              0.000004 if !exists('g:ruby_indent_access_modifier_style')
                              " Possible values: "normal", "indent", "outdent"
    1              0.000003   let g:ruby_indent_access_modifier_style = 'normal'
    1              0.000001 endif
                            
    1              0.000004 if !exists('g:ruby_indent_assignment_style')
                              " Possible values: "variable", "hanging"
    1              0.000003   let g:ruby_indent_assignment_style = 'hanging'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:ruby_indent_block_style')
                              " Possible values: "expression", "do"
    1              0.000002   let g:ruby_indent_block_style = 'do'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:ruby_indent_hanging_elements')
                              " Non-zero means hanging indents are enabled, zero means disabled
    1              0.000003   let g:ruby_indent_hanging_elements = 1
    1              0.000001 endif
                            
    1              0.000009 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
    1              0.000009 setlocal indentexpr=GetRubyIndent(v:lnum)
    1              0.000005 setlocal indentkeys=0{,0},0),0],!^F,o,O,e,:,.
    1              0.000005 setlocal indentkeys+==end,=else,=elsif,=when,=in\ ,=ensure,=rescue,==begin,==end
    1              0.000006 setlocal indentkeys+==private,=protected,=public
                            
    1              0.000004 let b:undo_indent = "setlocal indentexpr< indentkeys< smartindent<"
                            
                            " Only define the function once.
    1              0.000004 if exists("*GetRubyIndent")
                              finish
    1              0.000001 endif
                            
    1              0.000008 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
                            " 1. Variables {{{1
                            " ============
                            
                            " Syntax group names that are strings.
    1              0.000006 let s:syng_string =
                                  \ ['String', 'Interpolation', 'InterpolationDelimiter', 'StringEscape']
                            
                            " Syntax group names that are strings or documentation.
    1              0.000006 let s:syng_stringdoc = s:syng_string + ['Documentation']
                            
                            " Syntax group names that are or delimit strings/symbols/regexes or are comments.
    1              0.000018 let s:syng_strcom = s:syng_stringdoc + [
                                  \ 'Character',
                                  \ 'Comment',
                                  \ 'HeredocDelimiter',
                                  \ 'PercentRegexpDelimiter',
                                  \ 'PercentStringDelimiter',
                                  \ 'PercentSymbolDelimiter',
                                  \ 'Regexp',
                                  \ 'RegexpCharClass',
                                  \ 'RegexpDelimiter',
                                  \ 'RegexpEscape',
                                  \ 'StringDelimiter',
                                  \ 'Symbol',
                                  \ 'SymbolDelimiter',
                                  \ ]
                            
                            " Expression used to check whether we should skip a match with searchpair().
    1              0.000015 let s:skip_expr =
                                  \ 'index(map('.string(s:syng_strcom).',"hlID(''ruby''.v:val)"), synID(line("."),col("."),1)) >= 0'
                            
                            " Regex used for words that, at the start of a line, add a level of indent.
    1              0.000011 let s:ruby_indent_keywords =
                                  \ '^\s*\zs\<\%(module\|class\|if\|for' .
                                  \   '\|while\|until\|else\|elsif\|case\|when\|in\|unless\|begin\|ensure\|rescue' .
                                  \   '\|\%(\K\k*[!?]\?\s\+\)\=def\):\@!\>' .
                                  \ '\|\%([=,*/%+-]\|<<\|>>\|:\s\)\s*\zs' .
                                  \    '\<\%(if\|for\|while\|until\|case\|unless\|begin\):\@!\>'
                            
                            " Def without an end clause: def method_call(...) = <expression>
    1              0.000003 let s:ruby_endless_def = '\<def\s\+\k\+[!?]\=\%((.*)\|\s\)\s*='
                            
                            " Regex used for words that, at the start of a line, remove a level of indent.
    1              0.000004 let s:ruby_deindent_keywords =
                                  \ '^\s*\zs\<\%(ensure\|else\|rescue\|elsif\|when\|in\|end\):\@!\>'
                            
                            " Regex that defines the start-match for the 'end' keyword.
                            "let s:end_start_regex = '\%(^\|[^.]\)\<\%(module\|class\|def\|if\|for\|while\|until\|case\|unless\|begin\|do\)\>'
                            " TODO: the do here should be restricted somewhat (only at end of line)?
    1              0.000008 let s:end_start_regex =
                                  \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
                                  \ '\<\%(module\|class\|if\|for\|while\|until\|case\|unless\|begin' .
                                  \   '\|\%(\K\k*[!?]\?\s\+\)\=def\):\@!\>' .
                                  \ '\|\%(^\|[^.:@$]\)\@<=\<do:\@!\>'
                            
                            " Regex that defines the middle-match for the 'end' keyword.
    1              0.000004 let s:end_middle_regex = '\<\%(ensure\|else\|\%(\%(^\|;\)\s*\)\@<=\<rescue:\@!\>\|when\|\%(\%(^\|;\)\s*\)\@<=\<in\|elsif\):\@!\>'
                            
                            " Regex that defines the end-match for the 'end' keyword.
    1              0.000003 let s:end_end_regex = '\%(^\|[^.:@$]\)\@<=\<end:\@!\>'
                            
                            " Expression used for searchpair() call for finding a match for an 'end' keyword.
    1              0.000003 function! s:EndSkipExpr()
                              if eval(s:skip_expr)
                                return 1
                              elseif expand('<cword>') == 'do'
                                    \ && getline(".") =~ '^\s*\<\(while\|until\|for\):\@!\>'
                                return 1
                              elseif getline('.') =~ s:ruby_endless_def
                                return 1
                              elseif getline('.') =~ '\<def\s\+\k\+[!?]\=([^)]*$'
                                " Then it's a `def method(` with a possible `) =` later
                                call search('\<def\s\+\k\+\zs(', 'W', line('.'))
                                normal! %
                                return getline('.') =~ ')\s*='
                              else
                                return 0
                              endif
                            endfunction
                            
    1              0.000009 let s:end_skip_expr = function('s:EndSkipExpr')
                            
                            " Regex that defines continuation lines, not including (, {, or [.
    1              0.000005 let s:non_bracket_continuation_regex =
                                  \ '\%([\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|:\@<![^[:alnum:]:][|&?]\|||\|&&\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines continuation lines.
    1              0.000004 let s:continuation_regex =
                                  \ '\%(%\@<![({[\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|:\@<![^[:alnum:]:][|&?]\|||\|&&\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines continuable keywords
    1              0.000006 let s:continuable_regex =
                                  \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
                                  \ '\<\%(if\|for\|while\|until\|unless\):\@!\>'
                            
                            " Regex that defines bracket continuations
    1              0.000003 let s:bracket_continuation_regex = '%\@<!\%([({[]\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines dot continuations
    1              0.000003 let s:dot_continuation_regex = '%\@<!\.\s*\%(#.*\)\=$'
                            
                            " Regex that defines backslash continuations
    1              0.000003 let s:backslash_continuation_regex = '%\@<!\\\s*$'
                            
                            " Regex that defines end of bracket continuation followed by another continuation
    1              0.000004 let s:bracket_switch_continuation_regex = '^\([^(]\+\zs).\+\)\+'.s:continuation_regex
                            
                            " Regex that defines the first part of a splat pattern
    1              0.000002 let s:splat_regex = '[[,(]\s*\*\s*\%(#.*\)\=$'
                            
                            " Regex that describes all indent access modifiers
    1              0.000003 let s:access_modifier_regex = '\C^\s*\%(public\|protected\|private\)\s*\%(#.*\)\=$'
                            
                            " Regex that describes the indent access modifiers (excludes public)
    1              0.000003 let s:indent_access_modifier_regex = '\C^\s*\%(protected\|private\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines blocks.
                            "
                            " Note that there's a slight problem with this regex and s:continuation_regex.
                            " Code like this will be matched by both:
                            "
                            "   method_call do |(a, b)|
                            "
                            " The reason is that the pipe matches a hanging "|" operator.
                            "
    1              0.000003 let s:block_regex =
                                  \ '\%(\<do:\@!\>\|%\@<!{\)\s*\%(|[^|]*|\)\=\s*\%(#.*\)\=$'
                            
    1              0.000004 let s:block_continuation_regex = '^\s*[^])}\t ].*'.s:block_regex
                            
                            " Regex that describes a leading operator (only a method call's dot for now)
    1              0.000003 let s:leading_operator_regex = '^\s*\%(&\=\.\)'
                            
                            " 2. GetRubyIndent Function {{{1
                            " =========================
                            
    1              0.000002 function! GetRubyIndent(...) abort
                              " 2.1. Setup {{{2
                              " ----------
                            
                              let indent_info = {}
                            
                              " The value of a single shift-width
                              if exists('*shiftwidth')
                                let indent_info.sw = shiftwidth()
                              else
                                let indent_info.sw = &sw
                              endif
                            
                              " For the current line, use the first argument if given, else v:lnum
                              let indent_info.clnum = a:0 ? a:1 : v:lnum
                              let indent_info.cline = getline(indent_info.clnum)
                            
                              " Set up variables for restoring position in file.  Could use clnum here.
                              let indent_info.col = col('.')
                            
                              " 2.2. Work on the current line {{{2
                              " -----------------------------
                              let indent_callback_names = [
                                    \ 's:AccessModifier',
                                    \ 's:ClosingBracketOnEmptyLine',
                                    \ 's:BlockComment',
                                    \ 's:DeindentingKeyword',
                                    \ 's:MultilineStringOrLineComment',
                                    \ 's:ClosingHeredocDelimiter',
                                    \ 's:LeadingOperator',
                                    \ ]
                            
                              for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
                                let indent = call(function(callback_name), [indent_info])
                            
                                if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
                                endif
                              endfor
                            
                              " 2.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " Special case: we don't need the real s:PrevNonBlankNonString for an empty
                              " line inside a string. And that call can be quite expensive in that
                              " particular situation.
                              let indent_callback_names = [
                                    \ 's:EmptyInsideString',
                                    \ ]
                            
                              for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
                                let indent = call(function(callback_name), [indent_info])
                            
                                if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
                                endif
                              endfor
                            
                              " Previous line number
                              let indent_info.plnum = s:PrevNonBlankNonString(indent_info.clnum - 1)
                              let indent_info.pline = getline(indent_info.plnum)
                            
                              let indent_callback_names = [
                                    \ 's:StartOfFile',
                                    \ 's:AfterAccessModifier',
                                    \ 's:ContinuedLine',
                                    \ 's:AfterBlockOpening',
                                    \ 's:AfterHangingSplat',
                                    \ 's:AfterUnbalancedBracket',
                                    \ 's:AfterLeadingOperator',
                                    \ 's:AfterEndKeyword',
                                    \ 's:AfterIndentKeyword',
                                    \ ]
                            
                              for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
                                let indent = call(function(callback_name), [indent_info])
                            
                                if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
                                endif
                              endfor
                            
                              " 2.4. Work on the MSL line. {{{2
                              " --------------------------
                              let indent_callback_names = [
                                    \ 's:PreviousNotMSL',
                                    \ 's:IndentingKeywordInMSL',
                                    \ 's:ContinuedHangingOperator',
                                    \ ]
                            
                              " Most Significant line based on the previous one -- in case it's a
                              " continuation of something above
                              let indent_info.plnum_msl = s:GetMSL(indent_info.plnum)
                            
                              for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
                                let indent = call(function(callback_name), [indent_info])
                            
                                if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
                                endif
                              endfor
                            
                              " }}}2
                            
                              " By default, just return the previous line's indent
                            "  Decho "Default case matched"
                              return indent(indent_info.plnum)
                            endfunction
                            
                            " 3. Indenting Logic Callbacks {{{1
                            " ============================
                            
    1              0.000004 function! s:AccessModifier(cline_info) abort
                              let info = a:cline_info
                            
                              " If this line is an access modifier keyword, align according to the closest
                              " class declaration.
                              if g:ruby_indent_access_modifier_style == 'indent'
                                if s:Match(info.clnum, s:access_modifier_regex)
                                  let class_lnum = s:FindContainingClass()
                                  if class_lnum > 0
                                    return indent(class_lnum) + info.sw
                                  endif
                                endif
                              elseif g:ruby_indent_access_modifier_style == 'outdent'
                                if s:Match(info.clnum, s:access_modifier_regex)
                                  let class_lnum = s:FindContainingClass()
                                  if class_lnum > 0
                                    return indent(class_lnum)
                                  endif
                                endif
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:ClosingBracketOnEmptyLine(cline_info) abort
                              let info = a:cline_info
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(info.cline, '^\s*[]})]')
                            
                              if col > 0 && !s:IsInStringOrComment(info.clnum, col)
                                call cursor(info.clnum, col)
                                let closing_bracket = info.cline[col - 1]
                                let bracket_pair = strpart('(){}[]', stridx(')}]', closing_bracket) * 2, 2)
                            
                                if searchpair(escape(bracket_pair[0], '\['), '', bracket_pair[1], 'bW', s:skip_expr) > 0
                                  if closing_bracket == ')' && col('.') != col('$') - 1
                                    if g:ruby_indent_hanging_elements
                                      let ind = virtcol('.') - 1
                                    else
                                      let ind = indent(line('.'))
                                    end
                                  elseif g:ruby_indent_block_style == 'do'
                                    let ind = indent(line('.'))
                                  else " g:ruby_indent_block_style == 'expression'
                                    let ind = indent(s:GetMSL(line('.')))
                                  endif
                                endif
                            
                                return ind
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:BlockComment(cline_info) abort
                              " If we have a =begin or =end set indent to first column.
                              if match(a:cline_info.cline, '^\s*\%(=begin\|=end\)$') != -1
                                return 0
                              endif
                              return -1
                            endfunction
                            
    1              0.000003 function! s:DeindentingKeyword(cline_info) abort
                              let info = a:cline_info
                            
                              " If we have a deindenting keyword, find its match and indent to its level.
                              " TODO: this is messy
                              if s:Match(info.clnum, s:ruby_deindent_keywords)
                                call cursor(info.clnum, 1)
                            
                                if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
                                      \ s:end_skip_expr) > 0
                                  let msl  = s:GetMSL(line('.'))
                                  let line = getline(line('.'))
                            
                                  if s:IsAssignment(line, col('.')) &&
                                        \ strpart(line, col('.') - 1, 2) !~ 'do'
                                    " assignment to case/begin/etc, on the same line
                                    if g:ruby_indent_assignment_style == 'hanging'
                                      " hanging indent
                                      let ind = virtcol('.') - 1
                                    else
                                      " align with variable
                                      let ind = indent(line('.'))
                                    endif
                                  elseif g:ruby_indent_block_style == 'do'
                                    " align to line of the "do", not to the MSL
                                    let ind = indent(line('.'))
                                  elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the MSL, align to the starting line,
                                    " not to the MSL
                                    let ind = indent(line('.'))
                                  else
                                    " align to the MSL
                                    let ind = indent(msl)
                                  endif
                                endif
                                return ind
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:MultilineStringOrLineComment(cline_info) abort
                              let info = a:cline_info
                            
                              " If we are in a multi-line string or line-comment, don't do anything to it.
                              if s:IsInStringOrDocumentation(info.clnum, matchend(info.cline, '^\s*') + 1)
                                return indent(info.clnum)
                              endif
                              return -1
                            endfunction
                            
    1              0.000002 function! s:ClosingHeredocDelimiter(cline_info) abort
                              let info = a:cline_info
                            
                              " If we are at the closing delimiter of a "<<" heredoc-style string, set the
                              " indent to 0.
                              if info.cline =~ '^\k\+\s*$'
                                    \ && s:IsInStringDelimiter(info.clnum, 1)
                                    \ && search('\V<<'.info.cline, 'nbW') > 0
                                return 0
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:LeadingOperator(cline_info) abort
                              " If the current line starts with a leading operator, add a level of indent.
                              if s:Match(a:cline_info.clnum, s:leading_operator_regex)
                                return indent(s:GetMSL(a:cline_info.clnum)) + a:cline_info.sw
                              endif
                              return -1
                            endfunction
                            
    1              0.000003 function! s:EmptyInsideString(pline_info) abort
                              " If the line is empty and inside a string (the previous line is a string,
                              " too), use the previous line's indent
                              let info = a:pline_info
                            
                              let plnum = prevnonblank(info.clnum - 1)
                              let pline = getline(plnum)
                            
                              if info.cline =~ '^\s*$'
                                    \ && s:IsInStringOrComment(plnum, 1)
                                    \ && s:IsInStringOrComment(plnum, strlen(pline))
                                return indent(plnum)
                              endif
                              return -1
                            endfunction
                            
    1              0.000003 function! s:StartOfFile(pline_info) abort
                              " At the start of the file use zero indent.
                              if a:pline_info.plnum == 0
                                return 0
                              endif
                              return -1
                            endfunction
                            
    1              0.000002 function! s:AfterAccessModifier(pline_info) abort
                              let info = a:pline_info
                            
                              if g:ruby_indent_access_modifier_style == 'indent'
                                " If the previous line was a private/protected keyword, add a
                                " level of indent.
                                if s:Match(info.plnum, s:indent_access_modifier_regex)
                                  return indent(info.plnum) + info.sw
                                endif
                              elseif g:ruby_indent_access_modifier_style == 'outdent'
                                " If the previous line was a private/protected/public keyword, add
                                " a level of indent, since the keyword has been out-dented.
                                if s:Match(info.plnum, s:access_modifier_regex)
                                  return indent(info.plnum) + info.sw
                                endif
                              endif
                              return -1
                            endfunction
                            
                            " Example:
                            "
                            "   if foo || bar ||
                            "       baz || bing
                            "     puts "foo"
                            "   end
                            "
    1              0.000003 function! s:ContinuedLine(pline_info) abort
                              let info = a:pline_info
                            
                              let col = s:Match(info.plnum, s:ruby_indent_keywords)
                              if s:Match(info.plnum, s:continuable_regex) &&
                                    \ s:Match(info.plnum, s:continuation_regex)
                                if col > 0 && s:IsAssignment(info.pline, col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum)
                                  endif
                                else
                                  let ind = indent(s:GetMSL(info.plnum))
                                endif
                                return ind + info.sw + info.sw
                              endif
                              return -1
                            endfunction
                            
    1              0.000006 function! s:AfterBlockOpening(pline_info) abort
                              let info = a:pline_info
                            
                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(info.plnum, s:block_regex)
                                if g:ruby_indent_block_style == 'do'
                                  " don't align to the msl, align to the "do"
                                  let ind = indent(info.plnum) + info.sw
                                else
                                  let plnum_msl = s:GetMSL(info.plnum)
                            
                                  if getline(plnum_msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the msl, align to the starting line,
                                    " not to the msl
                                    let ind = indent(info.plnum) + info.sw
                                  else
                                    let ind = indent(plnum_msl) + info.sw
                                  endif
                                endif
                            
                                return ind
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:AfterLeadingOperator(pline_info) abort
                              " If the previous line started with a leading operator, use its MSL's level
                              " of indent
                              if s:Match(a:pline_info.plnum, s:leading_operator_regex)
                                return indent(s:GetMSL(a:pline_info.plnum))
                              endif
                              return -1
                            endfunction
                            
    1              0.000003 function! s:AfterHangingSplat(pline_info) abort
                              let info = a:pline_info
                            
                              " If the previous line ended with the "*" of a splat, add a level of indent
                              if info.pline =~ s:splat_regex
                                return indent(info.plnum) + info.sw
                              endif
                              return -1
                            endfunction
                            
    1              0.000003 function! s:AfterUnbalancedBracket(pline_info) abort
                              let info = a:pline_info
                            
                              " If the previous line contained unclosed opening brackets and we are still
                              " in them, find the rightmost one and add indent depending on the bracket
                              " type.
                              "
                              " If it contained hanging closing brackets, find the rightmost one, find its
                              " match and indent according to that.
                              if info.pline =~ '[[({]' || info.pline =~ '[])}]\s*\%(#.*\)\=$'
                                let [opening, closing] = s:ExtraBrackets(info.plnum)
                            
                                if opening.pos != -1
                                  if !g:ruby_indent_hanging_elements
                                    return indent(info.plnum) + info.sw
                                  elseif opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                    if col('.') + 1 == col('$')
                                      return indent(info.plnum) + info.sw
                                    else
                                      return virtcol('.')
                                    endif
                                  else
                                    let nonspace = matchend(info.pline, '\S', opening.pos + 1) - 1
                                    return nonspace > 0 ? nonspace : indent(info.plnum) + info.sw
                                  endif
                                elseif closing.pos != -1
                                  call cursor(info.plnum, closing.pos + 1)
                                  normal! %
                            
                                  if strpart(info.pline, closing.pos) =~ '^)\s*='
                                    " special case: the closing `) =` of an endless def
                                    return indent(s:GetMSL(line('.')))
                                  endif
                            
                                  if s:Match(line('.'), s:ruby_indent_keywords)
                                    return indent('.') + info.sw
                                  else
                                    return indent(s:GetMSL(line('.')))
                                  endif
                                else
                                  call cursor(info.clnum, info.col)
                                end
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:AfterEndKeyword(pline_info) abort
                              let info = a:pline_info
                              " If the previous line ended with an "end", match that "end"s beginning's
                              " indent.
                              let col = s:Match(info.plnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
                              if col > 0
                                call cursor(info.plnum, col)
                                if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW',
                                      \ s:end_skip_expr) > 0
                                  let n = line('.')
                                  let ind = indent('.')
                                  let msl = s:GetMSL(n)
                                  if msl != n
                                    let ind = indent(msl)
                                  end
                                  return ind
                                endif
                              end
                              return -1
                            endfunction
                            
    1              0.000003 function! s:AfterIndentKeyword(pline_info) abort
                              let info = a:pline_info
                              let col = s:Match(info.plnum, s:ruby_indent_keywords)
                            
                              if col > 0 && s:Match(info.plnum, s:ruby_endless_def) <= 0
                                call cursor(info.plnum, col)
                                let ind = virtcol('.') - 1 + info.sw
                                " TODO: make this better (we need to count them) (or, if a searchpair
                                " fails, we know that something is lacking an end and thus we indent a
                                " level
                                if s:Match(info.plnum, s:end_end_regex)
                                  let ind = indent('.')
                                elseif s:IsAssignment(info.pline, col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col + info.sw - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum) + info.sw
                                  endif
                                endif
                                return ind
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:PreviousNotMSL(msl_info) abort
                              let info = a:msl_info
                            
                              " If the previous line wasn't a MSL
                              if info.plnum != info.plnum_msl
                                " If previous line ends bracket and begins non-bracket continuation decrease indent by 1.
                                if s:Match(info.plnum, s:bracket_switch_continuation_regex)
                                  " TODO (2016-10-07) Wrong/unused? How could it be "1"?
                                  return indent(info.plnum) - 1
                                  " If previous line is a continuation return its indent.
                                elseif s:Match(info.plnum, s:non_bracket_continuation_regex)
                                  return indent(info.plnum)
                                endif
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000003 function! s:IndentingKeywordInMSL(msl_info) abort
                              let info = a:msl_info
                              " If the MSL line had an indenting keyword in it, add a level of indent.
                              " TODO: this does not take into account contrived things such as
                              " module Foo; class Bar; end
                              let col = s:Match(info.plnum_msl, s:ruby_indent_keywords)
                              if col > 0 && s:Match(info.plnum_msl, s:ruby_endless_def) <= 0
                                let ind = indent(info.plnum_msl) + info.sw
                                if s:Match(info.plnum_msl, s:end_end_regex)
                                  let ind = ind - info.sw
                                elseif s:IsAssignment(getline(info.plnum_msl), col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col + info.sw - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum_msl) + info.sw
                                  endif
                                endif
                                return ind
                              endif
                              return -1
                            endfunction
                            
    1              0.000003 function! s:ContinuedHangingOperator(msl_info) abort
                              let info = a:msl_info
                            
                              " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
                              " closing bracket, indent one extra level.
                              if s:Match(info.plnum_msl, s:non_bracket_continuation_regex) && !s:Match(info.plnum_msl, '^\s*\([\])}]\|end\)')
                                if info.plnum_msl == info.plnum
                                  let ind = indent(info.plnum_msl) + info.sw
                                else
                                  let ind = indent(info.plnum_msl)
                                endif
                                return ind
                              endif
                            
                              return -1
                            endfunction
                            
                            " 4. Auxiliary Functions {{{1
                            " ======================
                            
    1              0.000003 function! s:IsInRubyGroup(groups, lnum, col) abort
                              let ids = map(copy(a:groups), 'hlID("ruby".v:val)')
                              return index(ids, synID(a:lnum, a:col, 1)) >= 0
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
    1              0.000003 function! s:IsInStringOrComment(lnum, col) abort
                              return s:IsInRubyGroup(s:syng_strcom, a:lnum, a:col)
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string.
    1              0.000002 function! s:IsInString(lnum, col) abort
                              return s:IsInRubyGroup(s:syng_string, a:lnum, a:col)
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string or documentation.
    1              0.000003 function! s:IsInStringOrDocumentation(lnum, col) abort
                              return s:IsInRubyGroup(s:syng_stringdoc, a:lnum, a:col)
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string delimiter
    1              0.000002 function! s:IsInStringDelimiter(lnum, col) abort
                              return s:IsInRubyGroup(
                                    \ ['HeredocDelimiter', 'PercentStringDelimiter', 'StringDelimiter'],
                                    \ a:lnum, a:col
                                    \ )
                            endfunction
                            
    1              0.000003 function! s:IsAssignment(str, pos) abort
                              return strpart(a:str, 0, a:pos - 1) =~ '=\s*$'
                            endfunction
                            
                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
    1              0.000002 function! s:PrevNonBlankNonString(lnum) abort
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '^=begin'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '^=end'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1)
                                      \ && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction
                            
                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
    1              0.000002 function! s:GetMSL(lnum) abort
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                            
                                if !s:Match(msl, s:backslash_continuation_regex) &&
                                      \ s:Match(lnum, s:backslash_continuation_regex)
                                  " If the current line doesn't end in a backslash, but the previous one
                                  " does, look for that line's msl
                                  "
                                  " Example:
                                  "   foo = "bar" \
                                  "     "baz"
                                  "
                                  let msl = lnum
                                elseif s:Match(msl, s:leading_operator_regex)
                                  " If the current line starts with a leading operator, keep its indent
                                  " and keep looking for an MSL.
                                  let msl = lnum
                                elseif s:Match(lnum, s:splat_regex)
                                  " If the above line looks like the "*" of a splat, use the current one's
                                  " indentation.
                                  "
                                  " Example:
                                  "   Hash[*
                                  "     method_call do
                                  "       something
                                  "
                                  return msl
                                elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
                                      \ s:Match(msl, s:non_bracket_continuation_regex)
                                  " If the current line is a non-bracket continuation and so is the
                                  " previous one, keep its indent and continue looking for an MSL.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two,
                                  "     three
                                  "
                                  let msl = lnum
                                elseif s:Match(lnum, s:dot_continuation_regex) &&
                                      \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a dot, keep going to see if the previous line is the
                                  " start of another continuation.
                                  "
                                  " Example:
                                  "   parent.
                                  "     method_call {
                                  "     three
                                  "
                                  let msl = lnum
                                elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
                                      \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a non-bracket one, respect the previous' indentation,
                                  " and stop here.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two {
                                  "     three
                                  "
                                  return lnum
                                elseif s:Match(lnum, s:bracket_continuation_regex) &&
                                      \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If both lines are bracket continuations (the current may also be a
                                  " block-starter), use the current one's and stop here
                                  "
                                  " Example:
                                  "   method_call(
                                  "     other_method_call(
                                  "       foo
                                  return msl
                                elseif s:Match(lnum, s:block_regex) &&
                                      \ !s:Match(msl, s:continuation_regex) &&
                                      \ !s:Match(msl, s:block_continuation_regex)
                                  " If the previous line is a block-starter and the current one is
                                  " mostly ordinary, use the current one as the MSL.
                                  "
                                  " Example:
                                  "   method_call do
                                  "     something
                                  "     something_else
                                  return msl
                                else
                                  let col = match(line, s:continuation_regex) + 1
                                  if (col > 0 && !s:IsInStringOrComment(lnum, col))
                                        \ || s:IsInString(lnum, strlen(line))
                                    let msl = lnum
                                  else
                                    break
                                  endif
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction
                            
                            " Check if line 'lnum' has more opening brackets than closing ones.
    1              0.000003 function! s:ExtraBrackets(lnum) abort
                              let opening = {'parentheses': [], 'braces': [], 'brackets': []}
                              let closing = {'parentheses': [], 'braces': [], 'brackets': []}
                            
                              let line = getline(a:lnum)
                              let pos  = match(line, '[][(){}]', 0)
                            
                              " Save any encountered opening brackets, and remove them once a matching
                              " closing one has been found. If a closing bracket shows up that doesn't
                              " close anything, save it for later.
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  if line[pos] == '('
                                    call add(opening.parentheses, {'type': '(', 'pos': pos})
                                  elseif line[pos] == ')'
                                    if empty(opening.parentheses)
                                      call add(closing.parentheses, {'type': ')', 'pos': pos})
                                    else
                                      let opening.parentheses = opening.parentheses[0:-2]
                                    endif
                                  elseif line[pos] == '{'
                                    call add(opening.braces, {'type': '{', 'pos': pos})
                                  elseif line[pos] == '}'
                                    if empty(opening.braces)
                                      call add(closing.braces, {'type': '}', 'pos': pos})
                                    else
                                      let opening.braces = opening.braces[0:-2]
                                    endif
                                  elseif line[pos] == '['
                                    call add(opening.brackets, {'type': '[', 'pos': pos})
                                  elseif line[pos] == ']'
                                    if empty(opening.brackets)
                                      call add(closing.brackets, {'type': ']', 'pos': pos})
                                    else
                                      let opening.brackets = opening.brackets[0:-2]
                                    endif
                                  endif
                                endif
                            
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                            
                              " Find the rightmost brackets, since they're the ones that are important in
                              " both opening and closing cases
                              let rightmost_opening = {'type': '(', 'pos': -1}
                              let rightmost_closing = {'type': ')', 'pos': -1}
                            
                              for opening in opening.parentheses + opening.braces + opening.brackets
                                if opening.pos > rightmost_opening.pos
                                  let rightmost_opening = opening
                                endif
                              endfor
                            
                              for closing in closing.parentheses + closing.braces + closing.brackets
                                if closing.pos > rightmost_closing.pos
                                  let rightmost_closing = closing
                                endif
                              endfor
                            
                              return [rightmost_opening, rightmost_closing]
                            endfunction
                            
    1              0.000003 function! s:Match(lnum, regex) abort
                              let line   = getline(a:lnum)
                              let offset = match(line, '\C'.a:regex)
                              let col    = offset + 1
                            
                              while offset > -1 && s:IsInStringOrComment(a:lnum, col)
                                let offset = match(line, '\C'.a:regex, offset + 1)
                                let col = offset + 1
                              endwhile
                            
                              if offset > -1
                                return col
                              else
                                return 0
                              endif
                            endfunction
                            
                            " Locates the containing class/module's definition line, ignoring nested classes
                            " along the way.
                            "
    1              0.000002 function! s:FindContainingClass() abort
                              let saved_position = getpos('.')
                            
                              while searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
                                    \ s:end_skip_expr) > 0
                                if expand('<cword>') =~# '\<class\|module\>'
                                  let found_lnum = line('.')
                                  call setpos('.', saved_position)
                                  return found_lnum
                                endif
                              endwhile
                            
                              call setpos('.', saved_position)
                              return 0
                            endfunction
                            
                            " }}}1
                            
    1              0.000016 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 et:

SCRIPT  /mnt/nfs/homes/emcnab/.local/share/nvim/lazy/lazygit.nvim/plugin/lazygit.vim
Sourced 1 time
Total time:   0.000413
 Self time:   0.000394

count  total (s)   self (s)
    1              0.000013 scriptencoding utf-8
                            
    1              0.000023 if exists('g:loaded_lazygit_vim') | finish | endif
                            
    1              0.000012 let s:save_cpo = &cpoptions
    1   0.000034   0.000023 set cpoptions&vim
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000009 if !exists('g:lazygit_floating_window_winblend')
    1              0.000008     let g:lazygit_floating_window_winblend = 0
    1              0.000002 endif
                            
    1              0.000007 if !exists('g:lazygit_floating_window_scaling_factor')
    1              0.000010   let g:lazygit_floating_window_scaling_factor = 0.9
    1              0.000002 endif
                            
    1              0.000006 if !exists('g:lazygit_use_neovim_remote')
    1              0.000109   let g:lazygit_use_neovim_remote = executable('nvr') ? 1 : 0
    1              0.000003 endif
                            
    1              0.000007 if !exists('g:lazygit_floating_window_corner_chars')
    1              0.000015   let g:lazygit_floating_window_corner_chars = ['╭', '╮', '╰', '╯']
    1              0.000002 endif
                            
                            " if lazygit_use_custom_config_file_path is set to 1 the
                            " lazygit_config_file_path option will be evaluated
    1              0.000005 let g:lazygit_use_custom_config_file_path = 0
                            " path to custom config file
    1              0.000004 let g:lazygit_config_file_path = ''
                            
    1              0.000014 command! LazyGit lua require'lazygit'.lazygit()
                            
    1              0.000011 command! LazyGitCurrentFile lua require'lazygit'.lazygitcurrentfile()
                            
    1              0.000010 command! LazyGitFilter lua require'lazygit'.lazygitfilter()
                            
    1              0.000013 command! LazyGitFilterCurrentFile lua require'lazygit'.lazygitfiltercurrentfile()
                            
    1              0.000009 command! LazyGitConfig lua require'lazygit'.lazygitconfig()
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1   0.000025   0.000018 let &cpoptions = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
    1              0.000011 let g:loaded_lazygit_vim = 1

FUNCTION  91()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:454
Called 135 times
Total time:   0.002960
 Self time:   0.002960

count  total (s)   self (s)
                                " Reset byte map for all regions.
                            
  135              0.000842     let s:V.Bytes = {}
                            
  135              0.000305     if a:update
                                    for r in self.active_regions() | call r.update_bytes_map() | endfor
  135              0.000116     endif

FUNCTION  <SNR>16_vm_persist()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/plugin/visual-multi.vim:76
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000011   if exists('g:VM_PERSIST') && !g:VM_persistent_registers
                                unlet g:VM_PERSIST
    1              0.000003   elseif g:VM_persistent_registers
                                let g:VM_PERSIST = deepcopy(g:Vm.registers)
    1              0.000001   endif

FUNCTION  <SNR>33_Highlight_Matching_Pair()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/plugin/matchparen.vim:39
Called 24426 times
Total time:  14.055300
 Self time:  13.535764

count  total (s)   self (s)
                              " Remove any previous match.
24426   1.884129   1.364592   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
24426              0.175612   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
  103              0.000178     return
24323              0.019001   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
24323              0.127270   let c_lnum = line('.')
24323              0.104134   let c_col = col('.')
24323              0.058750   let before = 0
                            
24323              0.121022   let text = getline(c_lnum)
24323              1.906748   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
24323              0.100498   if empty(matches)
                                let [c_before, c] = ['', '']
24323              0.028846   else
24323              0.181251     let [c_before, c] = matches[1:2]
24323              0.027243   endif
24323              1.244414   let plist = split(&matchpairs, '.\zs[:,]')
24323              0.143316   let i = index(plist, c)
24323              0.057429   if i < 0
                                " not found, in Insert mode try character before the cursor
18100              0.099153     if c_col > 1 && (mode() == 'i' || mode() == 'R')
11591              0.051885       let before = strlen(c_before)
11591              0.027633       let c = c_before
11591              0.044084       let i = index(plist, c)
18100              0.017171     endif
18100              0.029256     if i < 0
                                  " not found, nothing to do
17685              0.027244       return
  415              0.000377     endif
 6638              0.004977   endif
                            
                              " Figure out the arguments for searchpairpos().
 6638              0.014139   if i % 2 == 0
  615              0.001568     let s_flags = 'nW'
  615              0.002633     let c2 = plist[i + 1]
 6023              0.005356   else
 6023              0.013986     let s_flags = 'nbW'
 6023              0.014689     let c2 = c
 6023              0.022152     let c = plist[i - 1]
 6638              0.006287   endif
 6638              0.012001   if c == '['
   59              0.000087     let c = '\['
   59              0.000079     let c2 = '\]'
 6638              0.004745   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
 6638              0.011223   if before > 0
  415              0.002700     let has_getcurpos = exists("*getcurpos")
  415              0.000933     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
  415              0.002622       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
  415              0.000392     endif
  415              0.002795     call cursor(c_lnum, c_col - before)
 6638              0.005355   endif
                            
 6638              0.057927   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
 6638              0.005176   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
 6638              0.041699     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
 6638              0.009732     try
 6638              3.451751       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
 6638              0.009690     endtry
 6638              0.005477   endif
                            
                              " Limit the search to lines visible in the window.
 6638              0.036466   let stoplinebottom = line('w$')
 6638              0.026691   let stoplinetop = line('w0')
 6638              0.017321   if i % 2 == 0
  615              0.002757     let stopline = stoplinebottom
 6023              0.005187   else
 6023              0.024866     let stopline = stoplinetop
 6638              0.005963   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
 6638              0.028704   if mode() == 'i' || mode() == 'R'
 5681              0.046106     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
  957              0.000769   else
  957              0.006203     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
 6638              0.005577   endif
 6638              0.006752   try
 6638              2.093314     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
 6638              0.009232   endtry
                            
 6638              0.013507   if before > 0
  415              0.000808     if has_getcurpos
  415              0.002755       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
  415              0.000394     endif
 6638              0.004585   endif
                            
                              " If a match is found setup match highlighting.
 6638              0.030934   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
 6513              0.026368     if exists('*matchaddpos')
 6513              0.081500       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
 6513              0.005051     endif
 6513              0.019269     let w:paren_hl_on = 1
 6638              0.006056   endif

FUNCTION  vm#themes#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/themes.vim:15
Called 1 time
Total time:   0.000364
 Self time:   0.000337

count  total (s)   self (s)
    1              0.000021   if !exists('g:Vm') | return | endif
                            
    1              0.000007   if !empty(g:VM_highlight_matches)
    1              0.000025     let out = execute('highlight Search')
    1              0.000023     if match(out, ' links to ') >= 0
                                  let hi = substitute(out, '^.*links to ', '', '')
                                  let g:Vm.search_hi = "link Search " . hi
    1              0.000002     else
    1              0.000036       let hi = strtrans(substitute(out, '^.*xxx ', '', ''))
    1              0.000014       let hi = substitute(hi, '\^.', '', 'g')
    1              0.000009       let g:Vm.search_hi = "Search " . hi
    1              0.000002     endif
                            
    1   0.000060   0.000034     call vm#themes#search_highlight()
    1              0.000002   endif
                            
    1              0.000004   let g:Vm.hi.mono    = 'VM_Mono'
    1              0.000003   let g:Vm.hi.cursor  = 'VM_Cursor'
    1              0.000003   let g:Vm.hi.extend  = 'VM_Extend'
    1              0.000004   let g:Vm.hi.insert  = 'VM_Insert'
    1              0.000009   let g:Vm.hi.message = get(g:, 'VM_Message_hl', 'WarningMsg')
                            
    1              0.000006   if exists('g:VM_theme_set_by_colorscheme')
                                unlet g:VM_theme_set_by_colorscheme
                                highlight! link MultiCursor VM_Cursor
                                return
    1              0.000001   endif
                            
    1              0.000006   let theme = get(g:, 'VM_theme', 'default')
                            
    1              0.000016   silent! hi clear VM_Mono
    1              0.000005   silent! hi clear VM_Cursor
    1              0.000008   silent! hi clear VM_Extend
    1              0.000003   silent! hi clear VM_Insert
    1              0.000003   silent! hi clear MultiCursor
                            
    1              0.000004   if theme == 'default'
    1              0.000016     exe "highlight! link VM_Mono     ".get(g:, 'VM_Mono_hl',   'ErrorMsg')
    1              0.000010     exe "highlight! link VM_Cursor   ".get(g:, 'VM_Cursor_hl', 'Visual')
    1              0.000009     exe "highlight! link VM_Extend   ".get(g:, 'VM_Extend_hl', 'PmenuSel')
    1              0.000009     exe "highlight! link VM_Insert   ".get(g:, 'VM_Insert_hl', 'DiffChange')
    1              0.000009     exe "highlight! link MultiCursor ".get(g:, 'VM_Cursor_hl', 'Visual')
    1              0.000002     return
                              endif
                            
                              call s:Themes[theme]()
                              highlight! link MultiCursor VM_Cursor

FUNCTION  remote#host#RegisterClone()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/remote/host.vim:19
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000017   if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
    2              0.000002   endif
    2              0.000015   let Factory = s:hosts[a:orig_name].factory
    2              0.000024   let s:hosts[a:name] = { 'factory': Factory, 'channel': 0, 'initialized': 0, 'orig_name': a:orig_name }

FUNCTION  1()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:46
Called 17 times
Total time:   0.028354
 Self time:   0.000255

count  total (s)   self (s)
                                " Enable mappings in current buffer.
   17              0.000047     if !g:Vm.mappings_enabled
   17              0.000043         let g:Vm.mappings_enabled = 1
   17   0.028212   0.000113         call self.start()
   17              0.000021     endif

FUNCTION  2()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:55
Called 17 times
Total time:   0.031863
 Self time:   0.000460

count  total (s)   self (s)
                                " Disable mappings in current buffer.
   17              0.000100     if g:Vm.mappings_enabled
   17              0.000064         let g:Vm.mappings_enabled = 0
   17   0.031601   0.000199         call self.end(a:keep_permanent)
   17              0.000015     endif

FUNCTION  4()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:80
Called 17 times
Total time:   0.028099
 Self time:   0.028047

count  total (s)   self (s)
                                " Apply mappings in current buffer.
  204              0.002538     for m in g:Vm.maps.permanent | exe m | endfor
 7905              0.024246     for m in b:VM_maps           | exe m | endfor
                            
   17              0.000074     nmap              <nowait> <buffer> :          <Plug>(VM-:)
   17              0.000070     nmap              <nowait> <buffer> /          <Plug>(VM-/)
   17              0.000070     nmap              <nowait> <buffer> ?          <Plug>(VM-?)
                            
                                " user autocommand after mappings have been set
   17   0.000190   0.000138     silent doautocmd <nomodeline> User visual_multi_mappings

FUNCTION  5()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:94
Called 17 times
Total time:   0.000778
 Self time:   0.000778

count  total (s)   self (s)
                                " Esc and 'toggle' keys are handled separately.
   17              0.000168     if !has('nvim') && !has('gui_running')
                                    nnoremap <nowait><buffer> <esc><esc> <esc><esc>
   17              0.000013     endif
   17              0.000292     exe 'nmap <nowait><buffer>' g:Vm.maps.exit '<Plug>(VM-Exit)'
   17              0.000233     exe 'nmap <nowait><buffer>' g:Vm.maps.toggle '<Plug>(VM-Toggle-Mappings)'

FUNCTION  6()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:110
Called 17 times
Total time:   0.031403
 Self time:   0.031403

count  total (s)   self (s)
                                " Remove mappings in current buffer.
 1377              0.003368     for m in g:Vm.unmaps | exe m | endfor
 7905              0.024814     for m in b:VM_unmaps | exe m | endfor
                            
   17              0.000066     nunmap <buffer> :
   17              0.000053     nunmap <buffer> /
   17              0.000055     nunmap <buffer> ?
   17              0.000186     silent! cunmap <buffer> <cr>
   17              0.000169     silent! cunmap <buffer> <esc>
                            
                                " restore permanent mappings
   17              0.000058     if a:keep_permanent
  204              0.001322         for m in g:Vm.maps.permanent | exe m | endfor
   17              0.000017     endif

FUNCTION  7()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:128
Called 17 times
Total time:   0.000702
 Self time:   0.000702

count  total (s)   self (s)
                                " Esc and 'toggle' keys are handled separately.
   17              0.000248     silent! exe 'nunmap <buffer>' g:Vm.maps.toggle
   17              0.000163     silent! exe 'nunmap <buffer>' g:Vm.maps.exit
   17              0.000160     if !has('nvim') && !has('gui_running')
                                    silent! nunmap <buffer> <esc><esc>
   17              0.000018     endif

FUNCTION  8()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/clipboard.vim:22
Called 109 times
Total time:   0.003978
 Self time:   0.003978

count  total (s)   self (s)
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
  109              0.001201   if self.owner == a:jobid
  109              0.000678     let self.owner = 0
  109              0.000137   endif
  109              0.000169   if a:data != 0
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
  109              0.000073   endif

FUNCTION  9()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/clipboard.vim:164
Called 18 times
Total time:   0.000565
 Self time:   0.000565

count  total (s)   self (s)
   18              0.000194   if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
   18              0.000130   elseif s:selections[a:reg].owner > 0
   18              0.000083     return s:selections[a:reg].data
                              end
                            
                              let clipboard_data = s:try_cmd(s:paste[a:reg])
                              if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0 && type(clipboard_data) == v:t_list && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
                                return s:selections[a:reg].data
                              end
                              return clipboard_data

FUNCTION  vm#special#commands#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/special/commands.vim:390
Called 17 times
Total time:   0.006253
 Self time:   0.005370

count  total (s)   self (s)
                              " Initialize {{{1
   17              0.004755   let s:V = b:VM_Selection
   17              0.000082   let s:F = s:V.Funcs
   17              0.000036   let s:G = s:V.Global
   17   0.001345   0.000462   call s:set_commands()

FUNCTION  <SNR>89_do_reindent()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:593
Called 14 times
Total time:   0.000847
 Self time:   0.000756

count  total (s)   self (s)
                                " Check if lines must be reindented when exiting insert mode.
   14              0.000217     if empty(&ft) | return | endif
                            
   14   0.000554   0.000463     return index(vm#comp#no_reindents(), &ft) < 0 && index(g:VM_reindent_filetypes, &ft) >= 0

FUNCTION  <SNR>74_init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:16
Called 52 times
Total time:   0.417462
 Self time:   0.004527

count  total (s)   self (s)
                                " Ensure the buffer is initialized, set starting options.
   52              0.000470     if a:extend_mode | let g:Vm.extend_mode = 1 | endif
                            
   52              0.000132     if g:Vm.buffer
   35   0.000838   0.000362         call s:F.Scroll.get()
   35              0.000247         if s:v.using_regex | call vm#commands#regex_reset() | endif
   35              0.000130         let s:v.whole_word = a:whole
   35              0.000082         return 1    " return true if already initialized
   17              0.000021     else
   17   0.413978   0.002195         let error = vm#init_buffer(a:type)
   17              0.000117         if type(error) == v:t_string | throw error | endif
   17   0.000837   0.000160         call s:F.Scroll.get()
   17              0.000052         let s:v.whole_word = a:whole
   17              0.000014     endif

FUNCTION  provider#pythonx#DetectByModule()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/pythonx.vim:39
Called 1 time
Total time:   0.083956
 Self time:   0.000259

count  total (s)   self (s)
    1   0.000067   0.000026   let python_exe = s:get_python_executable_from_host_var(a:major_version)
                            
    1              0.000007   if !empty(python_exe)
                                return [exepath(expand(python_exe, v:true)), '']
    1              0.000002   endif
                            
    1   0.000039   0.000021   let candidates = s:get_python_candidates(a:major_version)
    1              0.000004   let errors = []
                            
    7              0.000013   for exe in candidates
    6   0.083737   0.000099     let [result, error] = provider#pythonx#CheckForModule(exe, a:module, a:major_version)
    6              0.000008     if result
                                  return [exe, error]
    6              0.000003     endif
                                " Accumulate errors in case we don't find any suitable Python executable.
    6              0.000022     call add(errors, error)
    7              0.000008   endfor
                            
                              " No suitable Python executable found.
    1              0.000011   return ['', 'Could not load Python '.a:major_version.":\n".join(errors, "\n")]

FUNCTION  <SNR>7_filetype()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:36
Called 286 times
Total time:   0.063527
 Self time:   0.056240

count  total (s)   self (s)
  286   0.012858   0.005571 	let l:f = s:filename()
                            
  286              0.001136 	let s:start	= '#'
  286              0.000841 	let s:end	= '#'
  286              0.000565 	let s:fill	= '*'
                            
 2574              0.006112 	for type in keys(s:types)
 2288              0.022410 		if l:f =~ type
  286              0.001347 			let s:start	= s:types[type][0]
  286              0.000826 			let s:end	= s:types[type][1]
  286              0.000755 			let s:fill	= s:types[type][2]
 2288              0.001364 		endif
 2574              0.001884 	endfor
                            

FUNCTION  203()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:413
Called 99 times
Total time:   0.020054
 Self time:   0.003328

count  total (s)   self (s)
                                " Update cursor to current position.
   99              0.001107     let [ self.l, self.a ] = getpos('.')[1:2]
   99   0.005652   0.001199     call s:fix_pos(self)
   99   0.013092   0.000820     call self.update_vars()

FUNCTION  vm#special#case#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/special/case.vim:5
Called 17 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
   17              0.000075   let s:V = b:VM_Selection
   17              0.000053   return s:Case

FUNCTION  VMInfos()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/plugin/visual-multi.vim:97
Called 22 times
Total time:   0.001110
 Self time:   0.001110

count  total (s)   self (s)
   22              0.000135     if !exists('b:VM_Selection') || empty(b:VM_Selection)
                                    return {}
   22              0.000016     endif
                            
   22              0.000066     let infos = {}
   22              0.000051     let VM = b:VM_Selection
                            
   22              0.000071     let m = g:Vm.mappings_enabled ?    'M' : 'm'
   22              0.000063     let s = VM.Vars.single_region ?    'S' : 's'
   22              0.000055     let l = VM.Vars.multiline ?        'V' : 'v'
                            
   22              0.000093     let infos.current = VM.Vars.index + 1
   22              0.000093     let infos.total = len(VM.Regions)
   22              0.000117     let infos.ratio = infos.current . ' / ' . infos.total
   22              0.000069     let infos.patterns = VM.Vars.search
   22              0.000090     let infos.status = m.s.l
   22              0.000041     return infos

FUNCTION  <SNR>74_skip_shorter_lines()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:58
Called 30 times
Total time:   0.021721
 Self time:   0.001267

count  total (s)   self (s)
                                " When adding cursors below or above, don't add on shorter lines.
                                " we don't want cursors on final column('$'), except when adding at column 1
                                " in this case, moving to an empty line would give:
                                "   vcol     = 1
                                "   col      = 1
                                "   endline  = 1
                                " and the line would be skipped: check endline as 2, so that the cursor is added
                            
   30              0.000162     if get(g:, 'VM_skip_shorter_lines', 1)
   30              0.000099         let vcol    = s:v.vertical_col
   30              0.000120         let col     = virtcol('.')
   30              0.000306         let endline = get(g:, 'VM_skip_empty_lines', 0) ? virtcol('$') :                                     virtcol('$') > 1 ?                                     virtcol('$') : 2
                            
                                    "skip line
   30              0.000160         if ( col < vcol || col == endline ) | return 1 | endif
   28              0.000019     endif
                            
   28   0.020637   0.000182     call s:G.new_cursor()

FUNCTION  vm#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:36
Called 17 times
Total time:   0.314220
 Self time:   0.026151

count  total (s)   self (s)
                                " If already initialized, return current instance.
   17              0.000113     let v:errmsg = ""
   17              0.000031     try
   17              0.000137         if exists('b:visual_multi') | return s:V | endif
                            
   17              0.000208         let b:VM_Selection = {'Vars': {}, 'Regions': [], 'Bytes': {}}
   17              0.000074         let b:visual_multi = 1
                            
   17              0.000175         let b:VM_Debug  = get(b:, 'VM_Debug', {'lines': []})
   17              0.002456         let b:VM_Backup = {'ticks': [], 'last': 0, 'first': undotree().seq_cur}
                            
                                    " funcs script must be sourced first
   17              0.000101         let s:V       = b:VM_Selection
   17              0.000083         let s:v       = s:V.Vars
   17   0.002598   0.001997         let s:V.Funcs = vm#funcs#init()
                            
                                    " init plugin variables
   17   0.008717   0.001801         call vm#variables#init()
                            
   17              0.000126         if get(g:, 'VM_filesize_limit', 0) && s:V.Funcs.size() > gVM_filesize_limit
                                        call vm#variables#reset_globals()
                                        let v:errmsg = 'VM cannot start, buffer too big.'
                                        return v:errmsg
   17              0.000016         endif
                            
                                    " init search register
   17              0.000077         let @/ = a:cmd_type ? '' : @/
                            
                                    " hooks and compatibility tweaks before applying mappings
   17   0.005259   0.001761         call vm#comp#init()
                            
                                    " init classes
   17   0.223242   0.000238         let s:V.Maps   = vm#maps#init()
   17   0.003145   0.001955         let s:V.Global = vm#global#init()
   17   0.002329   0.001837         let s:V.Search = vm#search#init()
   17   0.009514   0.001601         let s:V.Edit   = vm#edit#init()
   17   0.002113   0.001381         let s:V.Insert = vm#insert#init()
   17   0.002288   0.002011         let s:V.Case   = vm#special#case#init()
                            
   17   0.028463   0.000109         call s:V.Maps.enable()
                            
   17   0.002562   0.001840         call vm#region#init()
   17   0.000424   0.000160         call vm#commands#init()
   17   0.002196   0.001718         call vm#operators#init()
   17   0.008324   0.001731         call vm#special#commands#init()
                            
   17   0.002069   0.000188         call vm#augroup(0)
   17   0.000920   0.000163         call vm#au_cursor(0)
                            
                                    " set vim variables
   17   0.003441   0.000167         call vm#variables#set()
                            
   17              0.000063         if !empty(g:VM_highlight_matches)
   17              0.000058             if !has_key(g:Vm, 'Search')
                                            call vm#themes#init()
   17              0.000016             else
   17   0.000539   0.000206                 call vm#themes#search_highlight()
   17              0.000020             endif
   17              0.000087             hi clear Search
   17              0.000172             exe 'hi! ' . g:Vm.Search
   17              0.000015         endif
                            
   17              0.000050         if !v:hlsearch && a:cmd_type != 2
                                        call s:enable_hls()
   17              0.000015         endif
                            
   17   0.000740   0.000160         call s:V.Funcs.set_statusline(0)
                            
                                    " backup sync settings for the buffer
   17              0.000071         if !exists('b:VM_sync_minlines')
    6   0.000266   0.000053             let b:VM_sync_minlines = s:V.Funcs.sync_minlines()
   17              0.000015         endif
                            
   17              0.000069         let g:Vm.buffer = bufnr('')
   17              0.000042         return s:V
                                catch
                                    let v:errmsg = 'VM cannot start, unhandled exception.'
                                    call vm#variables#reset_globals()
                                    return v:errmsg
   17              0.000029     endtry

FUNCTION  206()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:455
Called 469 times
Total time:   0.063199
 Self time:   0.043612

count  total (s)   self (s)
                                " Update the rest of the region variables.
                            
  469              0.001663     let r         = self
  469              0.001589     let s:v.index = r.index
                            
                                "   "--------- cursor mode ----------------------------
                            
  469   0.005871   0.005150     if !s:X()
  469              0.002716         let r.L   = r.l              | let r.b = r.a
  469   0.009856   0.005696         let r.A   = r.A_()           | let r.B = r.A
  469              0.002223         let r.k   = r.a              | let r.K = r.A
  469              0.001937         let r.w   = 0                | let r.h = 0
  469   0.024414   0.009708         let r.txt = ''               | let r.pat = s:pattern(r)
                            
                                    "--------- extend mode ----------------------------
                            
                                else
                                    let r.A   = r.A_()           | let r.B = r.B_()
                                    let r.w   = r.B - r.A + 1    | let r.h = r.L - r.l
                                    let r.k   = r.dir? r.a : r.b | let r.K   = r.dir? r.A : r.B
                            
                                    call r.update_bytes_map()
  469              0.000448     endif

FUNCTION  vm#ecmds1#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/ecmds1.vim:8
Called 17 times
Total time:   0.002454
 Self time:   0.001951

count  total (s)   self (s)
   17              0.000090     let s:V       = b:VM_Selection
   17              0.000041     let s:v       = s:V.Vars
   17              0.000033     let s:G       = s:V.Global
   17              0.000039     let s:F       = s:V.Funcs
                            
   17   0.002217   0.001713     return extend(s:Edit, vm#ecmds2#init())

FUNCTION  vm#variables#set()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/variables.vim:4
Called 17 times
Total time:   0.003275
 Self time:   0.002080

count  total (s)   self (s)
   17              0.000075   let F = b:VM_Selection.Funcs
   17              0.000045   let v = b:VM_Selection.Vars
                            
                              " disable folding, but keep winline
   17              0.000045   if &foldenable
    6   0.000106   0.000046     call F.Scroll.get(1)
    6              0.000013     let v.oldfold = 1
    6   0.000150   0.000061     set nofoldenable
    6   0.000444   0.000038     call F.Scroll.restore()
   17              0.000014   endif
                            
   17              0.000048   if g:VM_case_setting ==? 'smart'
                                set smartcase
                                set ignorecase
   17              0.000041   elseif g:VM_case_setting ==? 'sensitive'
                                set nosmartcase
                                set noignorecase
   17              0.000031   elseif g:VM_case_setting ==? 'ignore'
                                set nosmartcase
                                set ignorecase
   17              0.000012   endif
                            
                              "force default register
   17   0.000390   0.000193   set clipboard=
                            
                              "disable conceal
   17   0.000516   0.000308   let &l:conceallevel = vm#comp#conceallevel()
   17   0.000219   0.000153   set concealcursor=
                            
   17   0.000291   0.000213   set virtualedit=onemore
   17   0.000144   0.000111   set ww=h,l,<,>
   17   0.000247   0.000189   set lz
                            
   17              0.000101   if get(g:, 'VM_cmdheight', 1) > 1
                                let &ch = g:VM_cmdheight
   17              0.000013   endif

FUNCTION  vm#ecmds2#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/ecmds2.vim:7
Called 17 times
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
   17              0.000079     let s:V       = b:VM_Selection
   17              0.000038     let s:v       = s:V.Vars
   17              0.000032     let s:G       = s:V.Global
   17              0.000030     let s:F       = s:V.Funcs
   17              0.000047     return s:Edit

FUNCTION  vm#comp#icmds()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:59
Called 46 times
Total time:   0.001282
 Self time:   0.001282

count  total (s)   self (s)
                                " Insert mode starts: temporarily disable autocompletion engines. {{{1
   46              0.000345     if exists('g:loaded_deoplete') && g:deoplete#is_enabled()
                                    call deoplete#disable()
                                    let s:disabled_deoplete = 1
   46              0.000228     elseif exists('b:ncm2_enable') && b:ncm2_enable
                                    let b:ncm2_enable = 0
                                    let s:disabled_ncm2 = 1
   46              0.000044     endif

FUNCTION  208()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:529
Called 635 times
Total time:   0.028012
 Self time:   0.028012

count  total (s)   self (s)
                                " Remove the highlight entries.
  635              0.002723     let r       = self.matches.region
  635              0.001826     let c       = self.matches.cursor
                            
 1905              0.013855     for m in r | silent! call matchdelete(m) | endfor
  635              0.005467     silent! call matchdelete(c)

FUNCTION  vm#maps#all#buffer()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps/all.vim:80
Called 6 times
Total time:   0.003428
 Self time:   0.003428

count  total (s)   self (s)
                              """Default buffer mappings dictionary."""
                            
    6              0.000021   let maps = {}
    6              0.000035   let leader = g:Vm.leader.buffer
    6              0.000019   let visual = g:Vm.leader.visual
                            
                              "basic
    6              0.000106   call extend(maps, {"Switch Mode":             ['<Tab>',       'n'],"Toggle Single Region":    [leader.'<CR>', 'n'],})
                            
                              "select
    6              0.000260   call extend(maps, {"Find Next":               ['n',         'n'],"Find Prev":               ['N',         'n'],"Goto Next":               [']',         'n'],"Goto Prev":               ['[',         'n'],"Seek Up":                 ['<C-b>',     'n'],"Seek Down":               ['<C-f>',     'n'],"Skip Region":             ['q',         'n'],"Remove Region":           ['Q',         'n'],"Remove Last Region":      [leader.'q',  'n'],"Remove Every n Regions":  [leader.'R',  'n'],"Select Operator":         ['s',         'n'],"Find Operator":           ['m',         'n'],})
                            
                              "utility
    6              0.000311   call extend(maps, {"Tools Menu":              [leader.'`',      'n'],"Show Registers":          [leader.'"',      'n'],"Case Setting":            [leader.'c',      'n'],"Toggle Whole Word":       [leader.'w',      'n'],"Case Conversion Menu":    [leader.'C',      'n'],"Search Menu":             [leader.'S',      'n'],"Rewrite Last Search":     [leader.'r',      'n'],"Show Infoline":           [leader.'l',      'n'],"One Per Line":            [leader.'L',      'n'],"Filter Regions":          [leader.'f',      'n'],"Toggle Multiline":        ['M',             'n'],})
                            
                              "commands
    6              0.000788   call extend(maps, {"Undo":                    ['',          'n'],"Redo":                    ['',          'n'],"Surround":                ['S',         'n'],"Merge Regions":           [leader.'m',  'n'],"Transpose":               [leader.'t',  'n'],"Rotate":                  ['',          'n'],"Duplicate":               [leader.'d',  'n'],"Align":                   [leader.'a',  'n'],"Split Regions":           [leader.'s',  'n'],"Visual Subtract":         [visual.'s',  'x'],"Visual Reduce":           [visual.'r',  'x'],"Run Normal":              [leader.'z',  'n'],"Run Last Normal":         [leader.'Z',  'n'],"Run Visual":              [leader.'v',  'n'],"Run Last Visual":         [leader.'V',  'n'],"Run Ex":                  [leader.'x',  'n'],"Run Last Ex":             [leader.'X',  'n'],"Run Macro":               [leader.'@',  'n'],"Run Dot":                 [leader.'.',  'n'],"Align Char":              [leader.'<',  'n'],"Align Regex":             [leader.'>',  'n'],"Numbers":                 [leader.'N',  'n'],"Numbers Append":          [leader.'n',  'n'],"Zero Numbers":            [leader.'0N', 'n'],"Zero Numbers Append":     [leader.'0n', 'n'],"Shrink":                  [leader.'-',  'n'],"Enlarge":                 [leader.'+',  'n'],"Goto Regex":              [leader.'g',  'n'],"Goto Regex!":             [leader.'G',  'n'],"Slash Search":            ['g/',        'n'],})
                            
                              "arrows
    6              0.000391   call extend(maps, {"Select Cursor Down":      ['<M-C-Down>',  'n'],"Select Cursor Up":        ['<M-C-Up>',    'n'],"Add Cursor Down":         ['<C-Down>',    'n'],"Add Cursor Up":           ['<C-Up>',      'n'],"Select j":                ['<S-Down>',    'n'],"Select k":                ['<S-Up>',      'n'],"Select l":                ['<S-Right>',   'n'],"Select h":                ['<S-Left>',    'n'],"Single Select l":         ['<M-Right>',   'n'],"Single Select h":         ['<M-Left>',    'n'],"Select e":                ['',            'n'],"Select ge":               ['',            'n'],"Select w":                ['',            'n'],"Select b":                ['',            'n'],"Select E":                ['',            'n'],"Select BBW":              ['',            'n'],"Move Right":              ['<M-S-Right>', 'n'],"Move Left":               ['<M-S-Left>',  'n'],})
                            
                              "insert
    6              0.000526   call extend(maps, {"I Arrow w":               ['<C-Right>',   'i'],"I Arrow b":               ['<C-Left>',    'i'],"I Arrow W":               ['<C-S-Right>', 'i'],"I Arrow B":               ['<C-S-Left>',  'i'],"I Arrow ge":              ['<C-Up>',      'i'],"I Arrow e":               ['<C-Down>',    'i'],"I Arrow gE":              ['<C-S-Up>',    'i'],"I Arrow E":               ['<C-S-Down>',  'i'],"I Left Arrow":            ['<Left>',      'i'],"I Right Arrow":           ['<Right>',     'i'],"I Up Arrow":              ['<Up>',        'i'],"I Down Arrow":            ['<Down>',      'i'],"I Return":                ['<CR>',        'i'],"I BS":                    ['<BS>',        'i'],"I CtrlW":                 ['<C-w>',       'i'],"I CtrlU":                 ['<C-u>',       'i'],"I CtrlD":                 ['<C-d>',       'i'],"I Ctrl^":                 ['<C-^>',       'i'],"I Del":                   ['<Del>',       'i'],"I Home":                  ['<Home>',      'i'],"I End":                   ['<End>',       'i'],"I CtrlB":                 ['<C-b>',       'i'],"I CtrlF":                 ['<C-f>',       'i'],"I CtrlC":                 ['<C-c>',       'i'],"I CtrlO":                 ['<C-o>',       'i'],"I Replace":               ['<Insert>',    'i'],})
                            
    6              0.000047   let insert_keys = get(g:, 'VM_insert_special_keys', ['c-v'])
    6              0.000032   if index(insert_keys, 'c-a') >= 0
                                let maps["I CtrlA"] = ['<C-a>', 'i']
    6              0.000006   endif
    6              0.000020   if index(insert_keys, 'c-e') >= 0
                                let maps["I CtrlE"] = ['<C-e>', 'i']
    6              0.000004   endif
    6              0.000019   if index(insert_keys, 'c-v') >= 0
    6              0.000030     let maps["I Paste"] = ['<C-v>', 'i']
    6              0.000006   endif
                            
                              "edit
    6              0.000639   call extend(maps, {"D":                       ['D',           'n'],"Y":                       ['Y',           'n'],"x":                       ['x',           'n'],"X":                       ['X',           'n'],"J":                       ['J',           'n'],"~":                       ['~',           'n'],"&":                       ['&',           'n'],"Del":                     ['<del>',       'n'],"Dot":                     ['.',           'n'],"Increase":                ['<C-a>',       'n'],"Decrease":                ['<C-x>',       'n'],"gIncrease":               ['g<C-a>',      'n'],"gDecrease":               ['g<C-x>',      'n'],"Alpha Increase":          [leader.'<C-a>','n'],"Alpha Decrease":          [leader.'<C-x>','n'],"a":                       ['a',           'n'],"A":                       ['A',           'n'],"i":                       ['i',           'n'],"I":                       ['I',           'n'],"o":                       ['o',           'n'],"O":                       ['O',           'n'],"c":                       ['c',           'n'],"gc":                      ['gc',          'n'],"gu":                      ['gu',          'n'],"gU":                      ['gU',          'n'],"C":                       ['C',           'n'],"Delete":                  ['d',           'n'],"Replace Characters":      ['r',           'n'],"Replace":                 ['R',           'n'],"Transform Regions":       [leader.'e',    'n'],"p Paste":                 ['p',           'n'],"P Paste":                 ['P',           'n'],"Yank":                    ['y',           'n'],})
                            
    6              0.000017   return maps

FUNCTION  <SNR>74_after_move()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:629
Called 25 times
Total time:   0.044391
 Self time:   0.001283

count  total (s)   self (s)
   25              0.000143     let s:v.direction = a:R.dir
   25              0.000090     let s:v.restore_scroll = !s:v.insert
                            
   25              0.000046     if s:v.merge
   25   0.002405   0.000210         call s:G.select_region(a:R.index)
   25   0.001070   0.000215         call s:F.Scroll.get(1)
   25   0.040303   0.000246         call s:G.update_and_select_region(a:R.A)
                                else
                                    call s:F.restore_reg()
                                    call s:G.update_highlight()
                                    call s:G.select_region(a:R.index)
   25              0.000021     endif

FUNCTION  189()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:144
Called 514 times
Total time:   0.004442
 Self time:   0.004442

count  total (s)   self (s)
  514              0.003947     return line2byte(self.l) + self.a - 1

FUNCTION  <SNR>75_buffer_enter()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:261
Called 4 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    4              0.000082     if empty(get(b:, 'VM_Selection', {}))
    4              0.000025         let b:VM_Selection = {}
    4              0.000005     endif

FUNCTION  <SNR>7_insert()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:115
Called 3 times
Total time:   0.009049
 Self time:   0.007124

count  total (s)   self (s)
    3              0.000010 	let l:line = 11
                            
                            	" empty line after header
    3              0.000583 	call append(0, "")
                            
                            	" loop over lines
   36              0.000070 	while l:line > 0
   33   0.008168   0.006242 		call append(0, s:line(l:line))
   33              0.000131 		let l:line = l:line - 1
   36              0.000043 	endwhile

FUNCTION  vm#plugs#buffer()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/plugs.vim:42
Called 1 time
Total time:   0.004061
 Self time:   0.004061

count  total (s)   self (s)
                              " Plugs and mappings for <buffer> keys.
    1              0.000027   let g:Vm.motions        = ['h', 'j', 'k', 'l', 'w', 'W', 'b', 'B', 'e', 'E', ',', ';', '$', '0', '^', '%', 'ge', 'gE', '\|']
    1              0.000007   let g:Vm.find_motions   = ['f', 'F', 't', 'T']
    1              0.000016   let g:Vm.tobj_motions   = { '{': '{', '}': '}', '(': '(', ')': ')', 'g{': '[{', 'g}': ']}', 'g)': '])', 'g(': '[(' }
                            
    1              0.000034   nnoremap <silent>       <Plug>(VM-Select-Operator)         :<c-u>call vm#operators#select(v:count)<cr>
    1              0.000014   nmap <expr><silent>     <Plug>(VM-Find-Operator)           vm#operators#find(1, 0)
                            
    1              0.000017   xnoremap <silent>       <Plug>(VM-Visual-Subtract)         :<c-u>call vm#visual#subtract(visualmode())<cr>
    1              0.000012   nnoremap                <Plug>(VM-Split-Regions)           :<c-u>call vm#visual#split()<cr>
    1              0.000018   nnoremap <silent>       <Plug>(VM-Remove-Empty-Lines)      :<c-u>call vm#commands#remove_empty_lines()<cr>
    1              0.000016   nnoremap <silent>       <Plug>(VM-Goto-Regex)              :<c-u>call vm#commands#regex_motion('', v:count1, 0)<cr>
    1              0.000016   nnoremap <silent>       <Plug>(VM-Goto-Regex!)             :<c-u>call vm#commands#regex_motion('', v:count1, 1)<cr>
                            
    1              0.000018   nnoremap <silent>       <Plug>(VM-Toggle-Mappings)         :call b:VM_Selection.Maps.mappings_toggle()<cr>
    1              0.000017   nnoremap <silent>       <Plug>(VM-Toggle-Multiline)        :call b:VM_Selection.Funcs.toggle_option('multiline')<cr>
    1              0.000017   nnoremap <silent>       <Plug>(VM-Toggle-Whole-Word)       :call b:VM_Selection.Funcs.toggle_option('whole_word')<cr>
    1              0.000017   nnoremap <silent>       <Plug>(VM-Toggle-Single-Region)    :call b:VM_Selection.Funcs.toggle_option('single_region')<cr>
    1              0.000012   nnoremap <silent>       <Plug>(VM-Case-Setting)            :call b:VM_Selection.Search.case()<cr>
    1              0.000013   nnoremap <silent>       <Plug>(VM-Rewrite-Last-Search)     :call b:VM_Selection.Search.rewrite(1)<cr>
    1              0.000015   nnoremap <silent>       <Plug>(VM-Rewrite-All-Search)      :call b:VM_Selection.Search.rewrite(0)<cr>
    1              0.000016   nnoremap <silent>       <Plug>(VM-Read-From-Search)        :call b:VM_Selection.Search.get_slash_reg()<cr>
    1              0.000013   nnoremap <silent>       <Plug>(VM-Add-Search)              :call b:VM_Selection.Search.get_from_region()<cr>
    1              0.000015   nnoremap <silent>       <Plug>(VM-Remove-Search)           :call b:VM_Selection.Search.remove(0)<cr>
    1              0.000018   nnoremap <silent>       <Plug>(VM-Remove-Search-Regions)   :call b:VM_Selection.Search.remove(1)<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Search-Menu)             :call b:VM_Selection.Search.menu()<cr>
    1              0.000013   nnoremap <silent>       <Plug>(VM-Case-Conversion-Menu)    :call b:VM_Selection.Case.menu()<cr>
                            
    1              0.000020   nnoremap <silent>       <Plug>(VM-Show-Regions-Info)       :call b:VM_Selection.Funcs.regions_contents()<cr>
    1              0.000011   nnoremap <silent>       <Plug>(VM-Show-Registers)          :VMRegisters<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Tools-Menu)              :call vm#special#commands#menu()<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Filter-Regions)          :call vm#special#commands#filter_regions(0, '', 1)<cr>
    1              0.000016   nnoremap <silent>       <Plug>(VM-Regions-To-Buffer)       :call vm#special#commands#regions_to_buffer()<cr>
    1              0.000015   nnoremap <silent>       <Plug>(VM-Filter-Lines)            :call vm#special#commands#filter_lines(0)<cr>
    1              0.000018   nnoremap <silent>       <Plug>(VM-Filter-Lines-Strip)      :call vm#special#commands#filter_lines(1)<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Merge-Regions)           :call b:VM_Selection.Global.merge_regions()<cr>
    1              0.000017   nnoremap <silent>       <Plug>(VM-Switch-Mode)             :call b:VM_Selection.Global.change_mode(1)<cr>
    1              0.000017   nnoremap <silent>       <Plug>(VM-Exit)                    :<c-u><C-r>=b:VM_Selection.Vars.noh<CR>call vm#reset()<cr>
    1              0.000011   nnoremap <silent>       <Plug>(VM-Undo)                    :call vm#commands#undo()<cr>
    1              0.000013   nnoremap <silent>       <Plug>(VM-Redo)                    :call vm#commands#redo()<cr>
                            
    1              0.000015   nnoremap <silent>       <Plug>(VM-Goto-Next)               :call vm#commands#find_next(0, 1)<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Goto-Prev)               :call vm#commands#find_prev(0, 1)<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Find-Next)               :call vm#commands#find_next(0, 0)<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Find-Prev)               :call vm#commands#find_prev(0, 0)<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Seek-Up)                 :call vm#commands#seek_up()<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Seek-Down)               :call vm#commands#seek_down()<cr>
    1              0.000014   nnoremap <silent>       <Plug>(VM-Skip-Region)             :call vm#commands#skip(0)<cr>
    1              0.000012   nnoremap <silent>       <Plug>(VM-Remove-Region)           :call vm#commands#skip(1)<cr>
    1              0.000017   nnoremap <silent>       <Plug>(VM-Remove-Last-Region)      :call b:VM_Selection.Global.remove_last_region()<cr>
    1              0.000020   nnoremap <silent>       <Plug>(VM-Remove-Every-n-Regions)  :<c-u>call vm#commands#remove_every_n_regions(v:count)<cr>
    1              0.000017   nnoremap <silent>       <Plug>(VM-Show-Infoline)           :call b:VM_Selection.Funcs.infoline()<cr>
    1              0.000024   nnoremap <silent>       <Plug>(VM-One-Per-Line)            :call b:VM_Selection.Global.one_region_per_line()<bar>call b:VM_Selection.Global.update_and_select_region()<cr>
                            
    1              0.000012   nnoremap <silent>       <Plug>(VM-Hls)                     :set hls<cr>
                            
   20              0.000049   for m in g:Vm.motions
   19              0.000445     exe "nnoremap <silent> <Plug>(VM-Motion-".m.") :\<C-u>call vm#commands#motion('".m."', v:count1, 0, 0)\<cr>"
   19              0.000455     exe "nnoremap <silent> <Plug>(VM-Single-Motion-".m.") :\<C-u>call vm#commands#motion('".m."',v:count1, 0, 1)\<cr>"
   20              0.000033   endfor
                            
    5              0.000012   for m in g:Vm.find_motions
    4              0.000090     exe "nnoremap <silent> <Plug>(VM-Motion-".m.") :call vm#commands#find_motion('".m."', '')\<cr>"
    5              0.000008   endfor
                            
    1              0.000005   let tobj = g:Vm.tobj_motions
    9              0.000027   for m in keys(tobj)
    8              0.000197     exe "nnoremap <silent> <Plug>(VM-Motion-".m.") :\<C-u>call vm#commands#motion('".tobj[m]."', v:count1, 0, 0)\<cr>"
    9              0.000014   endfor
                            
   14              0.000032   for m in g:Vm.select_motions
   13              0.000311     exe "nnoremap <silent> <Plug>(VM-Single-Select-".m.") :\<C-u>call vm#commands#motion('".m."', v:count1, 1, 1)\<cr>"
   14              0.000022   endfor
                            
                              "make a dict with custom user operators, if they have been defined
                              "the key holds the operator, the value is the expected characters of the
                              "text object, 0 means any kind of text object
    1              0.000006   let g:Vm.user_ops = {}
    1              0.000009   for op in get(g:, 'VM_user_operators', [])
                                if type(op) == v:t_dict
                                  let key = keys(op)[0]
                                  let g:Vm.user_ops[key] = op[key]
                                else
                                  let key = op
                                  let g:Vm.user_ops[key] = 0
                                endif
                                exe "nnoremap <silent> <Plug>(VM-User-Operator-".key.") :\<C-u>call <sid>Operator('".key."', v:count1, v:register)\<cr>"
    1              0.000002   endfor
                            
    1              0.000005   let remaps = g:VM_custom_remaps
    1              0.000006   for m in keys(remaps)
                                exe "nmap <silent> <Plug>(VM-Remap-".remaps[m].") ".remaps[m]
    1              0.000001   endfor
                            
    1              0.000004   let noremaps = g:VM_custom_noremaps
    1              0.000005   for m in values(noremaps)
                                exe "nnoremap <silent> <Plug>(VM-Normal!-".m.") :\<C-u>call b:VM_Selection.Edit.run_normal('".m."', {'count': v:count1, 'recursive': 0})\<cr>"
    1              0.000001   endfor
                            
    1              0.000003   let cm = g:VM_custom_commands
    1              0.000005   for m in keys(cm)
                                exe "nnoremap <silent> <Plug>(VM-".m.") ".cm[m]
    1              0.000001   endfor
                            
    1              0.000017   nnoremap <silent>        <Plug>(VM-Shrink)                  :call vm#commands#shrink_or_enlarge(1)<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Enlarge)                 :call vm#commands#shrink_or_enlarge(0)<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Merge-To-Eol)            :call vm#commands#merge_to_beol(1, 0)<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Merge-To-Bol)            :call vm#commands#merge_to_beol(0, 0)<cr>
                            
                              "Edit commands
    1              0.000016   nnoremap <silent>        <Plug>(VM-D)                       :<C-u>call vm#cursors#operation('d', 0, v:register, 'd$')<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Y)                       :<C-u>call vm#cursors#operation('y', 0, v:register, 'y$')<cr>
    1              0.000019   nnoremap <silent>        <Plug>(VM-x)                       :<C-u>call b:VM_Selection.Edit.xdelete('x', v:count1)<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-X)                       :<C-u>call b:VM_Selection.Edit.xdelete('X', v:count1)<cr>
    1              0.000021   nnoremap <silent>        <Plug>(VM-J)                       :<C-u>call b:VM_Selection.Edit.run_normal('J', {'count': v:count1, 'recursive': 0})<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-~)                       :<C-u>call b:VM_Selection.Edit.run_normal('~', {'recursive': 0})<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-&)                       :<C-u>call b:VM_Selection.Edit.run_normal('&', {'recursive': 0, 'silent': 1})<cr>
    1              0.000021   nnoremap <silent>        <Plug>(VM-Del)                     :<C-u>call b:VM_Selection.Edit.run_normal('x', {'count': v:count1, 'recursive': 0})<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Dot)                     :<C-u>call b:VM_Selection.Edit.dot()<cr>
    1              0.000020   nnoremap <silent>        <Plug>(VM-Increase)                :<C-u>call vm#commands#increase_or_decrease(1, 0, v:count1, v:false)<cr>
    1              0.000020   nnoremap <silent>        <Plug>(VM-Decrease)                :<C-u>call vm#commands#increase_or_decrease(0, 0, v:count1, v:false)<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-gIncrease)               :<C-u>call vm#commands#increase_or_decrease(1, 0, v:count1, v:true)<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-gDecrease)               :<C-u>call vm#commands#increase_or_decrease(0, 0, v:count1, v:true)<cr>
    1              0.000021   nnoremap <silent>        <Plug>(VM-Alpha-Increase)          :<C-u>call vm#commands#increase_or_decrease(1, 1, v:count1, v:false)<cr>
    1              0.000018   nnoremap <silent>        <Plug>(VM-Alpha-Decrease)          :<C-u>call vm#commands#increase_or_decrease(0, 1, v:count1, v:false)<cr>
    1              0.000014   nnoremap <silent>        <Plug>(VM-a)                       :<C-u>call b:VM_Selection.Insert.key('a')<cr>
    1              0.000014   nnoremap <silent>        <Plug>(VM-A)                       :<C-u>call b:VM_Selection.Insert.key('A')<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-i)                       :<C-u>call b:VM_Selection.Insert.key('i')<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-I)                       :<C-u>call b:VM_Selection.Insert.key('I')<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-o)                       :<C-u>call <sid>O(0)<cr>
    1              0.000013   nnoremap <silent>        <Plug>(VM-O)                       :<C-u>call <sid>O(1)<cr>
    1              0.000021   nnoremap <silent>        <Plug>(VM-c)                       :<C-u>call b:VM_Selection.Edit.change(g:Vm.extend_mode, v:count1, v:register, 0)<cr>
    1              0.000022   nnoremap <silent>        <Plug>(VM-gc)                      :<C-u>call b:VM_Selection.Edit.change(g:Vm.extend_mode, v:count1, v:register, 1)<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-gu)                      :<C-u>call <sid>Operator('gu', v:count1, v:register)<cr>
    1              0.000018   nnoremap <silent>        <Plug>(VM-gU)                      :<C-u>call <sid>Operator('gU', v:count1, v:register)<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-C)                       :<C-u>call vm#cursors#operation('c', 0, v:register, 'c$')<cr>
    1              0.000021   nnoremap <silent>        <Plug>(VM-Delete)                  :<C-u>call b:VM_Selection.Edit.delete(g:Vm.extend_mode, v:register, v:count1, 1)<cr>
    1              0.000020   nnoremap <silent>        <Plug>(VM-Delete-Exit)             :<C-u>call b:VM_Selection.Edit.delete(g:Vm.extend_mode, v:register, v:count1, 1)<cr>:call vm#reset()<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-Replace-Characters)      :<C-u>call b:VM_Selection.Edit.replace_chars()<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Replace)                 :<C-u>call b:VM_Selection.Edit.replace()<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-Transform-Regions)       :<C-u>call b:VM_Selection.Edit.replace_expression()<cr>
    1              0.000040   nnoremap <silent>        <Plug>(VM-p-Paste)                 :call b:VM_Selection.Edit.paste(g:Vm.extend_mode, 0, g:Vm.extend_mode, v:register)<cr>
    1              0.000023   nnoremap <silent>        <Plug>(VM-P-Paste)                 :call b:VM_Selection.Edit.paste(               1, 0, g:Vm.extend_mode, v:register)<cr>
    1              0.000022   nnoremap <silent>        <Plug>(VM-p-Paste-Vimreg)          :call b:VM_Selection.Edit.paste(g:Vm.extend_mode, 1, g:Vm.extend_mode, v:register)<cr>
    1              0.000022   nnoremap <silent>        <Plug>(VM-P-Paste-Vimreg)          :call b:VM_Selection.Edit.paste(               1, 1, g:Vm.extend_mode, v:register)<cr>
    1              0.000013   nnoremap <silent> <expr> <Plug>(VM-Yank)                    <SID>Yank()
                            
    1              0.000015   nnoremap <silent>        <Plug>(VM-Move-Right)              :call b:VM_Selection.Edit.shift(1)<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Move-Left)               :call b:VM_Selection.Edit.shift(0)<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Transpose)               :call b:VM_Selection.Edit.transpose()<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Rotate)                  :call b:VM_Selection.Edit.rotate()<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Duplicate)               :call b:VM_Selection.Edit.duplicate()<cr>
                            
    1              0.000014   nnoremap <silent>        <Plug>(VM-Align)                   :<C-u>call vm#commands#align()<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Align-Char)              :<C-u>call vm#commands#align_char(v:count1)<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Align-Regex)             :<C-u>call vm#commands#align_regex()<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Numbers)                 :<C-u>call b:VM_Selection.Edit.numbers(v:count1, 0)<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Numbers-Append)          :<C-u>call b:VM_Selection.Edit.numbers(v:count1, 1)<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Zero-Numbers)            :<C-u>call b:VM_Selection.Edit.numbers(v:count, 0)<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-Zero-Numbers-Append)     :<C-u>call b:VM_Selection.Edit.numbers(v:count, 1)<cr>
    1              0.000018   nnoremap <silent>        <Plug>(VM-Run-Dot)                 :<C-u>call b:VM_Selection.Edit.run_normal('.', {'count': v:count1, 'recursive': 0})<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Surround)                :<c-u>call b:VM_Selection.Edit.surround()<cr>
    1              0.000015   nnoremap <silent>        <Plug>(VM-Run-Macro)               :<c-u>call b:VM_Selection.Edit.run_macro()<cr>
    1              0.000014   nnoremap <silent>        <Plug>(VM-Run-Ex)                  @=b:VM_Selection.Edit.ex()<CR>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Run-Last-Ex)             :<C-u>call b:VM_Selection.Edit.run_ex(g:Vm.last_ex)<cr>
    1              0.000017   nnoremap <silent>        <Plug>(VM-Run-Normal)              :<C-u>call b:VM_Selection.Edit.run_normal(-1, {'count': v:count1})<cr>
    1              0.000026   nnoremap <silent>        <Plug>(VM-Run-Last-Normal)         :<C-u>call b:VM_Selection.Edit.run_normal(g:Vm.last_normal[0], {'count': v:count1, 'recursive': g:Vm.last_normal[1]})<cr>
    1              0.000016   nnoremap <silent>        <Plug>(VM-Run-Visual)              :call b:VM_Selection.Edit.run_visual(-1, 1)<cr>
    1              0.000022   nnoremap <silent>        <Plug>(VM-Run-Last-Visual)         :call b:VM_Selection.Edit.run_visual(g:Vm.last_visual[0], g:Vm.last_visual[1])<cr>
                            
    1              0.000013   inoremap <silent><expr> <Plug>(VM-I-Arrow-w)          <sid>Insert('w')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Arrow-b)          <sid>Insert('b')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Arrow-W)          <sid>Insert('W')
    1              0.000012   inoremap <silent><expr> <Plug>(VM-I-Arrow-B)          <sid>Insert('B')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Arrow-e)          <sid>Insert('e')
    1              0.000012   inoremap <silent><expr> <Plug>(VM-I-Arrow-ge)         <sid>Insert('ge')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Arrow-E)          <sid>Insert('E')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Arrow-gE)         <sid>Insert('gE')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Left-Arrow)       <sid>Insert('h')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Right-Arrow)      <sid>Insert('l')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Up-Arrow)         <sid>Insert('k')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Down-Arrow)       <sid>Insert('j')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Return)           <sid>Insert('cr')
    1              0.000011   inoremap <silent><expr> <Plug>(VM-I-BS)               <sid>Insert('X')
    1              0.000010   inoremap <silent><expr> <Plug>(VM-I-Paste)            <sid>Insert('c-v')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlW)            <sid>Insert('c-w')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlU)            <sid>Insert('c-u')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlD)            <sid>Insert('x')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Del)              <sid>Insert('x')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Home)             <sid>Insert('0')
    1              0.000008   inoremap <silent><expr> <Plug>(VM-I-End)              <sid>Insert('A')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlE)            <sid>Insert('A')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Ctrl^)            <sid>Insert('I')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlA)            <sid>Insert('I')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlB)            <sid>Insert('h')
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlF)            <sid>Insert('l')
    1              0.000008   inoremap <silent>       <Plug>(VM-I-CtrlC)            <Esc>
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-CtrlO)            <sid>Insert('O')
    1              0.000008   inoremap <silent><expr> <Plug>(VM-I-Next)             vm#icmds#goto(1)
    1              0.000008   inoremap <silent><expr> <Plug>(VM-I-Prev)             vm#icmds#goto(0)
    1              0.000009   inoremap <silent><expr> <Plug>(VM-I-Replace)          <sid>Insert('ins')
                            
                              "Cmdline
    1              0.000015   nnoremap         <expr> <Plug>(VM-:)                  vm#commands#regex_reset(':')
    1              0.000014   nnoremap         <expr> <Plug>(VM-/)                  vm#commands#regex_reset('/')
    1              0.000016   nnoremap         <expr> <Plug>(VM-?)                  vm#commands#regex_reset('?')

FUNCTION  vm#special#commands#unset()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/special/commands.vim:409
Called 17 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
                              " Unset buffer commands. {{{1
   17              0.000067   delcommand VMFilterRegions
   17              0.000031   delcommand VMFilterLines
   17              0.000030   delcommand VMRegionsToBuffer
   17              0.000024   delcommand VMMassTranspose
   17              0.000032   delcommand VMQfix
   17              0.000034   delcommand VMSort

FUNCTION  htmlcomplete#DetectOmniFlavor()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/htmlcomplete.vim:9
Called 2 times
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
    2              0.000008   if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
    2              0.000002   else
    2              0.000005     let b:html_omni_flavor = 'html401t'
    2              0.000002   endif
    2              0.000003   let i = 1
    2              0.000003   let line = ""
   15              0.000042   while i < 10 && i < line("$")
   13              0.000036     let line = getline(i)
   13              0.000059     if line =~ '<!DOCTYPE.*\<DTD '
                                  break
   13              0.000006     endif
   13              0.000020     let i += 1
   15              0.000012   endwhile
    2              0.000008   if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
    2              0.000001   endif

FUNCTION  <SNR>91_vertical()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:273
Called 170 times
Total time:   0.001865
 Self time:   0.001865

count  total (s)   self (s)
  170              0.001656     return index(['j', 'k'], s:motion[0]) >=0

FUNCTION  <SNR>7_textline()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:57
Called 571 times
Total time:   0.013591
 Self time:   0.013591

count  total (s)   self (s)
  571              0.004155 	let l:left = strpart(a:left, 0, s:length - s:margin * 2 - strlen(a:right))
                            
  571              0.008379 	return s:start . repeat(' ', s:margin - strlen(s:start)) . l:left . repeat(' ', s:length - s:margin * 2 - strlen(l:left) - strlen(a:right)) . a:right . repeat(' ', s:margin - strlen(s:end)) . s:end

FUNCTION  vm#commands#merge_to_beol()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:516
Called 1 time
Total time:   0.004027
 Self time:   0.001366

count  total (s)   self (s)
                                " Entry point for 0/^/$ motions.
    1   0.000037   0.000013     if s:F.no_regions() | return | endif
    1   0.001349   0.001322     call s:G.cursor_mode()
                            
    1              0.000010     let s:v.motion = a:eol? "\<End>" : '^'
    1              0.000003     let s:v.merge = 1
    1   0.002627   0.000016     call s:call_motion()

FUNCTION  remote#host#PluginsForHost()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/remote/host.vim:177
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000011   if !has_key(s:plugins_for_host, a:host)
    2              0.000010     let s:plugins_for_host[a:host] = []
    2              0.000003   end
    2              0.000008   return s:plugins_for_host[a:host]

FUNCTION  <SNR>97_query_path()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/ruby.vim:63
Called 1 time
Total time:   0.027713
 Self time:   0.000446

count  total (s)   self (s)
    1              0.000006   let code = "print $:.join %q{,}"
    1              0.000017   if &shell =~# 'sh' && empty(&shellxquote)
    1              0.000024     let prefix = 'env PATH='.shellescape($PATH).' '
                              else
                                let prefix = ''
    1              0.000001   endif
    1              0.000003   if &shellxquote == "'"
                                let path_check = prefix.'ruby --disable-gems -e "' . code . '"'
    1              0.000001   else
    1              0.000013     let path_check = prefix."ruby --disable-gems -e '" . code . "'"
    1              0.000002   endif
                            
    1              0.000006   let cd = haslocaldir() ? 'lcd' : 'cd'
    1              0.000015   let cwd = fnameescape(getcwd())
    1              0.000002   try
    1              0.000115     exe cd fnameescape(a:root)
    1   0.027347   0.000080     let path = split(system(path_check),',')
    1              0.000113     exe cd cwd
    1              0.000005     return path
    1              0.000005   finally
    1              0.000015     exe cd cwd
    1              0.000004   endtry

FUNCTION  vm#commands#regex_reset()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:215
Called 17 times
Total time:   0.001505
 Self time:   0.001505

count  total (s)   self (s)
                                " Reset the VM regex mode.
   17              0.000541     silent! cunmap <buffer> <cr>
   17              0.000254     silent! cunmap <buffer> <esc>
   17              0.000231     silent! cunmap <buffer> <esc><esc>
   17              0.000128     let s:v.using_regex = 0
   17              0.000148     silent! unlet s:v.statusline_mode
   17              0.000118     if a:0 | return a:1 | endif

FUNCTION  vm#clearmatches()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:193
Called 273 times
Total time:   0.007011
 Self time:   0.007011

count  total (s)   self (s)
  476              0.002337     for m in getmatches()
  203              0.001016         if m.group == 'VM_Extend' || m.group == 'MultiCursor'
                                        silent! call matchdelete(m.id)
  203              0.000214         endif
  476              0.000479     endfor

FUNCTION  vm#maps#reset()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:33
Called 17 times
Total time:   0.002260
 Self time:   0.001558

count  total (s)   self (s)
                                " At VM reset, last buffer mappings are reset, and permanent maps are restored.
   17   0.000847   0.000145     call s:Maps.unmap_esc_and_toggle()
  204              0.001282     for m in g:Vm.maps.permanent | exe m | endfor

FUNCTION  <SNR>97_build_path()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/ruby.vim:88
Called 1 time
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
    1              0.000061   let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
    1              0.000034   if &g:path =~# '\v^%(\.,)=%(/%(usr|emx)/include,)=,$'
    1              0.000005     let path = path . ',.,,'
                              elseif &g:path =~# ',\.,,$'
                                let path = &g:path[0:-4] . path . ',.,,'
                              elseif &g:path =~# ',,$'
                                let path = &g:path[0:-2] . path . ',,'
                              else
                                let path = substitute(&g:path, '[^,]\zs$', ',', '') . path
    1              0.000001   endif
    1              0.000002   return path

FUNCTION  vm#funcs#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:10
Called 17 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   17              0.000102     let s:V = b:VM_Selection
   17              0.000049     let s:v = s:V.Vars
   17              0.000043     return s:Funcs

FUNCTION  <lambda>1139()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:13
Called 21 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            return g:Vm.extend_mode 

FUNCTION  vm#themes#statusline()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/themes.vim:101
Called 22 times
Total time:   0.003006
 Self time:   0.001897

count  total (s)   self (s)
   22              0.000206   if !exists('b:visual_multi')
                                return ''
   22              0.000022   endif
   22              0.000108   let v = b:VM_Selection.Vars
   22   0.001312   0.000203   let vm = VMInfos()
   22              0.000047   let color  = '%#VM_Extend#'
   22              0.000071   let single = b:VM_Selection.Vars.single_region ? '%#VM_Mono# SINGLE ' : ''
   22              0.000025   try
   22              0.000029     if v.insert
                                  if b:VM_Selection.Insert.replace
                                    let [ mode, color ] = [ 'V-R', '%#VM_Mono#' ]
                                  else
                                    let [ mode, color ] = [ 'V-I', '%#VM_Cursor#' ]
                                  endif
   22              0.000015     else
   22              0.000225       let mode = { 'n': 'V-M', 'v': 'V', 'V': 'V-L', "\<C-v>": 'V-B' }[mode()]
   22              0.000020     endif
                              catch
                                let mode = 'V-M'
   22              0.000027   endtry
   22              0.000112   let mode = exists('v.statusline_mode') ? v.statusline_mode : mode
   22              0.000161   let patterns = string(vm.patterns)[:(winwidth(0)-30)]
   22              0.000260   return printf("%s %s %s %s %s%s %s %%=%%l:%%c %s %s", color, mode, '%#VM_Insert#', vm.ratio, single, '%#TabLine#', patterns, color, vm.status . ' ')

FUNCTION  <SNR>97_map()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin/ruby.vim:158
Called 14 times
Total time:   0.000830
 Self time:   0.000830

count  total (s)   self (s)
   14              0.000165   let from = matchstr(a:map, '\S\+')
   14              0.000261   if empty(mapcheck(from, a:mode))
   14              0.000232     exe a:mode.'map' '<buffer>' a:flags a:map
   14              0.000113     let b:undo_ftplugin .= '|sil! '.a:mode.'unmap <buffer> '.from
   14              0.000014   endif

FUNCTION  <lambda>1140()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:14
Called 13 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            return s:V.Regions      

FUNCTION  vm#comp#TextChangedI()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:71
Called 71 times
Total time:   0.001476
 Self time:   0.001476

count  total (s)   self (s)
                                " Insert mode change: re-enable autocompletion engines. {{{1
   71              0.000408     if exists('g:loaded_deoplete') && s:disabled_deoplete
                                    call deoplete#enable()
                                    let s:disabled_deoplete = 0
   71              0.000179     elseif s:disabled_ncm2
                                    let b:ncm2_enable = 1
                                    let s:disabled_ncm2 = 0
   71              0.000060     endif

FUNCTION  vm#reset()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:131
Called 17 times
Total time:   0.350094
 Self time:   0.007092

count  total (s)   self (s)
   17              0.000210     if !exists('b:visual_multi')
                                    return {}
   17              0.000029     endif
   17   0.005795   0.000257     call vm#variables#reset()
   17   0.002024   0.000518     call vm#commands#regex_reset()
                            
   17   0.003709   0.000216     call s:V.Global.remove_highlight()
   17   0.003202   0.000240     call s:V.Global.backup_last_regions()
                            
   17   0.003923   0.000304     call s:V.Funcs.restore_regs()
   17   0.032127   0.000264     call s:V.Maps.disable(1)
   17   0.001178   0.000759     silent! call s:V.Insert.auto_end()
                            
   17   0.002466   0.000206     call vm#maps#reset()
   17   0.001733   0.000255     call vm#comp#reset()
   17   0.002770   0.000224     call vm#augroup(1)
   17   0.001430   0.000218     call vm#au_cursor(1)
                            
                                " reenable folding, but keep winline and open current fold
   17              0.000110     if exists('s:v.oldfold')
    6   0.000429   0.000077         call s:V.Funcs.Scroll.get(1)
    6              0.000483         normal! zizv
    6   0.000441   0.000060         call s:V.Funcs.Scroll.restore()
   17              0.000018     endif
                            
   17              0.000073     if !empty(g:VM_highlight_matches)
   17              0.000123         hi clear Search
   17              0.000195         exe 'hi! ' . g:Vm.search_hi
   17              0.000019     endif
                            
   17              0.000066     if g:Vm.oldupdate && &updatetime != g:Vm.oldupdate
                                    let &updatetime = g:Vm.oldupdate
   17              0.000015     endif
                            
   17   0.000682   0.000189     call vm#comp#exit()
                            
   17   0.000516   0.000159     call s:V.Funcs.restore_visual_marks()
                            
                                "exiting manually
   17              0.000111     if !get(g:, 'VM_silent_exit', 0) && !a:0
   17   0.282954   0.000181         call s:V.Funcs.msg('Exited Visual-Multi.')
                                else
                                    echo "\r"
   17              0.000018     endif
                            
   17   0.001806   0.000346     call vm#variables#reset_globals()
   17   0.000661   0.000372     call vm#special#commands#unset()
   17              0.000115     unlet b:visual_multi
   17              0.000065     call garbagecollect()
   17              0.000048     return {}

FUNCTION  vm#themes#search_highlight()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/themes.vim:67
Called 18 times
Total time:   0.000359
 Self time:   0.000359

count  total (s)   self (s)
                              " Init Search highlight.
   18              0.000091   let hl = g:VM_highlight_matches
   18              0.000205   let g:Vm.Search = hl == 'underline' ? 'Search term=underline cterm=underline gui=underline' :           hl == 'red'       ? 'Search ctermfg=196 guifg=#ff0000' :           hl =~ '^hi!\? '   ? substitute(g:VM_highlight_matches, '^hi!\?', '', '')                             : 'Search term=underline cterm=underline gui=underline'

FUNCTION  vm#commands#add_cursor_up()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:115
Called 13 times
Total time:   0.182603
 Self time:   0.001683

count  total (s)   self (s)
                                " Add cursors vertically, upwards.
   13   0.000274   0.000209     if s:first_line() | return | endif
   13   0.164074   0.000176     call s:set_extend_mode(a:extend)
   13   0.000422   0.000132     let s:v.vertical_col = s:F.get_vertcol()
   13   0.006017   0.000099     call s:G.new_cursor()
   13              0.000034     let N = a:count
                            
   26              0.000039     while N
   13              0.000312         normal! k
   13   0.010129   0.000223         if !s:skip_shorter_lines() | let N -= 1 | endif
   13   0.000135   0.000107         if s:first_line()          | break      | endif
   26              0.000027     endwhile
                            
   13   0.000936   0.000122     call s:went_too_far()

FUNCTION  vm#comp#exit()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:114
Called 17 times
Total time:   0.000493
 Self time:   0.000427

count  total (s)   self (s)
                                " Called last on VM exit. "{{{1
   17              0.000230     silent! call VM_Exit()
   17   0.000183   0.000116     silent doautocmd <nomodeline> User visual_multi_exit

FUNCTION  <SNR>86_eol()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/icmds.vim:229
Called 14 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
   14              0.000124     return a:r.a == (col([a:r.l, '$']) - 1)

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/ftplugin.vim:14
Called 10501 times
Total time:  73.690481
 Self time:  73.564621

count  total (s)   self (s)
10501              0.073729     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
10501              0.009962     endif
                            
10501              0.063286     let s = expand("<amatch>")
10501              0.024181     if s != ""
10501              0.143666       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
10501              0.007910       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
21002              0.122583       for name in split(s, '\.')
10501  38.981122  38.864096         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
10501  33.975849  33.967016         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
21002              0.053489       endfor
10501              0.011272     endif

FUNCTION  vm#edit#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/edit.vim:7
Called 17 times
Total time:   0.007587
 Self time:   0.004437

count  total (s)   self (s)
                                " Initialize script variables
   17              0.000074     let s:V = b:VM_Selection
   17              0.000038     let s:v = s:V.Vars
   17              0.000032     let s:G = s:V.Global
   17              0.000030     let s:F = s:V.Funcs
                            
   17              0.000067     let s:v.new_text     = []
   17              0.000048     let s:v.W            = []
   17              0.000057     let s:v.storepos     = []
   17              0.000049     let s:v.extra_spaces = []
   17              0.000064     let s:can_multiline  = 0
                            
   17   0.002172   0.001769     call vm#icmds#init()
   17   0.004897   0.002150     return extend(s:Edit, vm#ecmds1#init())

FUNCTION  vm#search#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/search.vim:5
Called 17 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   17              0.000082     let s:V        = b:VM_Selection
   17              0.000041     let s:v        = s:V.Vars
   17              0.000034     let s:F        = s:V.Funcs
   17              0.000032     let s:G        = s:V.Global
   17              0.000049     return s:Search

FUNCTION  165()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:286
Called 50 times
Total time:   0.154510
 Self time:   0.016012

count  total (s)   self (s)
                                " Called on InsertLeave.
   50   0.001520   0.000908     if s:F.not_VM() | return | endif
                            
                                " text must be updated again after InsertLeave, to take into account
                                " changes that don't trigger TextChangedI, for example when exiting
                                " insert mode immediately after CompleteDone or abbreviation expansion
                                " the only case we don't do this, it's when no characters are typed, nor
                                " completion has been performed
   50              0.000193     if self.reupdate
   16   0.041492   0.000211         call self.update_text(1)
   16              0.000099         let self.reupdate = v:false
   50              0.000051     endif
                            
   50   0.007187   0.001313     call self.clear_hi() | call self.auto_end() | let i = 0
                            
   50              0.000152     if s:v.single_region
                                    let active_line = 0
                                    let s:cursors_after = []
                                    for r in s:R()
                                        let c = self.cursors[i]
                                        if c.active
                                            let active_line = c.l
                                            call r.update_cursor([c.l, c._a])
                                            let s:v.storepos = [r.l, r.a]
                                        elseif active_line == c.l
                                            call r.update_cursor([c.l, c._a])
                                            call add(s:cursors_after, c)
                                        endif
                                        let i += 1
                                    endfor
   50              0.000057     else
  166   0.001227   0.001099         for r in s:R()
  116              0.000545             let c = self.cursors[i]
  116   0.036912   0.001894             call r.update_cursor([c.l, c._a])
  197              0.000996             if r.index == self.index | let s:v.storepos = [r.l, r.a] | endif
  116              0.000363             let i += 1
  166              0.000250         endfor
   50              0.000051     endif
                            
                                " NOTE:
                                " - s:v.insert is true if re-entering insert mode after BS/CR/arrows etc;
                                "   it is true until an insert session is really over.
                                "
                                " - s:v.restart_insert is only temporarily true when commands need to exit
                                "   insert mode to update cursors, and enter it again; it is set in plugs,
                                "   to avoid postprocessing.
                            
   50              0.000338     if s:v.restart_insert | let s:v.restart_insert = 0 | return | endif
                            
                                " reset insert mode variables
   14              0.000047     let s:v.eco    = 1
   14              0.000039     let s:v.insert = 0
                            
   14   0.020642   0.000197     call s:step_back()
   14   0.031947   0.000258     call s:V.Edit.post_process(0,0)
                            
   14              0.000204     let &l:indentkeys   = s:v.indentkeys
   14              0.000105     let &l:cinkeys      = s:v.cinkeys
   14              0.000199     let &l:synmaxcol    = s:v.synmaxcol
   14              0.000256     let &l:textwidth    = s:v.textwidth
   14              0.000120     let &l:softtabstop  = s:v.softtabstop
                            
                                "restore sync minlines if possible
   14              0.000069     if len(b:VM_sync_minlines)
   14              0.000170         exe 'syn sync minlines='.b:VM_sync_minlines
   14              0.000017     endif
                            
                                "reindent all and adjust cursors position, only if filetype/options allow
   14   0.001168   0.000321     if s:do_reindent() | call s:V.Edit.run_normal('==', {'recursive': 0, 'stay_put': 1}) | endif
                            
   14              0.000029     if g:VM_reselect_first
                                    call s:G.select_region(0)
   14              0.000039     elseif self._index >= 0
                                    call s:G.select_region(self._index)
   14              0.000013     else
   14   0.001294   0.000130         call s:G.select_region(self.index)
   14              0.000015     endif
                            
                                " now insert mode has really ended, restore winline and clear variable
   14              0.000029     if !g:VM_reselect_first
   14   0.001406   0.000106         call s:F.Scroll.force(s:v.winline_insert)
   14              0.000015     endif
   14              0.000059     unlet s:v.winline_insert
   14              0.000176     silent! unlet s:v.smart_case_change
                            
                                " unmap single mode mappings, if they had been mapped
   14   0.000345   0.000205     call s:map_single_mode(1)
                            
                                " reset type and replace mode last, but not in single region mode
   14              0.000030     if !s:v.single_region
   14              0.000044         let self.replace = 0
   14              0.000046         let self.type = ''
   14              0.000117         silent! unlet self._lines
   14              0.000018     endif
                            
   14              0.000080     if get(g:, 'VM_quit_after_leaving_insert_mode', 0)
                                    call vm#reset()
   14              0.000012     endif

FUNCTION  <SNR>18_assign()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:248
Called 984 times
Total time:   0.071657
 Self time:   0.071657

count  total (s)   self (s)
                                " Create a map command that will be executed.
  984              0.008780     let k = a:key[0] | if empty(k) | return '' | endif
  930              0.002620     let m = a:key[1]
                            
                                "check if the mapping can be applied: this only runs for buffer mappings
                                "a:1 is a bool that is true if mappings must be checked
                                "a:2 can contain a list of mappings that will be applied anyway (forced)
                                "otherwise, if a buffer mapping already exists, the remapping fails, and
                                "a debug line is added
  930              0.003971     if a:0 && a:1 && index(a:2, k) < 0
  930              0.013962         let K = maparg(k, m, 0, 1)
  930              0.003323         if !empty(K) && K.buffer
    6              0.000038             let b = 'b'.bufnr('%').': '
                                        " Handle Neovim mappings with Lua functions as rhs
    6              0.000034             let rhs = has_key(K, 'rhs') ? K.rhs : '<Lua callback>'
    6              0.000013             if m != 'i'
                                            let s = b.'Could not map: '.k.' ('.a:plug.')  ->  ' . rhs
                                            call add(b:VM_Debug.lines, s)
                                            return ''
    6              0.000006             else
    6              0.000036                 let s = b.'Overwritten imap: '.k.' ('.a:plug.')  ->  ' . rhs
    6              0.000029                 call add(b:VM_Debug.lines, s)
    6              0.000006             endif
  930              0.000619         endif
  930              0.000612     endif
                            
  930              0.007380     let p = substitute(a:plug, ' ', '-', 'g')
  930              0.003173     let _ = a:buffer? '<buffer><nowait> ' : '<nowait> '
  930              0.004774     return m."map "._.k.' <Plug>(VM-'.p.")"

FUNCTION  vm#au_cursor()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:229
Called 34 times
Total time:   0.001969
 Self time:   0.001969

count  total (s)   self (s)
   34              0.000144     if a:end
   17              0.000859         autocmd! VM_cursormoved
   17              0.000211         augroup! VM_cursormoved
   17              0.000029         return
   17              0.000012     endif
                            
   17              0.000048     augroup VM_cursormoved
   17              0.000220         au!
   17              0.000106         au CursorMoved  <buffer> call s:cursor_moved()
   17              0.000075         au CursorMoved  <buffer> call s:V.Funcs.set_statusline(2)
   17              0.000093         au CursorHold   <buffer> call s:V.Funcs.set_statusline(1)
   17              0.000021     augroup END

FUNCTION  <SNR>18_build_buffer_maps()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:179
Called 6 times
Total time:   0.138415
 Self time:   0.045466

count  total (s)   self (s)
                                " Run once per buffer. Generate buffer mappings and integrate custom ones.
    6              0.000024     let b:VM_maps   = []
    6              0.000020     let b:VM_unmaps = []
    6              0.000041     let check_maps  = get(b:, 'VM_check_mappings', g:VM_check_mappings)
    6              0.000051     let force_maps  = get(b:, 'VM_force_maps', get(g:, 'VM_force_maps', []))
                            
                                "generate base buffer maps
    6   0.003508   0.000080     let maps = vm#maps#all#buffer()
                            
                                "integrate motions
  144              0.000288     for m in (g:Vm.motions + g:Vm.find_motions)
  138              0.000695         let maps['Motion ' . m] = [m, 'n']
  144              0.000144     endfor
   54              0.000128     for m in keys(g:Vm.tobj_motions)
   48              0.000300         let maps['Motion ' . g:Vm.tobj_motions[m]] = [m, 'n']
   54              0.000056     endfor
    6              0.000037     for op in keys(g:Vm.user_ops)
                                    " don't map the operator if it starts with a key that would interfere
                                    " with VM operations in extend mode, eg. if 'cx' gets mapped, then 'c'
                                    " will not work as it should (it would have a delay in extend mode)
                                    if index(['y', 'c', 'd'], op[:0]) == -1
                                        let maps['User Operator ' . op] = [op, 'n']
                                    endif
    6              0.000007     endfor
                            
                                "integrate custom motions and commands
    6              0.000034     for m in keys(g:VM_custom_motions)
                                    let maps['Motion ' . g:VM_custom_motions[m]] = [m, 'n']
    6              0.000006     endfor
    6              0.000023     for m in keys(g:VM_custom_noremaps)
                                    let maps['Normal! ' . g:VM_custom_noremaps[m]] = [m, 'n']
    6              0.000006     endfor
    6              0.000022     for m in keys(g:VM_custom_remaps)
                                    let maps['Remap ' . g:VM_custom_remaps[m]] = [m, 'n']
    6              0.000005     endfor
    6              0.000031     for m in keys(g:VM_custom_commands)
                                    let maps[m] = [m, 'n']
    6              0.000006     endfor
                            
                                "integrate custom remappings
   72              0.000148     for key in keys(g:VM_maps)
   66              0.000446         silent! let maps[key][0] = g:VM_maps[key]
   72              0.000077     endfor
                            
                                "generate list of 'exe' commands for map assignment
  990              0.001906     for key in keys(maps)
  984   0.086465   0.014808         let mapping = s:assign(key, maps[key], 1, check_maps, force_maps)
  984              0.002941         if !empty(mapping)
  930              0.003719             call add(b:VM_maps, mapping)
   54              0.000049         else
                                        " remove the mapping, so that it won't be unmapped either
   54              0.000190             unlet maps[key]
  984              0.000665         endif
  990              0.000895     endfor
                            
                                "store the key used to toggle mappings
    6              0.000067     let g:Vm.maps.toggle = has_key(g:VM_maps, 'Toggle Mappings') ? g:VM_maps['Toggle Mappings'] : g:Vm.leader.buffer . '<Space>'
    6              0.000056     let g:Vm.maps.exit   = has_key(g:VM_maps, 'Exit') ? g:VM_maps['Exit'] : '<Esc>'
                            
                                "generate list of 'exe' commands for unmappings
  936              0.001632     for key in keys(maps)
  930   0.028800   0.010936         call add(b:VM_unmaps, s:unmap(maps[key], 1))
  936              0.001008     endfor

FUNCTION  195()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:177
Called 86 times
Total time:   0.004181
 Self time:   0.004181

count  total (s)   self (s)
                                " Shift region offsets by integer values.
                                "TODO: this will surely cause trouble in insert mode with multibyte chars
                                "all r.shift() in insert mode should be replaced with r.update_cursor()
   86              0.000351     let r = self
                            
   86              0.000526     let r.A += a:x | let r.B += a:y
                            
   86              0.000502     let r.l = byte2line(r.A)
   86              0.000397     let r.L = byte2line(r.B)
   86              0.000473     let r.a = r.A - line2byte(r.l) + 1
   86              0.000412     let r.b = r.B - line2byte(r.L) + 1
                            
   86              0.000530     if !s:v.eco | call r.update() | endif
   86              0.000436     return [r.l, r.L, r.a, r.b]

FUNCTION  vm#augroup()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:206
Called 34 times
Total time:   0.004426
 Self time:   0.004426

count  total (s)   self (s)
   34              0.000143     if a:end
   17              0.002113         autocmd! VM_global
   17              0.000259         augroup! VM_global
   17              0.000035         return
   17              0.000014     endif
                            
   17              0.000149     augroup VM_global
   17              0.000817         au!
   17              0.000180         au BufLeave     * call s:buffer_leave()
   17              0.000099         au BufEnter     * call s:buffer_enter()
                            
   17              0.000098         if exists("##TextYankPost")
   17              0.000128             au TextYankPost <buffer> call s:set_reg()
   17              0.000091             au TextYankPost <buffer> call vm#operators#after_yank()
                                    else
                                        au CursorMoved  <buffer> call s:set_reg()
                                        au CursorMoved  <buffer> call vm#operators#after_yank()
                                        au CursorHold   <buffer> call vm#operators#after_yank()
   17              0.000014         endif
   17              0.000018     augroup END

FUNCTION  vm#insert#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:9
Called 17 times
Total time:   0.000323
 Self time:   0.000323

count  total (s)   self (s)
                                " Init script variables.
   17              0.000075     let s:V    = b:VM_Selection
   17              0.000039     let s:v    = s:V.Vars
   17              0.000032     let s:G    = s:V.Global
   17              0.000030     let s:F    = s:V.Funcs
   17              0.000043     let s:v.restart_insert = 0
   17              0.000058     return s:Insert

FUNCTION  199()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:246
Called 85 times
Total time:   0.037990
 Self time:   0.003296

count  total (s)   self (s)
                                " Move cursors, or extend regions by motion.
   85              0.000554     let s:motion = a:0? a:1 : s:v.motion
                            
   85   0.001013   0.000880     if !s:X()
   85   0.035632   0.001071         call s:move_cursor(self)
                                else
                                    call s:move_region(self)
   85              0.000089     endif

FUNCTION  200()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:258
Called 85 times
Total time:   0.004201
 Self time:   0.003220

count  total (s)   self (s)
                                " Set vertical column if motion is j or k, and vcol not previously set.
   85   0.001925   0.000943     if !s:vertical()
   85              0.000360         let self.vcol = 0
                                elseif !self.vcol
                                    let before = getline('.')[:col('.')-1]
                                    let self.bdiff = strlen(before) - strchars(before)
                                    let self.vcol = col('.')
                                    if !&expandtab
                                        let self.ntabs = count(before, "\t")
                                    endif
   85              0.000067     endif

FUNCTION  <SNR>25_try()
    Defined: ~/.local/share/nvim/lazy/indent-blankline.nvim/plugin/indent_blankline.vim:7
Called 34812 times
Total time:  23.959294
 Self time:  23.959294

count  total (s)   self (s)
34812              0.082658     try
34812             23.552125         execute a:cmd
                                catch /E12/
                                    return
34812              0.057989     endtry

FUNCTION  10()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/clipboard.vim:182
Called 110 times
Total time:   1.951120
 Self time:   1.951120

count  total (s)   self (s)
  110              0.000625   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
  110              0.000071   end
                            
  110              0.000759   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
  110              0.000065   end
                            
  110              0.000187   if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
  110              0.000066   end
                            
  110              0.000507   if s:selections[a:reg].owner > 0
  107              0.000400     let prev_job = s:selections[a:reg].owner
  110              0.000100   end
  110              0.001051   let s:selections[a:reg] = copy(s:selection)
  110              0.000377   let selection = s:selections[a:reg]
  110              0.000482   let selection.data = [a:lines, a:regtype]
  110              0.000339   let selection.argv = s:copy[a:reg]
  110              0.000251   let selection.detach = s:cache_enabled
  110              0.000271   let selection.cwd = "/"
  110              1.930191   let jobid = jobstart(selection.argv, selection)
  110              0.001144   if jobid > 0
  110              0.002621     call jobsend(jobid, a:lines)
  110              0.000605     call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
  110              0.000509     if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
  110              0.000134     endif
  110              0.000524     let selection.owner = jobid
  110              0.000194     let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
  110              0.000079   endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
  110              0.000422   if exists('prev_job')
  107              0.002745     call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
  110              0.000108   endif
                            
  110              0.000408   return ret

FUNCTION  <SNR>7_stdheader()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:140
Called 3 times
Total time:   0.009786
 Self time:   0.000059

count  total (s)   self (s)
    3   0.000702   0.000024 	if s:update()
    3   0.009075   0.000026 		call s:insert()
    3              0.000002 	endif

FUNCTION  103()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:659
Called 82 times
Total time:   0.001032
 Self time:   0.001032

count  total (s)   self (s)
                                " Remove a list of regions by id.
                            
   82              0.000337     for id in a:list
                                    call s:F.region_with_id(id).remove()
   82              0.000104     endfor

FUNCTION  104()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:673
Called 82 times
Total time:   0.136984
 Self time:   0.007335

count  total (s)   self (s)
                                " Merge overlapping cursors.
                            
   82              0.001285     let ids_to_remove = [] | let last_A = 0 | let pos = getpos('.')[1:2]
                            
                                " we only check offset r.A, since for cursors r.A == r.B
  268   0.001235   0.001122     for r in s:R()
  290              0.001039         if r.A == last_A | call add(ids_to_remove, r.id) | endif
  186              0.000498         let last_A = r.A
  268              0.000331     endfor
                            
   82   0.001794   0.000762     call self.remove_regions_by_id(ids_to_remove)
   82   0.129354   0.000850     return self.update_and_select_region(pos)

FUNCTION  105()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:689
Called 32 times
Total time:   0.053100
 Self time:   0.000989

count  total (s)   self (s)
                                " Merge overlapping regions.
                            
   32   0.000434   0.000394     if !len(s:R()) | return {}                   | endif
   32   0.052571   0.000501     if !s:X()      | return self.merge_cursors() | endif
                            
                                let s:v.eco = 1
                                let pos = getpos('.')[1:2]
                                call self.rebuild_from_map(s:V.Bytes)
                                return self.update_map_and_select_region(pos)

FUNCTION  vm#region#new()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:35
Called 45 times
Total time:   0.029576
 Self time:   0.004829

count  total (s)   self (s)
                                " Create region from marks, offsets or positions.
                            
                                "----------------------------------------------------------------------
                            
   45              0.000094     if a:0
                                    if a:0 == 2             "making a new region from offsets
                                        let a = byte2line(a:1) | let c = a:1 - line2byte(a) + 1
                                        let b = byte2line(a:2) | let d = a:2 - line2byte(b) + 1
                            
                                    else                    "making a new region from positions
                                        let a = a:1 | let b = a:2 | let c = a:3 | let d = a:4
                                    endif
   45              0.000028     endif
                            
                                "----------------------------------------------------------------------
                            
   45              0.000185     let cursor = a:cursor || ( a:0 && c==d && a==b )          "cursor or region?
                            
   45              0.000239     if !g:Vm.buffer | call vm#init_buffer(cursor) | endif     "activate if needed
                            
   45   0.023040   0.000427     if !a:0 | let R = s:Region.new(cursor)                    "create region
                                else    | let R = s:Region.new(0, a, b, c, d)
   45              0.000034     endif
                            
                                "----------------------------------------------------------------------
                            
                                "update region index and ID count
   45              0.000221     let s:v.index = R.index | let s:v.ID += 1
                            
                                "keep regions list ordered
   45   0.000632   0.000562     if empty(s:R()) || s:R()[s:v.index-1].A < R.A
   32   0.000278   0.000249         call add(s:R(), R)
   13              0.000011     else
   13              0.000025         let i = 0
   13   0.000096   0.000086         for r in s:R()
   13              0.000029             if r.A > R.A
   13   0.000110   0.000100                 call insert(s:R(), R, i)
   13              0.000017                 break
                                        endif
                                        let i += 1
   13              0.000014         endfor
   13              0.000028         let s:v.index = i
   13   0.000608   0.000113         call s:G.update_indices(i)
   45              0.000035     endif
                            
   45   0.001795   0.000274     call s:G.update_cursor_highlight()
   45              0.000077     return R

FUNCTION  <SNR>2_LoadIndent()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/indent.vim:13
Called 10501 times
Total time:   9.787473
 Self time:   9.784239

count  total (s)   self (s)
10501              0.052521     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
10501              0.008032     endif
10501              0.053097     let s = expand("<amatch>")
10501              0.021874     if s != ""
10501              0.026511       if exists("b:did_indent")
                            	unlet b:did_indent
10501              0.006864       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
21002              0.100053       for name in split(s, '\.')
10501   4.761331   4.758097         exe 'runtime! indent/' . name . '.vim'
10501              4.585936         exe 'runtime! indent/' . name . '.lua'
21002              0.031179       endfor
10501              0.008585     endif

FUNCTION  202()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:396
Called 370 times
Total time:   0.087428
 Self time:   0.019552

count  total (s)   self (s)
                                " Update cursor vars from position [line, col] or offset.
  370              0.001387     let r = self
                            
  370              0.001543     if a:0 && !type(a:1)
                                    let r.l = byte2line(a:1)
                                    let r.a = a:1 - line2byte(r.l) + 1
  370              0.000718     elseif a:0
  150              0.000715         let r.l = a:1[0]
  150              0.000593         let r.a = a:1[1]
  370              0.000365     endif
                            
  370   0.023371   0.006422     call s:fix_pos(r)
  370   0.054056   0.003130     call self.update_vars()

FUNCTION  <SNR>17_Insert()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/plugs.vim:264
Called 36 times
Total time:   0.006776
 Self time:   0.006776

count  total (s)   self (s)
                              " Handle keys in insert mode.
   36              0.000396   if a:key == 'o'
                                echo 'Not supported'
                                return ''
   36              0.000059   endif
                            
   36              0.000286   let VM = b:VM_Selection
   36              0.000190   let i  = ":call b:VM_Selection.Insert.key('i')\<cr>"
   36              0.000134   let a  = ":call b:VM_Selection.Insert.key('a')\<cr>"
                            
   36              0.000167   if pumvisible()
                                if a:key == 'j'       | return "\<C-n>"
                                elseif a:key == 'k'   | return "\<C-p>"
                                elseif a:key == 'c-e' | return "\<C-e>"
                                endif
   36              0.000029   endif
                            
   36              0.000095   if a:key == 'ins'
                                let VM.Insert.replace = !VM.Insert.replace
   36              0.000029   endif
                            
   36              0.000464   if VM.Insert.replace | return s:Replace(a:key) | endif
                            
                              " in single region mode, some keys must be handled differently, or the
                              " function must return prematurely
   36              0.000129   if VM.Vars.single_region
                                if a:key == 'c-v'
                                  return "\<C-r>0"
                                elseif index(['cr', 'c-w', 'c-u', 'ins'], a:key) >= 0
                                  call VM.Funcs.msg("[visual-multi] not possible in single region mode")
                                  let &ro = &ro          " brings the cursor back from commmand line
                                  return ""
                                endif
   36              0.000037   else
   36              0.000184     let VM.Vars.restart_insert = 1
   36              0.000050   endif
                            
   36              0.001504   if index(split('hjklwbWB0', '\zs'), a:key) >= 0
   23              0.000219     return "\<esc>:call vm#commands#motion('".a:key."', 1, 0, 0)\<cr>".i
   13              0.000013   endif
                            
   13              0.000625   return { 'cr': "\<esc>:call vm#icmds#return()\<cr>".i, 'x': "\<esc>:call vm#icmds#x('".a:key."')\<cr>".i, 'ge': "\<esc>:call vm#commands#motion('h".a:key."l', 1, 0, 0)\<cr>".i, 'e': "\<esc>:call vm#commands#motion('".a:key."l', 1, 0, 0)\<cr>".i, 'a': "\<esc>:call b:VM_Selection.Insert.key('A')\<cr>", 'i': "\<esc>:call b:VM_Selection.Insert.key('I')\<cr>", 'c-v': "\<esc>:call vm#icmds#paste()\<cr>".a, 'c-w': "\<esc>:call vm#icmds#cw(0)\<cr>", 'c-u': "\<esc>:call vm#icmds#cw(1)\<cr>", 'ins': "\<esc>".i,}[tolower(a:key)]

FUNCTION  <SNR>74_before_move()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:623
Called 25 times
Total time:   0.001173
 Self time:   0.000579

count  total (s)   self (s)
   25   0.000788   0.000234     call s:G.reset_byte_map(0)
   25   0.000338   0.000298     if !s:X() | let s:v.merge = 1 | endif

FUNCTION  <SNR>91_keep_line()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:294
Called 85 times
Total time:   0.003469
 Self time:   0.003469

count  total (s)   self (s)
                                " Ensure line boundaries aren't crossed. Force cursor merging.
   85              0.000376     let r = a:r
                            
   85              0.001112     if     ( a:ln > r.l ) | call cursor ( r.l, col([r.l, '$'])-1 ) | let s:v.merge = s:X()? s:v.merge : 1
   85              0.000895     elseif ( a:ln < r.l ) | call cursor ( r.l, col([r.l, 1]) )     | let s:v.merge = s:X()? s:v.merge : 1
   85              0.000654     else                  | call cursor ( r.l, col('.') )
   85              0.000110     endif

FUNCTION  vm#icmds#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/icmds.vim:5
Called 17 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
   17              0.000074     let s:V = b:VM_Selection
   17              0.000039     let s:v = s:V.Vars
   17              0.000033     let s:G = s:V.Global
   17              0.000030     let s:F = s:V.Funcs

FUNCTION  <SNR>91_region_vars()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:597
Called 45 times
Total time:   0.011971
 Self time:   0.006438

count  total (s)   self (s)
                                " Update region variables.
   45              0.000151     let R = a:r
                            
   45              0.000099     if !a:0 && a:cursor    "/////////// CURSOR ////////////
                            
   45              0.000166         let R.l     = line('.')
   45              0.000112         let R.L     = R.l
   45              0.000165         let R.a     = col('.')
   45              0.000102         let R.b     = R.a
                            
   45   0.002089   0.000442         call s:fix_pos(R)
                            
   45   0.002185   0.000392         let R.txt   = R.char()              " character under cursor in extend mode
   45   0.001602   0.000476         let R.pat   = s:pattern(R)
                            
   45   0.000648   0.000366         let R.A     = R.A_()                " byte offset a
   45   0.001222   0.000536         let R.B     = s:X() ? R.B_() : R.A  " byte offset b
   45              0.000157         let R.w     = R.B - R.A + 1         " width
   45              0.000112         let R.h     = R.L - R.l             " height
   45              0.000134         let R.k     = R.dir? R.a : R.b      " anchor
   45              0.000133         let R.K     = R.dir? R.A : R.B      " anchor offset
                            
                                elseif !a:0            "/////////// REGION ////////////
                            
                                    let R.l     = line("'[")            " starting line
                                    let R.L     = line("']")            " ending line
                                    let R.a     = col("'[")             " begin
                                    let R.b     = col("']")             " end
                            
                                    call s:fix_pos(R)
                            
                                    let R.txt   = getreg(s:v.def_reg)   " text content
                                    let R.pat   = s:pattern(R)          " associated search pattern
                            
                                    let R.A     = R.A_()                " byte offset a
                                    let R.B     = R.B_()                " byte offset b
                                    let R.w     = R.B - R.A + 1         " width
                                    let R.h     = R.L - R.l             " height
                                    let R.k     = R.dir? R.a : R.b      " anchor
                                    let R.K     = R.dir? R.A : R.B      " anchor offset
                            
                                else                   "///////// FROM ARGS ///////////
                            
                                    let R.l     = a:1
                                    let R.L     = a:2
                                    let R.a     = a:3
                                    let R.b     = a:4
                            
                                    call s:fix_pos(R)
                                    call R.update_content()
                            
                                    let R.A     = R.A_()                " byte offset a
                                    let R.B     = R.B_()                " byte offset b
                                    let R.w     = R.B - R.A + 1         " width
                                    let R.h     = R.L - R.l             " height
                                    let R.k     = R.dir? R.a : R.b      " anchor
                                    let R.K     = R.dir? R.A : R.B      " anchor offset
   45              0.000033     endif
                            
                                " used to keep the column during vertical cursors movement
   45              0.000097     let R.vcol  = 0 " vertical column
   45              0.000092     let R.ntabs = 0 " number of tabs before cursor if noexpandtab
   45              0.000145     let R.bdiff = 0 " bytes diff if multibyte characters before cursor

FUNCTION  <SNR>91_fix_pos()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:581
Called 514 times
Total time:   0.023049
 Self time:   0.023049

count  total (s)   self (s)
                                " Fix positions at end of line.
  514              0.001862     let r = a:r
  514              0.004435     let eol = col([r.l, '$']) - 1
  514              0.003325     let eoL = col([r.L, '$']) - 1
                            
  514              0.001300     if !s:v.multiline
  514              0.002884         if r.a > eol    | let r.a = eol? eol : 1 | endif
  514              0.002317         if r.b > eoL    | let r.b = eoL? eoL : 1 | endif
                                else
                                    if r.a > eol+1  | let r.a = eol? eol+1 : 1 | endif
                                    if r.b > eoL+1  | let r.b = eoL? eoL+1 : 1 | endif
  514              0.000379     endif

FUNCTION  25()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:27
Called 110 times
Total time:   0.002916
 Self time:   0.002916

count  total (s)   self (s)
                                "pos can be a mark, a list [line, col], or the offset itself
                            
  110              0.000634     if type(a:1) == 0                   "an offset
                                    return a:1
                            
  110              0.000481     elseif type(a:1) == v:t_list        "a list [line, col]
   96              0.000676         return (line2byte(a:1[0]) + a:1[1] - 1)
                            
   14              0.000020     else                                "a mark like '[
   14              0.000141         let pos = getpos(a:1)[1:2]
   14              0.000235         return (line2byte(pos[0]) + min([pos[1], col([pos[0], '$'])]) - 1)
                                endif

FUNCTION  26()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:44
Called 204 times
Total time:   0.003764
 Self time:   0.003764

count  total (s)   self (s)
                                " Return the offset of the current cursor position.
  204              0.001794     let pos = getcurpos()[1:2]
  204              0.001558     return (line2byte(pos[0]) + pos[1] - 1)

FUNCTION  28()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:61
Called 33 times
Total time:   0.000725
 Self time:   0.000725

count  total (s)   self (s)
   33              0.000199     let ln = byte2line(a:A)
   33              0.000182     let cl = a:A - line2byte(ln) + 1
   33              0.000169     call cursor(ln, cl)
   33              0.000108     return [ln, cl]

FUNCTION  29()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:70
Called 28 times
Total time:   0.000658
 Self time:   0.000658

count  total (s)   self (s)
                                " getcurpos() is unreliable at $ (https://github.com/vim/vim/issues/4464)
                                " if > eol, reposition the cursor, so that curswant is reset
   28              0.000221     let curswant = getcurpos()[4]
   28              0.000122     if curswant > col('$')
                                    call cursor(getpos('.')[1:2])
                                    let curswant = getcurpos()[4]
   28              0.000024     endif
   28              0.000049     return curswant

FUNCTION  <SNR>33_Remove_Matches()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/plugin/matchparen.vim:196
Called 25015 times
Total time:   0.532712
 Self time:   0.532712

count  total (s)   self (s)
25015              0.239212   if exists('w:paren_hl_on') && w:paren_hl_on
 6497              0.041026     silent! call matchdelete(3)
 6497              0.031904     let w:paren_hl_on = 0
25015              0.031874   endif

FUNCTION  vm#comp#no_reindents()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:135
Called 14 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                                " Don't reindent for filetypes. "{{{1
   14              0.000069     return ['ctrlsf']

FUNCTION  117()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/search.vim:138
Called 514 times
Total time:   0.007037
 Self time:   0.007037

count  total (s)   self (s)
  514              0.006592     return substitute(escape(a:t, '\/.*$^~[]'), "\n", '\\n', "g")

FUNCTION  <SNR>7_date()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:111
Called 267 times
Total time:   0.003999
 Self time:   0.003999

count  total (s)   self (s)
  267              0.003610 	return strftime("%Y/%m/%d %H:%M:%S")

FUNCTION  vm#commands#motion()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:482
Called 24 times
Total time:   0.072217
 Self time:   0.002450

count  total (s)   self (s)
                                " Entry point for motions in VM.
   24   0.001720   0.000390     call s:init(0, 1, a:select)
                            
                                "create cursor if needed:
                                " - VM hasn't started yet
                                " - there are no regions
                                " - called with (single_region) and cursor not on a region
                            
   24   0.000811   0.000338     if !g:Vm.buffer || s:F.no_regions() || ( a:single && !s:is_r() )
                                    call s:G.new_cursor()
   24              0.000022     endif
                            
                                "-----------------------------------------------------------------------
                            
   24              0.000089     if a:motion == '|' && a:count <= 1
                                    let s:v.motion = virtcol('.').a:motion
   24              0.000026     else
   24              0.000144         let s:v.motion = a:count>1? a:count.a:motion : a:motion
   24              0.000028     endif
                            
                                "-----------------------------------------------------------------------
                            
   24   0.000482   0.000304     if s:symbol()          | let s:v.merge = 1          | endif
   24              0.000130     if a:select && !s:X()  | let g:Vm.extend_mode = 1   | endif
                            
   24              0.000085     if a:select && !s:v.multiline && s:vertical()
                                    call s:F.toggle_option('multiline')
   24              0.000021     endif
                            
   24   0.068132   0.000346     call s:call_motion(a:single)

FUNCTION  30()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:83
Called 50 times
Total time:   0.000912
 Self time:   0.000841

count  total (s)   self (s)
   50   0.000574   0.000503     if !len(s:R())
                                    let s:v.index = -1
                                    return 1
   50              0.000049     endif

FUNCTION  32()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:96
Called 45 times
Total time:   0.000692
 Self time:   0.000692

count  total (s)   self (s)
   45              0.000665     return matchstr(getline(a:l), '\%' . a:c . 'c.')

FUNCTION  33()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:102
Called 17 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
   17              0.000045     return "\""

FUNCTION  34()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:106
Called 45 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
   45              0.000365     return line2byte(line('$') + 1) - 1

FUNCTION  35()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:112
Called 17 times
Total time:   0.000307
 Self time:   0.000307

count  total (s)   self (s)
   17              0.000101     let r = a:0? a:1 : s:v.def_reg
   17              0.000183     return [r, getreg(r), getregtype(r)]

FUNCTION  36()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:117
Called 17 times
Total time:   0.002528
 Self time:   0.002528

count  total (s)   self (s)
   17              0.000058     let regs = []
  170              0.000486     for r in range(1, 9)
  153              0.001574         call add(regs, [r, getreg(r), getregtype(r)])
  170              0.000210     endfor
   17              0.000034     return regs

FUNCTION  38()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:134
Called 139 times
Total time:   0.002459
 Self time:   0.002459

count  total (s)   self (s)
  139              0.000656     let r = s:v.oldreg
  139              0.001558     call setreg(r[0], r[1], r[2])

FUNCTION  39()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:141
Called 17 times
Total time:   0.003620
 Self time:   0.003269

count  total (s)   self (s)
                                "default reg
   17   0.000534   0.000183     call self.restore_reg()
                            
                                "regs 0-9
  459              0.002186     for r in s:v.oldregs_1_9 | call setreg(r[0], r[1], r[2]) | endfor
                            
                                "search reg
   17              0.000065     let s = s:v.oldsearch
   17              0.000129     call setreg("/", s[0], s[1])
   17              0.000151     let g:Vm.registers['"'] = []
   17              0.000075     let g:Vm.registers['-'] = []
   17              0.000223     silent! unlet g:Vm.registers['§']

FUNCTION  remote#host#Register()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/remote/host.vim:6
Called 5 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    5              0.000028   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
    5              0.000012   let s:plugin_patterns[a:name] = a:pattern
    5              0.000016   if type(a:factory) == type(1) && a:factory
                                " Passed a channel directly
                                let s:hosts[a:name].channel = a:factory
    5              0.000003   endif

FUNCTION  <SNR>91_pattern()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:562
Called 514 times
Total time:   0.015832
 Self time:   0.008794

count  total (s)   self (s)
                                " Find the search pattern associated with the region.
                            
  514   0.014738   0.007701     if empty(s:v.search) | return s:V.Search.escape_pattern(a:r.txt) | endif
                            
                                for p in s:v.search
                                    if a:r.txt =~ p | return p | endif
                                endfor
                            
                                "return current search pattern in regex mode
                                if !has_key(a:r, 'pat')
                                    return s:v.using_regex ? s:v.search[0] : ''
                                endif
                            
                                "return current pattern if one is present (in cursor mode text is empty)
                                return a:r.pat

FUNCTION  40()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:158
Called 17 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
   17              0.000203     call setpos("'<", s:v.vmarks[0])
   17              0.000107     call setpos("'>", s:v.vmarks[1])

FUNCTION  42()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:174
Called 107 times
Total time:   0.002668
 Self time:   0.001362

count  total (s)   self (s)
                                " VM should quit if there are no active regions.
  107   0.002438   0.001132     return !len(s:V.Global.active_regions())

FUNCTION  45()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:211
Called 6 times
Total time:   0.000213
 Self time:   0.000213

count  total (s)   self (s)
                                " Get the current sync minlines setting for the buffer.
    6              0.000106     let sync = split(execute('syn sync'), '\n')
    6              0.000038     let sync = len(sync) > 1 ? sync[1] : sync[0]
    6              0.000059     return matchstr(sync, '\d\+')

FUNCTION  46()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:220
Called 139 times
Total time:   0.005635
 Self time:   0.005635

count  total (s)   self (s)
  139              0.001190     let setting = get(g:, 'VM_set_statusline', 2)
  139              0.000536     if ( setting - a:auto ) >= 1
   33              0.001219         silent! noautocmd setlocal statusline=%!vm#themes#statusline()
  139              0.000167     endif

FUNCTION  49()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:275
Called 115 times
Total time:   0.001121
 Self time:   0.001121

count  total (s)   self (s)
  115              0.001019     return ( winheight(0) - winline() + line('.') ) >= line('$')

FUNCTION  133()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/edit.vim:390
Called 14 times
Total time:   0.031689
 Self time:   0.000845

count  total (s)   self (s)
                                " Operations to be performed after the command has been executed.
   14              0.000071     if a:reselect
                                    call s:G.extend_mode()
                                    for r in s:R()
                                        call r.shift(a:1, a:1 + s:v.W[r.index])
                                    endfor
   14              0.000012     endif
                            
                                "remove extra spaces that may have been added
   14   0.002500   0.000134     call self.extra_spaces.remove()
                            
                                "update, restore position and clear vars
   14              0.000096     let pos = empty(s:v.storepos)? '.' : s:v.storepos
   14   0.028727   0.000249     call s:G.update_and_select_region(pos) | let s:v.storepos = []

FUNCTION  134()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/edit.vim:414
Called 14 times
Total time:   0.002366
 Self time:   0.002356

count  total (s)   self (s)
                                " Extra spaces at EOL may have been added and must be removed.
                                " remove the extra space only if it comes after r.b, and it's just before \n
   18              0.000099     for i in s:v.extra_spaces
                                    "some region has been removed for some reason(merge, ...)
    6   0.000058   0.000052         if i >= len(s:R()) | break | endif
                            
    4   0.000047   0.000042         let l = s:R()[i].L + (a:0? a:1 : 0)
    4              0.000021         let Line = getline(l)
    4              0.000016         if Line[-1:-1] ==# ' '
    4              0.001586             call setline(l, Line[:-2])
    4              0.000013         endif
   18              0.000030     endfor
   14              0.000073     let s:v.extra_spaces = []

FUNCTION  135()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/edit.vim:431
Called 102 times
Total time:   0.006550
 Self time:   0.006550

count  total (s)   self (s)
                                " It may be necessary to add spaces over empty lines, or if at EOL.
                                " add space if empty line(>) or eol(=)
                                " optional arg is when called in insert mode (cursors are different)
  102              0.000943     let [end, line] = a:0? [a:r._a, a:r.l] : [a:r.b, a:r.L]
  102              0.000512     let L = getline(line)
                                " use strwidth because multibyte chars cause problems at EOL
                                " this will result in more extra spaces than necessary but no big deal
  102              0.000490     if end >= strwidth(L)
    4              0.003326         call setline(line, L.' ')
    4              0.000046         call add(s:v.extra_spaces, a:r.index)
  102              0.000101     endif

FUNCTION  <SNR>89_step_back()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:602
Called 14 times
Total time:   0.020445
 Self time:   0.001954

count  total (s)   self (s)
                                " Go back one char after exiting insert mode, as vim does.
   14              0.000084     if s:v.single_region && s:Insert.type ==? 'i'
                                    return
   14              0.000014     endif
                            
   48   0.000292   0.000273     for r in s:v.single_region ? [s:R()[s:Insert.index]] : s:R()
   34              0.000319         if r.a != col([r.l, '$']) && r.a > 1
                                        " move one byte back
   34   0.002220   0.000412             call r.shift(-1,-1)
                                        " fix column in case of multibyte chars by using a motion
   34   0.017048   0.000384             call r.move('lh')
   34              0.000039         endif
   48              0.000065     endfor

FUNCTION  <SNR>34_LocalBrowse()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 428 times
Total time:   0.035045
 Self time:   0.035045

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
  428              0.003317   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
  428              0.000498   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
  428              0.003458   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
  428              0.008452   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
  428              0.000384   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
  428              0.000412   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  50()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:279
Called 127 times
Total time:   0.002735
 Self time:   0.002735

count  total (s)   self (s)
  127              0.002620     return line('.') <= winline()

FUNCTION  51()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:283
Called 178 times
Total time:   0.003539
 Self time:   0.003539

count  total (s)   self (s)
                                " Store winline().
  178              0.001052     if a:0 | let s:v.restore_scroll = 1 | endif
  178              0.002169     let s:v.winline = winline()

FUNCTION  52()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:289
Called 64 times
Total time:   0.004786
 Self time:   0.001000

count  total (s)   self (s)
                                " Restore arbitrary winline().
   64              0.000233     let s:v.restore_scroll = 1
   64              0.000203     let s:v.winline = a:line
   64   0.004201   0.000415     call self.restore()

FUNCTION  53()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:296
Called 282 times
Total time:   0.009071
 Self time:   0.005215

count  total (s)   self (s)
                                " Restore viewport position when done.
  282              0.002220     if s:v.restore_scroll | let s:v.restore_scroll = 0 | else | return | endif
                            
                                " restoring should be avoided if it's possible to see EOF or BOF
  127   0.005814   0.001957     if ( self.can_see_bof() || self.can_see_eof() ) | return | endif
                            
   12              0.000055     let lines = winline() - s:v.winline
   12              0.000026     if lines > 0
    2              0.000125         silent! exe "normal! ".lines."\<C-e>"
   10              0.000019     elseif lines < 0
    1              0.000004         let lines = lines * -1
    1              0.000056         silent! exe "normal! ".lines."\<C-y>"
   12              0.000011     endif
   12              0.000056     if a:0 | let s:v.winline = winline() | endif

FUNCTION  54()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:317
Called 23 times
Total time:   0.364914
 Self time:   0.364914

count  total (s)   self (s)
   23              0.000120     if s:v.eco | return | endif
                            
   23              0.004121     echo "\r"
   23              0.359806     redraw
   23              0.000288     if type(a:text) == type("")
   23              0.000247         exe "echohl" g:Vm.hi.message
   23              0.000131         echon a:text
   23              0.000085         echohl None | return
                                endif
                            
                                for txt in a:text
                                    exe "echohl ".txt[1]
                                    echon txt[0]
                                    echohl None
                                endfor

FUNCTION  <SNR>75_set_reg()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:267
Called 25 times
Total time:   0.000516
 Self time:   0.000516

count  total (s)   self (s)
                                " Replace old default register if yanking in VM outside a region or cursor.
   25              0.000134     if s:v.yanked
                                    let s:v.yanked = 0
                                    let g:Vm.registers['"'] = []
                                    let s:v.oldreg = s:V.Funcs.get_reg(v:register)
   25              0.000032     endif

FUNCTION  207()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:488
Called 299 times
Total time:   0.014236
 Self time:   0.013491

count  total (s)   self (s)
                                " Create the highlight entries.
                            
  299              0.001326     if s:v.eco | return | endif
  299              0.000726     let R = self
                            
                                "------------------ cursor mode ----------------------------
                            
  299   0.002320   0.001936     if !s:X()
  254              0.003840         let R.matches.cursor = R.a == 1 ? matchadd('MultiCursor', '\%' . R.l . 'l\%1c') : matchaddpos('MultiCursor', [[R.l, R.a]], 40)
  254              0.000428         return
   45              0.000031     endif
                            
                                "------------------ extend mode ----------------------------
                            
   45              0.000132     let max    = R.L - R.l
   45              0.000116     let region = []
   45   0.000904   0.000543     let cursor = [R.cur_ln(), R.cur_col()]
                            
                                "skip the for loop if single line
   45              0.000424     if !max | let region = [[R.l, R.a, R.w]] | else | let max += 1 | endif
                            
                                "define highlight
   45              0.000220     for n in range(max)
                                    let line =    n==0    ? [R.l, R.a, len(getline(R.l))] : n<max-1 ? [R.l + n] :           [R.L, 1, R.b]
                            
                                    call add(region, line)
   45              0.000060     endfor
                            
                                "build a list of highlight entries, one for each possible line
   90              0.000170     for line in region
   45              0.000484         call add(R.matches.region, matchaddpos(g:Vm.hi.extend, [line], 30))
   90              0.000108     endfor
   45              0.000306     let R.matches.cursor = matchaddpos('MultiCursor', [cursor], 40)

FUNCTION  <SNR>59_run_syntax_fold()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/ruby.vim:58
Called 157 times
Total time:   0.011046
 Self time:   0.009503

count  total (s)   self (s)
  157              0.005088   let [_0, _1, groups, cmd; _] = matchlist(a:args, '\(["'']\)\(.\{-}\)\1\s\+\(.*\)')
  157   0.003314   0.001770   if call('s:foldable', split(groups))
  157              0.000343     let cmd .= ' fold'
  157              0.000095   endif
  157              0.002060   exe cmd

FUNCTION  provider#pythonx#Detect()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/pythonx.vim:34
Called 1 time
Total time:   0.084000
 Self time:   0.000044

count  total (s)   self (s)
    1   0.083999   0.000042   return provider#pythonx#DetectByModule('neovim', a:major_version)

FUNCTION  <SNR>7_mail()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:92
Called 3 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000012 	if exists('g:mail42')
                            		return g:mail42
    3              0.000002 	endif
    3              0.000011 	let l:mail = $MAIL
    3              0.000007 	if strlen(l:mail) == 0
    3              0.000005 		let l:mail = "marvin@42.fr"
    3              0.000002 	endif
    3              0.000004 	return l:mail

FUNCTION  <SNR>7_line()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:63
Called 577 times
Total time:   0.064265
 Self time:   0.034364

count  total (s)   self (s)
  577              0.001843 	if a:n == 1 || a:n == 11 " top and bottom line
    6              0.000049 		return s:start . ' ' . repeat(s:fill, s:length - strlen(s:start) - strlen(s:end) - 2) . ' ' . s:end
  571              0.001300 	elseif a:n == 2 || a:n == 10 " blank line
    6   0.000176   0.000049 		return s:textline('', '')
  565              0.001338 	elseif a:n == 3 || a:n == 5 || a:n == 7 " empty with ascii
    9   0.000328   0.000115 		return s:textline('', s:ascii(a:n))
  556              0.000796 	elseif a:n == 4 " filename
  286   0.021178   0.009190 		return s:textline(s:filename(), s:ascii(a:n))
  270              0.000360 	elseif a:n == 6 " author
    3   0.000238   0.000074 		return s:textline("By: " . s:user() . " <" . s:mail() . ">", s:ascii(a:n))
  267              0.000357 	elseif a:n == 8 " created
    3   0.000198   0.000064 		return s:textline("Created: " . s:date() . " by " . s:user(), s:ascii(a:n))
  264              0.000374 	elseif a:n == 9 " updated
  264   0.024864   0.007590 		return s:textline("Updated: " . s:date() . " by " . s:user(), s:ascii(a:n))
                            	endif

FUNCTION  <SNR>18_check_warnings()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:291
Called 17 times
Total time:   0.082588
 Self time:   0.000447

count  total (s)   self (s)
                                " Notify once per buffer if errors have happened.
   17              0.000215     if get(g:, 'VM_show_warnings', 1) && !empty(b:VM_Debug.lines) && !has_key(b:VM_Debug, 'maps_warning')
    6              0.000024         let b:VM_Debug.maps_warning = 1
    6   0.082200   0.000059         call s:V.Funcs.msg('VM has started with warnings. :VMDebug for more info')
   17              0.000015     endif

FUNCTION  63()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:464
Called 121 times
Total time:   0.001304
 Self time:   0.001304

count  total (s)   self (s)
  121              0.001045     return !exists('b:visual_multi')

FUNCTION  65()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:45
Called 56 times
Total time:   0.034110
 Self time:   0.001358

count  total (s)   self (s)
                                " Create a new cursor if there isn't already a region.
                            
   56   0.003350   0.000469     let R = self.region_at_pos()
                            
   56              0.000159     if empty(R)
   45   0.029966   0.000390         return vm#region#new(1)
   11              0.000022     elseif a:0  " toggle cursor
                                    call R.clear()
   11              0.000008     endif
   11   0.000395   0.000102     return s:F.should_quit() ? vm#reset() : R

FUNCTION  66()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:59
Called 107 times
Total time:   0.001306
 Self time:   0.001306

count  total (s)   self (s)
                                " Return current working set of regions.
                            
  107              0.000664     if s:v.single_region    | return [s:V.Regions[s:v.index]]
  107              0.000357     else                    | return s:V.Regions
                                endif

FUNCTION  68()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:101
Called 14 times
Total time:   0.024493
 Self time:   0.001721

count  total (s)   self (s)
                                " Change from extend to cursor mode and viceversa.
                                " Merge cursors if transitioning from cursor mode, but reset direction
                                " transitioning from extend mode.
                            
   14   0.000287   0.000259     if !s:X() | call self.merge_cursors()
   14   0.003673   0.000174     else      | call self.backup_last_regions()
   14              0.000023     endif
                            
   14   0.000255   0.000231     let g:Vm.extend_mode = !s:X()
                            
   14              0.000057     let ix = s:v.index
   14   0.000435   0.000189     call s:F.Scroll.get()
   14   0.000134   0.000113     if s:X()
                                    call self.update_regions()
   14              0.000017     else
   14   0.017674   0.000131         call self.collapse_regions()
   14              0.000015     endif
                            
   14   0.001599   0.000186     let R = self.select_region(ix)
                            
   14              0.000031     if a:0  "called manually
                                    let s:v.restore_scroll = 1
                                    call s:F.Scroll.restore()
   14              0.000014     endif
   14              0.000025     return R

FUNCTION  69()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:130
Called 1 time
Total time:   0.000027
 Self time:   0.000024

count  total (s)   self (s)
                                " Set cursor mode. Return 1 if mode had to be changed.
    1   0.000023   0.000020     if s:X() | call self.change_mode() | return 1 | endif

FUNCTION  <SNR>54_SynSet()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/synload.vim:26
Called 10712 times
Total time:  29.369198
 Self time:  28.527561

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
10712              0.046514   syn clear
10712              0.042540   if exists("b:current_syntax")
                                unlet b:current_syntax
10712              0.008993   endif
                            
10712              0.055761   0verbose let s = expand("<amatch>")
10712              0.022203   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
10712              0.019507   elseif s == "OFF"
                                let s = ""
10712              0.006389   endif
                            
10712              0.013638   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
21424              0.115017     for name in split(s, '\.')
10712              0.032035       if !empty(name)
10712  15.319046  14.477409         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
10712             13.385273         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
10712              0.019742       endif
21424              0.022547     endfor
10712              0.008391   endif

FUNCTION  vm#maps#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:22
Called 17 times
Total time:   0.223004
 Self time:   0.001223

count  total (s)   self (s)
                                " At VM start, buffer mappings are generated (once per buffer) and applied.
   17              0.000060     let s:V = b:VM_Selection
   17   0.138920   0.000505     if !exists('b:VM_maps') | call s:build_buffer_maps() | endif
                            
   17   0.001148   0.000370     call s:Maps.map_esc_and_toggle()
   17   0.082792   0.000204     call s:check_warnings()
   17              0.000035     return s:Maps

FUNCTION  <SNR>78_import_module()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/pythonx.vim:63
Called 3 times
Total time:   0.083034
 Self time:   0.000282

count  total (s)   self (s)
    3   0.082985   0.000232   let prog_version = system([a:prog, '-c' , printf( 'import sys; ' . 'sys.path = [p for p in sys.path if p != ""]; ' . 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' . 'import pkgutil; ' . 'exit(2*int(pkgutil.get_loader("%s") is None))', a:module)])
    3              0.000037   return [v:shell_error, prog_version]

FUNCTION  71()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:147
Called 110 times
Total time:   0.043509
 Self time:   0.006910

count  total (s)   self (s)
                                " Update highlight for all regions.
  110              0.000606     if s:v.eco | return | endif
                            
  110   0.021059   0.000715     call self.remove_highlight()
  364   0.001712   0.001577     for r in s:R()
  254   0.011121   0.001907         call r.highlight()
  364              0.000436     endfor
                            
  110   0.007772   0.000866     call self.update_cursor_highlight()

FUNCTION  72()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:160
Called 205 times
Total time:   0.010259
 Self time:   0.007686

count  total (s)   self (s)
                                " Set cursor highlight, depending on extending mode.
  205              0.000927     if s:v.eco | return | endif
                            
  205              0.000975     highlight clear MultiCursor
                            
  205              0.000422     if s:v.insert
  118              0.001117         exe "highlight link MultiCursor ".g:Vm.hi.insert
                            
   87   0.003483   0.000910     elseif !s:X() && self.all_empty()
   42              0.000414         exe "highlight link MultiCursor ".g:Vm.hi.mono
                            
   45              0.000033     else
   45              0.000286         exe "highlight link MultiCursor ".g:Vm.hi.cursor
  205              0.000165     endif

FUNCTION  73()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:178
Called 273 times
Total time:   0.050340
 Self time:   0.014945

count  total (s)   self (s)
                                " Remove all regions' highlight.
  908   0.004127   0.003755     for r in s:R()
  635   0.033297   0.005286         call r.remove_highlight()
  908              0.001227     endfor
  273   0.009989   0.002979     call vm#clearmatches()

FUNCTION  74()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:192
Called 42 times
Total time:   0.002470
 Self time:   0.002417

count  total (s)   self (s)
                                " If not all regions are empty, turn on extend mode.
  144   0.000669   0.000616     for r in s:R()
  102              0.000278         if r.a != r.b
                                        if !s:X() | let g:Vm.extend_mode = 1 | endif
                                        return 0
  102              0.000087         endif
  144              0.000149     endfor
   42              0.000083     return 1

FUNCTION  75()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:204
Called 96 times
Total time:   0.089550
 Self time:   0.007501

count  total (s)   self (s)
                                " Force regions update.
   96              0.000450     if s:v.eco | return | endif
                            
   96   0.000787   0.000639     if s:X()
                                    for r in s:R() | call r.update_region() | endfor
   96              0.000104     else
  660   0.046738   0.003228         for r in s:R() | call r.update_cursor() | endfor
   96              0.000082     endif
   96   0.037566   0.000768     call self.update_highlight()
   96   0.002449   0.000857     call s:F.restore_reg()

FUNCTION  76()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:218
Called 121 times
Total time:   0.197039
 Self time:   0.014854

count  total (s)   self (s)
                                " Update regions and select region at position, index or id.
  121              0.000400     if s:v.merge
   25              0.003235         let s:v.merge = 0 | return self.merge_regions()
   96              0.000098     endif
                            
   96   0.019284   0.000915     call self.remove_highlight()
                            
   96   0.002829   0.000883     call self.reset_byte_map(0)
   96   0.002596   0.000704     call self.reset_vars()
   96   0.006016   0.000759     call self.update_indices()
   96   0.090284   0.000734     call self.update_regions()
                            
                                "a region is going to be reselected:
                                "   no arguments        ->  position '.'
                                "   a:1 not a dict      ->  position (a string, a list [ln, col], an offset)
                                "   {'index': i}        ->  index
                                "   {'id': i}           ->  id
                            
   96   0.001112   0.000999     let nR = len(s:R())
   96              0.000534     if !nR | return vm#reset() | endif
                            
   96              0.000226     if !g:VM_reselect_first
   96              0.000417         if exists('s:v.restore_index')
                                        let i = s:v.restore_index >= nR? nR - 1 : s:v.restore_index
                                        let R = self.select_region(i)
                                        unlet s:v.restore_index
   96              0.000188         elseif a:0
   96              0.000428             if type (a:1) != v:t_dict
   96   0.023592   0.000967                 let R = self.select_region_at_pos(a:1)
                                        elseif  has_key(a:1, 'index')
                                            let i = a:1.index >= nR? nR - 1 : a:1.index
                                            let R = self.select_region(i)
                                        elseif has_key(a:1, 'id')
                                            let R = self.select_region(s:F.region_with_id(a:1.id).index)
                                        else
                                            return s:F.msg('[visual-multi] '.  'update_and_select_region() '.  'called with wrong arguments')
   96              0.000097             endif
                                    else
                                        let R = self.select_region_at_pos('.')
   96              0.000087         endif
                                else
                                    let R = self.select_region(0)
   96              0.000088     endif
                            
   96   0.003394   0.001020     return s:F.should_quit() ? vm#reset() : R

FUNCTION  <SNR>7_user()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:81
Called 270 times
Total time:   0.005308
 Self time:   0.005308

count  total (s)   self (s)
  270              0.001381 	if exists('g:user42')
                            		return g:user42
  270              0.000194 	endif
  270              0.000963 	let l:user = $USER
  270              0.000774 	if strlen(l:user) == 0
                            		let l:user = "marvin"
  270              0.000146 	endif
  270              0.000398 	return l:user

FUNCTION  vm#operators#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/operators.vim:5
Called 17 times
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
   17              0.000095     let s:V = b:VM_Selection
   17              0.000042     let s:v = s:V.Vars
   17              0.000055     let s:G = s:V.Global
   17              0.000034     let s:F = s:V.Funcs

FUNCTION  vm#icmds#cw()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/icmds.vim:86
Called 5 times
Total time:   0.037211
 Self time:   0.011553

count  total (s)   self (s)
    5   0.000159   0.000084     let size = s:F.size()
    5              0.000039     let change = 0 | let s:v.eco = 1
    5              0.000050     let s:v.storepos = getpos('.')[1:2]
    5              0.000035     let keep_line = get(g:, 'VM_icw_keeps_line', 1)
                            
   19   0.000097   0.000089     for r in s:R()
   14   0.000793   0.000149         call r.shift(change, change)
                            
                                    "TODO: deletion to line above can be bugged for now
   23              0.000071         if keep_line && r.a == 1 | continue | endif
                            
   14   0.000452   0.000134         call s:F.Cursor(r.A)
                            
   14   0.000316   0.000171         if r.a > 1 && s:eol(r) "add extra space and move right
                                        call s:V.Edit.extra_spaces.add(r)
                                        call r.move('l')
   14              0.000014         endif
                            
   14              0.000066         let L = getline(r.l)
   14              0.000221         let ws_only = r.a > 1 && match(L[:(r.a-2)], '[^ \t]') < 0
                            
   14              0.000036         if a:ctrlu          "ctrl-u
                                        keepjumps normal! d^
   14              0.000041         elseif r.a == 1     "at bol, go up and join lines
                                        keepjumps normal! kgJ
   14              0.000027         elseif ws_only      "whitespace only before, delete it
    8   0.007145   0.004703             keepjumps normal! d0
    6              0.000009         else                "normal deletion
    6   0.007694   0.004609             keepjumps normal! db
   14              0.000026         endif
   14   0.002951   0.000155         call r.update_cursor_pos()
                            
                                    "update changed size
   14   0.000260   0.000151         let change = s:F.size() - size
   19              0.000038     endfor
    5   0.016113   0.000076     call s:V.Insert.start(1)

FUNCTION  161()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:34
Called 46 times
Total time:   0.188918
 Self time:   0.007712

count  total (s)   self (s)
                                " Starting insert mode with a key (i,I,a,A...), make adjustments if needed.
   46              0.000392     if empty(self.type)
   14              0.000236         let self.type = a:type
   46              0.000071     endif
                            
   46              0.000112     if self.replace
                                    call s:G.one_region_per_line()
   46              0.000049     endif
                            
   46   0.001874   0.000592     call vm#comp#icmds()        "compatibility tweaks
   46   0.001278   0.000698     call s:map_single_mode(0)
                            
   46              0.000159     if a:type ==# 'I'
                                    call vm#commands#merge_to_beol(0)
                                    call self.key('i')
                            
   46              0.000120     elseif a:type ==# 'A'
    1   0.004040   0.000013         call vm#commands#merge_to_beol(1)
    1              0.000005         call self.key('a')
                            
   45              0.000092     elseif a:type ==# 'o'
                                    call vm#commands#merge_to_beol(1)
                                    call vm#icmds#insert_line(0)
                                    call self.start(1)
                            
   45              0.000087     elseif a:type ==# 'O'
                                    call vm#commands#merge_to_beol(0)
                                    call vm#icmds#insert_line(1)
                                    call self.start(1)
                            
   45              0.000086     elseif a:type ==# 'a'
    1   0.000007   0.000006         if s:X()
                                        if s:v.direction | call vm#commands#invert_direction() | endif
                                        call s:G.change_mode()
                                        let s:v.direction = 1
    1              0.000001         endif
    6   0.002692   0.000038         for r in s:R() | call s:V.Edit.extra_spaces.add(r) | endfor
    1   0.002379   0.000012         call vm#commands#motion('l', 1, 0, 0)
    1   0.002064   0.000011         call self.start(1)
                            
   44              0.000046     else
   44   0.000584   0.000471         if s:X()
   14              0.000113             if !s:v.direction | call vm#commands#invert_direction() | endif
   14   0.024678   0.000186             call s:G.change_mode()
   44              0.000044         endif
                            
   44   0.136680   0.000441         call self.start()
   46              0.000039     endif

FUNCTION  162()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:86
Called 50 times
Total time:   0.154329
 Self time:   0.019446

count  total (s)   self (s)
                                " Initialize and then start insert mode.
                                "--------------------------------------------------------------------------
                            
                                "Initialize Insert Mode dict. 'begin' is the initial ln/col, and will be
                                "used to track all changes from that point, to apply them on all cursors
                            
                                "--------------------------------------------------------------------------
   50   0.085424   0.000464     call s:G.merge_cursors()
                            
   50              0.000160     let I = self
   50              0.000298     let I._index = get(I, '_index', -1)
                            
   50   0.024479   0.000589     let R = I.apply_settings()
                            
   50              0.000182     let I.index     = R.index
   50              0.000369     let I.begin     = [R.l, R.a]
   50              0.000296     let I.cursors   = []
   50              0.002180     let I.lines     = {}
   50              0.000152     let I.change    = 0         " text change, only if g:VM_live_editing
   50              0.000244     let I.col       = col('.')
   50              0.000169     let I.reupdate  = v:false   " set by InsertCharPre and CompleteDone
                            
                                " remove current regions highlight
   50   0.008730   0.000597     call s:G.remove_highlight()
                            
                                " create cursors and line objects
  166   0.000704   0.000637     for r in s:R()
  116   0.006363   0.001224         let C = s:Cursor.new(r.l, r.a)
  116              0.000569         call add(I.cursors, C)
                            
                                    " if cursor is at EOL/empty line, an extra space will be added
                                    " if starting with keys 'a/A', spaces have been added already
  116              0.000235         if !a:0
  100   0.004892   0.000994             call s:V.Edit.extra_spaces.add(r)
  116              0.000108         endif
                            
  116              0.000637         if !has_key(I.lines, r.l)
  110   0.004025   0.001470             let I.lines[r.l] = s:Line.new(r.l, C)
  170              0.000606             let nth = 0 | let C.nth = 0
    6              0.000003         else
    6              0.000007             if !s:v.single_region
    6              0.000010                 let nth += 1
    6              0.000003             endif
    6              0.000009             let C.nth = nth
    6              0.000020             call add(I.lines[r.l].cursors, C)
  116              0.000157         endif
  197              0.000553         if C.index == I.index | let I.nth = C.nth | endif
  166              0.000217     endfor
                            
                                " create a backup of the original lines
   50              0.000173     if self.replace && !exists('I._lines')
                                    let I._lines = map(copy(I.lines), 'v:val.txt')
   50              0.000046     endif
                            
                                "start tracking text changes
   50   0.004991   0.000583     let s:v.insert = 1 | call I.auto_start()
                            
                                "change/update cursor highlight
   50   0.002268   0.000436     call s:G.update_cursor_highlight()
                            
                                "start insert mode
   50              0.000101     if self.replace
                                    startreplace
   50              0.000045     else
   50              0.000059         startinsert
   50              0.000043     endif

FUNCTION  163()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:156
Called 50 times
Total time:   0.023889
 Self time:   0.008619

count  total (s)   self (s)
                                " Apply/disable settings related to insert mode. Return current region.
                            
                                " get winline and backup regions when insert mode is entered the first time
   50              0.000292     if !exists('s:v.winline_insert')
   14              0.000099         let s:v.winline_insert = winline()
   14   0.003762   0.000123         call s:G.backup_regions()
   50              0.000056     endif
                            
                                " syn minlines/synmaxcol settings
   50              0.000096     if !s:v.insert
   14              0.000037         if g:VM_disable_syntax_in_imode
                                        let &l:synmaxcol = 1
   14              0.000119         elseif get(g:, 'VM_reduce_sync_minlines', 1) && len(b:VM_sync_minlines)
   14              0.000074             if get(b:, 'VM_minlines', 0)
                                            exe 'syn sync minlines='.b:VM_minlines
   14              0.000015             else
   14              0.000139                 syn sync minlines=1
   14              0.000018             endif
   14              0.000012         endif
   50              0.000039     endif
                            
   50              0.000187     if g:VM_use_first_cursor_in_line || self.replace
                                    let R = s:G.select_region_at_pos('.')
                                    let ix = s:G.lines_with_regions(0, R.l)[R.l][0]
                                    let R = s:G.select_region(ix)
   50              0.000100     elseif s:v.insert
   36   0.000525   0.000484         let i = self.index >= len(s:R())? len(s:R())-1 : self.index
   36   0.003260   0.000314         let R = s:G.select_region(i)
   14              0.000015     else
   14   0.003360   0.000156         let R = s:G.select_region_at_pos('.')
   50              0.000050     endif
                            
                                " restore winline anyway, because it could have been auto-restarted
   50   0.003958   0.000473     call s:F.Scroll.force(s:v.winline_insert)
   50   0.001065   0.000469     call s:F.Scroll.get(1)
                            
                                "disable indentkeys and other settings that may mess up the text
                                "keep o,O to detect indent for <CR>, though
   50   0.001260   0.000629     setlocal indentkeys=o,O
   50   0.000715   0.000427     setlocal cinkeys=o,O
   50   0.001225   0.001024     setlocal textwidth=0
   50              0.000198     if !&expandtab
   50   0.000642   0.000404         setlocal softtabstop=0
   50              0.000071     endif
   50              0.000128     return R

FUNCTION  164()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:211
Called 71 times
Total time:   0.113781
 Self time:   0.014625

count  total (s)   self (s)
                                " Update the text on TextChangedI event, and just after InsertLeave.
                            
   71   0.002190   0.001498     if s:F.not_VM() || !g:VM_live_editing && !a:insert_leave | return | endif
                            
   71   0.003156   0.001680     call vm#comp#TextChangedI()  "compatibility tweaks
                            
   71              0.000236     let I = self
   71              0.000206     let L = I.lines
                            
                                " this is the current cursor position
   71              0.000278     let ln   = line('.')
   71              0.000285     let coln = col('.')
                            
                                " we're now evaluating the current (original) line
                                " we're only interested in column changes, since we insert text horizontally
                            
                                " I.begin is the starting column, when insert mode is entered
                                " I.change is the total length of the newly inserted text up to this moment
                                " I.nth refers to the n. of cursors in the same line: it's 0 if there is only
                                " a cursor, but if there are more cursors in the line, their changes add up
                                " In fact, even if it's the original cursor, there may be cursors behind it,
                                " and it will be 'pushed' forward by them
                            
                                " Given the above, the adjusted initial position will then be:
                                "   initial position + ( current change  * number of cursors behind it)
   71              0.000434     let pos = I.begin[1] + I.change*I.nth
                            
                                " find out the actual text that has been inserted up to this point:
                                " it's a slice of the current line, between the updated initial position
                                " (pos) and the current cursor position (coln)
                            
                                " coln needs some adjustments though:
                                "   -  in insert mode, 1 is subtracted to find the current cursor position
                                "   -  but when insert mode stops (a:insert_leave == 1) this isn't true
                            
                                " when exiting insert mode (a:insert_leave), if the last last inserted
                                " character is multibyte, any extra bytes will have to be added to the
                                " final column
   71              0.000148     if a:insert_leave
   16   0.001259   0.000413         let extra = s:cur_char_bytes() - 1
   16              0.000185         let text = getline(ln)[ (pos-1) : (coln-1 + extra) ]
   16              0.000077         let coln += extra
   55              0.000150     elseif coln > 1
   53              0.000305         let text = getline(ln)[ (pos-1) : (coln-2) ]
    2              0.000001     else
    2              0.000002         let text = ''
   71              0.000058     endif
                            
                                " now update the current change: secondary cursors need this value updated
   71              0.000314     let I.change = coln - pos + a:insert_leave
                            
                                " update the lines (also the current line is updated with setline(), this
                                " should ensure that the same text is entered everywhere)
   71              0.000132     if I.replace
                                    let width = strwidth(text)
                                    for l in sort(keys(L))
                                        call L[l].replace(I.change, text, width)
                                    endfor
   71              0.000059     else
  221              0.001031         for l in sort(keys(L))
  150   0.098368   0.002226             call L[l].update(I.change, text)
  221              0.000715         endfor
   71              0.000070     endif
                            
                                " put the cursor where it should stay after the lines update
                                " as said before, the actual cursor can be pushed by cursors behind it
   71              0.000439     call cursor(ln, I.col)

FUNCTION  vm#commands#add_cursor_down()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:97
Called 15 times
Total time:   0.277008
 Self time:   0.002498

count  total (s)   self (s)
                                " Add cursors vertically, downwards.
   15   0.000373   0.000282     if s:last_line() | return | endif
   15   0.253446   0.000250     call s:set_extend_mode(a:extend)
   15   0.000554   0.000187     let s:v.vertical_col = s:F.get_vertcol()
   15   0.007873   0.000136     call s:G.new_cursor()
   15              0.000045     let N = a:count
                            
   32              0.000053     while N
   17              0.000608         normal! j
   20   0.012114   0.000298         if !s:skip_shorter_lines() | let N -= 1 | endif
   19   0.000206   0.000154         if s:last_line()           | break      | endif
   32              0.000037     endwhile
                            
   15   0.001415   0.000166     call s:went_too_far()

FUNCTION  166()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:388
Called 50 times
Total time:   0.002084
 Self time:   0.002084

count  total (s)   self (s)
                                " Clear cursors highlight.
  166              0.000679     for c in self.cursors
  116              0.000710         silent! call matchdelete(c.hl)
  166              0.000239     endfor

FUNCTION  167()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:411
Called 116 times
Total time:   0.005139
 Self time:   0.005139

count  total (s)   self (s)
                                " Create new cursor.
  116              0.000732     let C        = copy(self)
  116              0.000598     let C.index  = len(s:Insert.cursors)
  116              0.000296     let C.txt    = ''
  116              0.000316     let C.l      = a:ln
  116              0.000273     let C.L      = a:ln
  116              0.000271     let C.a      = a:col
  116              0.000343     let C._a     = C.a
  116              0.000476     let C.active = ( C.index == s:Insert.index )
  116              0.001107     let C.hl     = matchaddpos('MultiCursor', [[C.l, C.a]], 40)
                            
  116              0.000248     return C

FUNCTION  168()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:427
Called 162 times
Total time:   0.004174
 Self time:   0.004174

count  total (s)   self (s)
                                " Update cursor position and highlight.
  162              0.000527     let C = self
  162              0.000618     let C._a = C.a + a:change
                            
  162              0.000892     silent! call matchdelete(C.hl)
  162              0.001635     let C.hl  = matchaddpos('MultiCursor', [[C.l, C._a]], 40)

FUNCTION  169()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:445
Called 110 times
Total time:   0.002555
 Self time:   0.002555

count  total (s)   self (s)
                                " Line object constructor.
  110              0.000708     let L         = copy(self)
  110              0.000371     let L.l       = a:line
  110              0.000521     let L.txt     = getline(a:line)
  110              0.000460     let L.cursors = [a:cursor]
  110              0.000229     return L

FUNCTION  <SNR>74_call_motion()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:607
Called 25 times
Total time:   0.070397
 Self time:   0.002756

count  total (s)   self (s)
   25   0.000685   0.000270     if s:F.no_regions() | return | endif
   25   0.000471   0.000194     call s:F.Scroll.get()
   25   0.000335   0.000302     let R = s:R()[ s:v.index ]
                            
   25   0.000326   0.000301     let regions = (a:0 && a:1) || s:v.single_region ? [R] : s:R()
                            
   25   0.001432   0.000260     call s:before_move()
                            
  153   0.022107   0.000781     for r in regions | call r.move() | endfor
                            
                                "update variables, facing direction, highlighting
   25   0.044826   0.000435     call s:after_move(R)

FUNCTION  vm#commands#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:34
Called 17 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
                                " Variables initialization.
   17              0.000050     let s:V        = b:VM_Selection
   17              0.000034     let s:v        = s:V.Vars
   17              0.000030     let s:G        = s:V.Global
   17              0.000030     let s:F        = s:V.Funcs
   17              0.000035     let s:Search   = s:V.Search
   17              0.000044     let s:v.motion = ''

FUNCTION  remote#host#IsRunning()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/remote/host.vim:49
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000019   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
    2              0.000002   endif
    2              0.000008   return s:hosts[a:name].channel != 0

FUNCTION  <SNR>7_update()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:128
Called 286 times
Total time:   0.436911
 Self time:   0.311044

count  total (s)   self (s)
  286   0.066739   0.003212 	call s:filetype()
  286              0.005597 	if getline(9) =~ s:start . repeat(' ', s:margin - strlen(s:start)) . "Updated: "
  283              0.001695 		if &mod
  261   0.239698   0.204574 			call setline(9, s:line(9))
  283              0.000630 		endif
  283   0.120569   0.093354 		call setline(4, s:line(4))
  283              0.000926 		return 0
    3              0.000002 	endif
    3              0.000003 	return 1

FUNCTION  <SNR>93_set_commands()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/special/commands.vim:399
Called 17 times
Total time:   0.000883
 Self time:   0.000883

count  total (s)   self (s)
   17              0.000306   command! -buffer -bang -nargs=? VMFilterRegions call vm#special#commands#filter_regions(<bang>0, <q-args>, empty(<q-args>))
   17              0.000098   command! -buffer VMFilterLines                  call vm#special#commands#filter_lines()
   17              0.000093   command! -buffer VMRegionsToBuffer              call vm#special#commands#regions_to_buffer()
   17              0.000098   command! -buffer VMMassTranspose                call vm#special#commands#mass_transpose()
   17              0.000120   command! -buffer -bang VMQfix                   call vm#special#commands#qfix(!<bang>0)
   17              0.000111   command! -buffer -nargs=? VMSort                call vm#special#commands#sort(<args>)

FUNCTION  provider#clipboard#Call()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/clipboard.vim:241
Called 128 times
Total time:   1.961203
 Self time:   0.009518

count  total (s)   self (s)
  128              0.001905   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
  128              0.000164   endif
  128              0.000739   let s:here = v:true
  128              0.000218   try
  128   1.955638   0.003953     return call(s:clipboard[a:method],a:args,s:clipboard)
  128              0.000257   finally
  128              0.000499     let s:here = v:false
  128              0.000389   endtry

FUNCTION  vm#operators#after_yank()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/operators.vim:106
Called 25 times
Total time:   0.000547
 Self time:   0.000547

count  total (s)   self (s)
                                "find operator
   25              0.000087     if g:Vm.finding
                                    let g:Vm.finding = 0
                                    call vm#operators#find(0, s:v.visual_regex)
                                    let s:v.visual_regex = 0
                                    call s:old_updatetime()
                                    nmap <silent> <nowait> <buffer> y <Plug>(VM-Yank)
   25              0.000024     endif

FUNCTION  80()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:307
Called 14 times
Total time:   0.003639
 Self time:   0.003596

count  total (s)   self (s)
                                " Store a copy of the current regions.
                            
   14              0.001791     let tick   = undotree().seq_cur
   14              0.000064     let backup = b:VM_Backup
   14              0.000110     let index  = index(backup.ticks, backup.last)
                            
   14              0.000075     if index < len(backup.ticks) - 1
                                    let backup.ticks = backup.ticks[:index]
   14              0.000016     endif
                            
   14              0.000077     call add(backup.ticks, tick)
   14   0.001287   0.001244     let backup[tick] = { 'regions': deepcopy(s:R()), 'X': s:X() }
   14              0.000082     let backup.last = tick

FUNCTION  81()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:324
Called 31 times
Total time:   0.006461
 Self time:   0.006375

count  total (s)   self (s)
                                " Create a backup of last set of regions.
                            
   31              0.000616     let b:VM_LastBackup = {}
   31              0.000181     let b:VM_LastBackup.extend = g:Vm.extend_mode
   31   0.005062   0.004976     let b:VM_LastBackup.regions = map(deepcopy(s:R()), "{'A': v:val.A, 'B': v:val.B}")
   31              0.000197     let b:VM_LastBackup.search = s:v.search
   31              0.000118     let b:VM_LastBackup.index = s:v.index
   31              0.000135     let s:v.direction = 1

FUNCTION  82()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:336
Called 14 times
Total time:   0.017543
 Self time:   0.001347

count  total (s)   self (s)
                                " Collapse regions to cursors and turn off extend mode.
                            
   14   0.000592   0.000133     call self.reset_byte_map(0)
                            
  102   0.009887   0.000861     for r in s:R() | call r.update_cursor([r.l, (r.dir? r.a : r.b)]) | endfor
   14              0.000044     let g:Vm.extend_mode = 0
   14   0.006874   0.000164     call self.update_highlight()

FUNCTION  83()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:347
Called 206 times
Total time:   0.020716
 Self time:   0.013470

count  total (s)   self (s)
                                " Adjust cursor position of the region at index, then return region.
                            
  206   0.002700   0.002461     if !len(s:R()) | return | endif
                            
  206   0.002565   0.002340     let i = a:i >= len(s:R())? 0 : a:i
                            
  206   0.001940   0.001732     let R = s:R()[i]
  206   0.005438   0.003363     call cursor(R.cur_ln(), R.cur_col())
  206   0.006094   0.001594     call s:F.Scroll.restore()
  206              0.000709     let s:v.index = R.index
  206              0.000384     return R

FUNCTION  84()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:362
Called 110 times
Total time:   0.025829
 Self time:   0.003112

count  total (s)   self (s)
                                " Try to select a region at the given position.
                            
  110   0.010798   0.001204     let r = self.region_at_pos(a:pos)
  110              0.000397     if !empty(r)
   96   0.010879   0.000869         return self.select_region(r.index)
   14              0.000014     else
   14   0.003364   0.000251         return self.select_region(self.nearest_region().index)
                                endif

FUNCTION  85()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:374
Called 300 times
Total time:   0.037694
 Self time:   0.030423

count  total (s)   self (s)
                                " Return the region at position, or an empty dict if not found.
                            
  300   0.010391   0.003947     let pos = a:0 ? s:F.pos2byte(a:1) : s:F.curs2byte()
  300   0.011901   0.011439     if s:X() && !has_key(s:V.Bytes, pos) | return {} | endif
                            
  530   0.010584   0.010220     for r in s:R()
  487              0.001854         if pos >= r.A && pos <= r.B
  212              0.000385             return r
  275              0.000263         endif
  318              0.000329     endfor
   43              0.000110     return {}

FUNCTION  86()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:389
Called 14 times
Total time:   0.000870
 Self time:   0.000619

count  total (s)   self (s)
                                " Return the nearest region at position.
                            
   14   0.000241   0.000226     let Rs = s:R() | if !len(Rs) | return {} | endif
                            
   14   0.000394   0.000158     let pos = a:0 ? s:F.pos2byte(a:1) : s:F.curs2byte()
                            
   14              0.000090     if pos <= Rs[0].A  | return Rs[0]  | endif
   14              0.000075     if pos >= Rs[-1].B | return Rs[-1] | endif
                            
                                for r in Rs
                                    if pos <= r.B
                                        return r
                                    endif
                                endfor

FUNCTION  <lambda>130()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:932
Called 53 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
                            return g:Vm.extend_mode 

FUNCTION  <lambda>131()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:933
Called 50 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
                            return s:V.Regions      

FUNCTION  <lambda>133()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:935
Called 26 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
                            return line('.') == 1 

FUNCTION  <lambda>134()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:936
Called 32 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
                            return line('.') == line('$') 

FUNCTION  <lambda>135()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:937
Called 24 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
                            return index(['^', '0', '%', '$'],     s:v.motion) >= 0 

FUNCTION  <lambda>139()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/funcs.vim:15
Called 50 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
                            return s:V.Regions 

FUNCTION  <SNR>74_set_extend_mode()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:45
Called 28 times
Total time:   0.417095
 Self time:   0.000862

count  total (s)   self (s)
                                " If just starting, enable extend mode if appropriate.
                            
   28   0.417000   0.000767     if s:X() || a:X | return s:init(0, 1, 1)
                                else            | return s:init(0, 1, 0)
                                endif

FUNCTION  vm#icmds#x()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/icmds.vim:22
Called 7 times
Total time:   0.042862
 Self time:   0.020918

count  total (s)   self (s)
    7   0.000225   0.000125     let size = s:F.size()
    7              0.000055     let change = 0 | let s:v.eco = 1
    7              0.000072     if empty(s:v.storepos) | let s:v.storepos = getpos('.')[1:2] | endif
    7   0.000099   0.000088     let active = s:R()[s:V.Insert.index]
                            
   26   0.000109   0.000101     for r in s:R()
   19              0.000063         if s:v.single_region && r isnot active
                                        if r.l == active.l
                                            call r.shift(change, change)
                                        endif
                                        continue
   19              0.000086         endif
                            
   19   0.001045   0.000208         call r.shift(change, change)
   19   0.000592   0.000185         call s:F.Cursor(r.A)
                            
                                    " we want to emulate the behaviour that <del> and <bs> have in insert
                                    " mode, but implemented as normal mode commands
                            
   19              0.000048         if s:V.Insert.replace
                                        " in replace mode, we don't allow line joining
                                        if a:cmd ==# 'X' && r.a > 1
                                            let original = s:V.Insert._lines[r.l] " the original line
                                            if strpart(getline(r.l), r.a) =~ '\s*$' " at EOL
                                                call search('\s*$', '', r.l)
                                            endif
                                            "FIXME this part is bugged with multibyte chars
                                            call r.shift(-1,-1)
                                            if r.a > 1
                                                let t1 = strpart(getline('.'), 0, r.a - 1)
                                                let wd = strwidth(t1)
                                                let tc = strcharpart(original, wd, 1)
                                                let t2 = strcharpart(original, wd + 1)
                                                call setline(r.l, t1 . tc . t2)
                                            else
                                                let pre = ''
                                                let post = original
                                                call setline(r.l, pre . post)
                                            endif
                                        endif
   19              0.000123         elseif a:cmd ==# 'x' && s:eol(r)    "at eol, join lines
                                        keepjumps normal! gJ
   19              0.000042         elseif a:cmd ==# 'x'                "normal delete
                                        keepjumps normal! x
   19              0.000068         elseif a:cmd ==# 'X' && r.a == 1    "at bol, go up and join lines
    8              0.007862             keepjumps normal! kgJ
    8   0.000364   0.000103             call r.shift(-1,-1)
   11              0.000018         else                                "normal backspace
   11   0.014205   0.008833             keepjumps normal! X
   11              0.000114             let w = strlen(@-)
   11   0.000819   0.000189             call r.shift(-w, -w)
   19              0.000022         endif
                            
                                    "update changed size
   19   0.000467   0.000320         let change = s:F.size() - size
   26              0.000053     endfor
                            
    7   0.013520   0.000095     call s:G.merge_regions()
    7   0.000811   0.000067     call s:G.select_region(s:V.Insert.index)

FUNCTION  170()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:455
Called 150 times
Total time:   0.096142
 Self time:   0.091968

count  total (s)   self (s)
                                " Update a line in insert mode.
  150              0.000638     let text     = self.txt
  150              0.000439     let I        = s:V.Insert
  150              0.000402     let extraChg = 0  " cumulative change for additional cursors in same line
                            
                                " self.txt is the initial text of the line, when insert mode starts
                                " it is not updated: the new text will be inserted inside of it
                                " 'text' is the updated content of the line
                            
                                " self.cursors are the cursors in this line
                            
                                " when created, cursors are relative to normal mode, but in insert mode
                                " 1 must be subtracted from their column (c.a)
                            
                                " a:change is the length of the text inserted by the main cursor
                                " if there are more cursors in the same line, changes add up (== extraChg)
                            
                                " to sum it up, if:
                                "     t1 is the original line, before the insertion point
                                "     t2 is the original line, after the insertion point
                                "     // is the insertion point (== c.a - 1 + nth*a:change)
                                "     \\ is the end of the inserted text
                                " then:
                                "     line = t1 // inserted text \\ t2
                            
  312              0.000858     for c in self.cursors
  162              0.000474         if s:v.single_region && !c.active
                                        call c.update(self.l, extraChg)
                                        continue
  162              0.000144         endif
                            
  162              0.001511         let inserted = exists('s:v.smart_case_change') ? s:smart_case_change(c, a:text) : a:text
                            
  162              0.000419         if c.a > 1
  154              0.000585             let insPoint = c.a + extraChg - 1
  154              0.000788             let t1 = text[ 0 : (insPoint - 1) ]
  154              0.000516             let t2 = text[ insPoint : ]
  154              0.000636             let text = t1 . inserted . t2
                                        " echo strtrans(t1) . "█" . strtrans(inserted) . "█" . strtrans(t2)
    8              0.000005         else
                                        " echo "█" . strtrans(inserted) . "█" . strtrans(text)
    8              0.000018             let text = inserted . text
  162              0.000124         endif
                            
                                    " increase the cumulative extra change
  162              0.000608         let extraChg += a:change
  162   0.007503   0.003329         call c.update(self.l, extraChg)
                            
                                    " c._a is the updated cursor position, c.a stays the same
  174              0.000833         if c.active | let I.col = c._a | endif
  312              0.000464     endfor
  150              0.070216     call setline(self.l, text)

FUNCTION  172()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:543
Called 50 times
Total time:   0.004408
 Self time:   0.004408

count  total (s)   self (s)
                                " Initialize autocommands.
   50              0.000452     augroup VM_insert
   50              0.002130         au!
   50              0.000557         au TextChangedI  <buffer> call b:VM_Selection.Insert.update_text(0)
   50              0.000379         au InsertLeave   <buffer> call b:VM_Selection.Insert.stop()
   50              0.000343         au InsertCharPre <buffer> let b:VM_Selection.Insert.reupdate = v:true
   50              0.000322         au CompleteDone  <buffer> let b:VM_Selection.Insert.reupdate = v:true
   50              0.000080     augroup END

FUNCTION  173()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:555
Called 67 times
Total time:   0.004210
 Self time:   0.004210

count  total (s)   self (s)
                                " Terminate autocommands.
   67              0.003152     autocmd! VM_insert
   67              0.000841     augroup! VM_insert

FUNCTION  vm#comp#conceallevel()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:83
Called 17 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
                                " indentLine compatibility. {{{1
   17              0.000107     return exists('b:indentLine_ConcealOptionSet') && b:indentLine_ConcealOptionSet

FUNCTION  <SNR>78_get_python_candidates()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/pythonx.vim:27
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000017   return { 3: ['python3', 'python3.10', 'python3.9', 'python3.8', 'python3.7', 'python'] }[a:major_version]

FUNCTION  <SNR>78_get_python_executable_from_host_var()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/pythonx.vim:23
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000039   return expand(get(g:, 'python'.(a:major_version == 3 ? '3' : execute("throw 'unsupported'")).'_host_prog', ''), v:true)

FUNCTION  <SNR>59_foldable()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/syntax/ruby.vim:40
Called 159 times
Total time:   0.001563
 Self time:   0.001563

count  total (s)   self (s)
  159              0.000580   if index(s:foldable_groups, 'NONE') > -1
                                return 0
  159              0.000093   endif
                            
  159              0.000367   if index(s:foldable_groups, 'ALL') > -1
  159              0.000154     return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  <SNR>89_map_single_mode()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:619
Called 60 times
Total time:   0.000720
 Self time:   0.000720

count  total (s)   self (s)
                                " If single_region is active, map Tab to cycle regions.
   60              0.000552     if !s:v.single_region || !get(g:, 'VM_single_mode_maps', 1) | return | endif
                            
                                let next = get(g:VM_maps, 'I Next', '<Tab>')
                                let prev = get(g:VM_maps, 'I Prev', '<S-Tab>')
                            
                                if a:stop
                                    exe 'iunmap <buffer>' next
                                    exe 'iunmap <buffer>' prev
                                    if exists('s:v.single_mode_running')
                                        if s:v.single_mode_running
                                            let s:v.single_mode_running = 0
                                        else
                                            if get(g:, 'VM_single_mode_auto_reset', 1)
                                                call s:F.toggle_option('single_region')
                                            endif
                                            unlet s:v.single_mode_running
                                        endif
                                    endif
                                else
                                    exe 'imap <buffer>' next '<Plug>(VM-I-Next)'
                                    exe 'imap <buffer>' prev '<Plug>(VM-I-Prev)'
                                endif

FUNCTION  92()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:465
Called 96 times
Total time:   0.001892
 Self time:   0.001376

count  total (s)   self (s)
                                " Reset variables during final regions update.
                                "Note: this eco/auto check is old and seems wrong. Keeping for now but it should go
                            
   96              0.000570     if !( s:v.eco || s:v.auto ) | return | endif
                            
   26              0.000149     let s:v.auto = 0    | let s:v.eco = 0
   26              0.000076     let s:v.no_search = 0
   26   0.000740   0.000224     call s:F.restore_reg()

FUNCTION  94()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:496
Called 109 times
Total time:   0.005752
 Self time:   0.005623

count  total (s)   self (s)
                                " Adjust region indices.
                            
  109              0.000323     if a:0
   13              0.000027         let i = a:1
   46   0.000158   0.000145         for r in s:R()[i:]
   33              0.000073             let r.index = i
   33              0.000057             let i += 1
   46              0.000043         endfor
   13              0.000015         return
   96              0.000085     endif
                            
   96              0.000230     let i = 0
  316   0.001229   0.001112     for r in s:R()
  220              0.000678         let r.index = i
  220              0.000524         let i += 1
  316              0.000338     endfor

FUNCTION  <lambda>140()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:2
Called 17 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
                            return &ft == 'ctrlsf' 

FUNCTION  <lambda>141()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:2
Called 17 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
                            return exists('b:autopairs_enabled') && b:autopairs_enabled 

FUNCTION  <lambda>142()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:2
Called 17 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
                            return exists('g:loaded_smartinput') && g:loaded_smartinput == 1 

FUNCTION  <lambda>143()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:2
Called 17 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
                            return exists('b:tagalong_initialized') 

FUNCTION  <SNR>75_buffer_leave()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:253
Called 4 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    4              0.000033     if exists('b:VM_skip_reset_once_on_bufleave')
                                    unlet b:VM_skip_reset_once_on_bufleave
    4              0.000058     elseif !empty(get(b:, 'VM_Selection', {})) && !b:VM_Selection.Vars.insert
                                    call vm#reset(1)
    4              0.000005     endif

FUNCTION  187()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:90
Called 45 times
Total time:   0.022613
 Self time:   0.004178

count  total (s)   self (s)
                                " Initialize region variables and methods.
                                "
                                " Uppercase variables (A,B,K) are for byte offsets, except L (end line).
                            
                                " a/b/k/l/L    : start, end, anchor, first line, end line
                                " R.cur_col()  : returns the current cursor column(a or b), based on direction.
                                " R.cur_Col()  : cur_col() in byte offset form
                                " R.cur_ln()   : the line where cur_col() is located
                                " R.char()     : returns the char under the active head, '' in cursor mode.
                                " R.id         : an individual incremental id, that will never change.
                                " R.dir        : is the current orientation for the region.
                                " R.txt        : is the text content.
                                " R.pat        : is the search pattern associated with the region
                                " R.matches    : holds the highlighting matches
                            
   45              0.000785     let R         = copy(self)
   45   0.000471   0.000412     let R.index   = len(s:R())
   45              0.000140     let R.dir     = s:v.direction
   45              0.000134     let R.id      = s:v.ID + 1
                            
   45              0.000240     let R.matches = {'region': [], 'cursor': 0}
                            
   45              0.000080     if !a:0                "/////// FROM MAPPINGS ///////
                            
   45   0.012474   0.000502         call s:region_vars(R, a:cursor)
                            
                                else                   "///////// FROM ARGS ///////////
                            
                                    call s:region_vars(R, a:cursor, a:1, a:2, a:3, a:4)
   45              0.000038     endif
                            
   45              0.000207     call add(s:v.IDs_list, R.id)
                            
   45              0.000082     if !s:v.eco
   45   0.005363   0.000341         call R.highlight()
   45              0.000047     endif
   45   0.001691   0.000308     call R.update_bytes_map()
                            
   45              0.000084     return R

FUNCTION  provider#pythonx#CheckForModule()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/pythonx.vim:75
Called 6 times
Total time:   0.083638
 Self time:   0.000604

count  total (s)   self (s)
    6              0.000319   let prog_path = exepath(a:prog)
    6              0.000015   if prog_path ==# ''
    3              0.000010     return [0, a:prog . ' not found in search path or not executable.']
    3              0.000003   endif
                            
    3              0.000007   let min_version = '3.7'
                            
                              " Try to load module, and output Python version.
                              " Exit codes:
                              "   0  module can be loaded.
                              "   2  module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
    3   0.083103   0.000069   let [prog_exitcode, prog_version] = s:import_module(a:prog, a:module)
                            
    3              0.000015   if prog_exitcode == 2 || prog_exitcode == 0
                                " Check version only for expected return codes.
    3              0.000057     if prog_version !~ '^' . a:major_version
                                  return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python ' . a:major_version . '.']
    3              0.000034     elseif prog_version =~ '^' . a:major_version && str2nr(prog_version[2:]) < str2nr(min_version[2:])
                                  return [0, prog_path . ' is Python ' . prog_version . ' and cannot provide Python >= ' . min_version . '.']
    3              0.000003     endif
    3              0.000002   endif
                            
    3              0.000004   if prog_exitcode == 2
    3              0.000013     return [0, prog_path.' does not have the "' . a:module . '" module.']
                              elseif prog_exitcode == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_version]
                              elseif prog_exitcode
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. ' . '(' . prog_exitcode . ', output: ' . prog_version . ')' . ' Report this at https://github.com/neovim/neovim']
                              endif
                            
                              return [1, '']

FUNCTION  vm#comp#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:31
Called 17 times
Total time:   0.003309
 Self time:   0.002873

count  total (s)   self (s)
                                " Set variables according to plugin needs. "{{{1
   17              0.000126     let s:V = b:VM_Selection
   17              0.000076     let s:v = s:V.Vars
   17              0.000073     let s:v.disabled_plugins = []
                            
   17              0.000340     silent! call VM_Start()
   17   0.000264   0.000130     silent doautocmd <nomodeline> User visual_multi_start
                            
   17              0.000088     if exists('g:loaded_youcompleteme')
                                    let g:VM_use_first_cursor_in_line = 1
   17              0.000016     endif
                            
   17              0.000056     if exists('b:doge_interactive')
                                    call doge#deactivate()
   17              0.000013     endif
                            
   85              0.000277     for plugin in keys(s:plugins)
   68              0.000288         let p = s:plugins[plugin]
                            
   68   0.000814   0.000513         if p.test()
                                        exe p.disable
                                        call add(s:v.disabled_plugins, plugin)
   68              0.000056         endif
   85              0.000084     endfor

FUNCTION  <SNR>18_unmap()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/maps.vim:281
Called 930 times
Total time:   0.017863
 Self time:   0.017863

count  total (s)   self (s)
                                " Create an unmap command that will be executed.
  930              0.003426     let k = a:key[0]
  930              0.004370     if empty(k) | return '' | endif
  930              0.002468     let m = a:key[1]
  930              0.002429     let b = a:buffer? ' <buffer> ' : ' '
  930              0.003373     return "silent! ".m."unmap".b.k

FUNCTION  <SNR>98_detect()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/provider/ruby.vim:47
Called 1 time
Total time:   0.000939
 Self time:   0.000939

count  total (s)   self (s)
    1              0.000010   if exists("g:ruby_host_prog")
                                return expand(g:ruby_host_prog, v:true)
    1              0.000009   elseif has('win32')
                                return exepath('neovim-ruby-host.bat')
    1              0.000001   else
    1              0.000889     let p = exepath('neovim-ruby-host')
    1              0.000011     if empty(p)
    1              0.000004       return ''
                                endif
                                " neovim-ruby-host could be an rbenv shim for another Ruby version.
                                call system(p)
                                return v:shell_error ? '' : p
                              end

FUNCTION  vm#global#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/global.vim:7
Called 17 times
Total time:   0.000735
 Self time:   0.000735

count  total (s)   self (s)
                                " Store Global class in buffer VM dictionary.
                            
   17              0.000103     let s:V = b:VM_Selection
   17              0.000045     let s:v = s:V.Vars
   17              0.000035     let s:F = s:V.Funcs
                            
   17              0.000246     let s:X = { -> g:Vm.extend_mode }
   17              0.000198     let s:R = { -> s:V.Regions      }
                            
   17              0.000040     return s:Global

FUNCTION  <lambda>157()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/edit.vim:27
Called 8 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            return s:V.Regions 

FUNCTION  <lambda>159()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/icmds.vim:15
Called 19 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                            return s:V.Regions 

FUNCTION  <SNR>74_went_too_far()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/commands.vim:82
Called 28 times
Total time:   0.002065
 Self time:   0.000404

count  total (s)   self (s)
                                " If gone too far, because it skipped all lines, reselect region.
   28   0.001875   0.000215     if empty(s:G.region_at_pos())
                                    call s:G.select_region(s:v.index)
   28              0.000022     endif

FUNCTION  190()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:149
Called 45 times
Total time:   0.000641
 Self time:   0.000641

count  total (s)   self (s)
                                " Last byte of the last character in the region.
                                " This will be greater than the column, if character is multibyte.
   45              0.000337     let bytes = len(self.txt) ? strlen(self.txt[-1:-1]) : 1
   45              0.000218     return line2byte(self.L) + self.b + bytes - 2

FUNCTION  191()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:157
Called 251 times
Total time:   0.001309
 Self time:   0.001309

count  total (s)   self (s)
  251              0.001089     return self.dir ? self.L : self.l

FUNCTION  192()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:162
Called 296 times
Total time:   0.001350
 Self time:   0.001350

count  total (s)   self (s)
  296              0.001144     return self.dir ? self.b : self.a

FUNCTION  194()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:172
Called 45 times
Total time:   0.001793
 Self time:   0.000823

count  total (s)   self (s)
   45   0.001764   0.000794     return s:X()? s:F.char_at_pos(self.l, self.cur_col()) : ''

FUNCTION  vm#comp#reset()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/comp.vim:95
Called 17 times
Total time:   0.001478
 Self time:   0.001478

count  total (s)   self (s)
                                " Called during VM exit. "{{{1
   17              0.000123     if exists('g:loaded_deoplete') && s:disabled_deoplete
                                    call deoplete#enable()
                                    let s:disabled_deoplete = 0
   17              0.000050     elseif s:disabled_ncm2
                                    let b:ncm2_enable = 1
                                    let s:disabled_ncm2 = 0
   17              0.000016     endif
                            
                                "restore plugins functionality if necessary
   85              0.000261     for plugin in keys(s:plugins)
   68              0.000326         if index(s:v.disabled_plugins, plugin) >= 0
                                        exe s:plugins[plugin].enable
   68              0.000056         endif
   85              0.000082     endfor

FUNCTION  <SNR>7_filename()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:103
Called 572 times
Total time:   0.011304
 Self time:   0.011304

count  total (s)   self (s)
  572              0.005068 	let l:filename = expand("%:t")
  572              0.002372 	if strlen(l:filename) == 0
                            		let l:filename = "< new >"
  572              0.000521 	endif
  572              0.001246 	return l:filename

FUNCTION  vm#variables#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/variables.vim:46
Called 17 times
Total time:   0.006768
 Self time:   0.003872

count  total (s)   self (s)
   17              0.000099   let F = b:VM_Selection.Funcs
   17              0.000077   let v = b:VM_Selection.Vars
                            
                              "init search
   17   0.000301   0.000240   let v.def_reg          = F.default_reg()
   17   0.000488   0.000181   let v.oldreg           = F.get_reg()
   17   0.002715   0.000187   let v.oldregs_1_9      = F.get_regs_1_9()
   17              0.000126   let v.oldsearch        = [getreg("/"), getregtype("/")]
   17              0.000072   let v.noh              = !v:hlsearch ? 'noh|' : ''
                            
                              "store old vars
   17              0.000069   let v.oldhls           = &hlsearch
   17              0.000068   let v.oldvirtual       = &virtualedit
   17              0.000056   let v.oldwhichwrap     = &whichwrap
   17              0.000114   let v.oldlz            = &lz
   17              0.000145   let v.oldch            = &ch
   17              0.000105   let v.oldcase          = [&smartcase, &ignorecase]
   17              0.000067   let v.indentkeys       = &indentkeys
   17              0.000068   let v.cinkeys          = &cinkeys
   17              0.000070   let v.synmaxcol        = &synmaxcol
   17              0.000175   let v.oldmatches       = getmatches()
   17              0.000064   let v.clipboard        = &clipboard
   17              0.000052   let v.textwidth        = &textwidth
   17              0.000054   let v.conceallevel     = &conceallevel
   17              0.000055   let v.concealcursor    = &concealcursor
   17              0.000063   let v.softtabstop      = &softtabstop
   17              0.000068   let v.statusline       = &statusline
                            
                              "init new vars
                            
   17              0.000058   let v.search           = []
   17              0.000060   let v.IDs_list         = []
   17              0.000056   let v.ID               = 0
   17              0.000042   let v.index            = -1
   17              0.000038   let v.direction        = 1
   17              0.000046   let v.nav_direction    = 1
   17              0.000037   let v.auto             = 0
   17              0.000041   let v.silence          = 0
   17              0.000037   let v.eco              = 0
   17              0.000049   let v.single_region    = 0
   17              0.000045   let v.using_regex      = 0
   17              0.000040   let v.multiline        = 0
   17              0.000037   let v.yanked           = 0
   17              0.000038   let v.merge            = 0
   17              0.000032   let v.insert           = 0
   17              0.000045   let v.whole_word       = 0
   17              0.000040   let v.winline          = 0
   17              0.000043   let v.restore_scroll   = 0
   17              0.000048   let v.find_all_overlap = 0
   17              0.000038   let v.dot              = ''
   17              0.000038   let v.no_search        = 0
   17              0.000072   let v.visual_regex     = 0
   17              0.000065   let v.use_register     = v.def_reg
   17              0.000037   let v.deleting         = 0
   17              0.000249   let v.vmarks           = [getpos("'<"), getpos("'>")]

FUNCTION  vm#region#init()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:2
Called 17 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
   17              0.000108     let s:V = b:VM_Selection
   17              0.000047     let s:v = s:V.Vars
   17              0.000036     let s:G = s:V.Global
   17              0.000033     let s:F = s:V.Funcs

FUNCTION  remote#host#RegisterPlugin()
    Defined: /tmp/.mount_nvim.aNA0A4r/usr/share/nvim/runtime/autoload/remote/host.vim:69
Called 2 times
Total time:   0.000267
 Self time:   0.000196

count  total (s)   self (s)
    2   0.000067   0.000032   let plugins = remote#host#PluginsForHost(a:host)
                            
    2              0.000008   for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
    2              0.000003   endfor
                            
    2   0.000060   0.000024   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
    2              0.000001   endif
                            
    2              0.000006   for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
    2              0.000003   endfor
                            
    2              0.000017   call add(plugins, {'path': a:path, 'specs': a:specs})

FUNCTION  210()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:546
Called 45 times
Total time:   0.001383
 Self time:   0.001333

count  total (s)   self (s)
                                " Update bytes map for region.
   45   0.000392   0.000342     if !s:X() | return | endif
                            
   90              0.000293     for b in range(self.A, self.B)
   45              0.000348         let s:V.Bytes[b] = get(s:V.Bytes, b, 0) + 1
   90              0.000101     endfor

FUNCTION  vm#variables#reset()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/variables.vim:107
Called 17 times
Total time:   0.005538
 Self time:   0.004263

count  total (s)   self (s)
   17              0.000159   let v = b:VM_Selection.Vars
                            
   17              0.000051   if !v.oldhls
                                set nohlsearch
   17              0.000018   endif
                            
   17   0.000559   0.000374   let &virtualedit = v.oldvirtual
   17   0.000268   0.000194   let &whichwrap   = v.oldwhichwrap
   17   0.000402   0.000305   let &smartcase   = v.oldcase[0]
   17   0.000244   0.000184   let &ignorecase  = v.oldcase[1]
   17   0.000385   0.000306   let &lz          = v.oldlz
   17   0.000291   0.000224   let &cmdheight   = v.oldch
   17   0.000263   0.000188   let &clipboard   = v.clipboard
                            
   17   0.000249   0.000182   let &l:indentkeys    = v.indentkeys
   17   0.000240   0.000173   let &l:cinkeys       = v.cinkeys
   17   0.000302   0.000215   let &l:synmaxcol     = v.synmaxcol
   17   0.000336   0.000263   let &l:textwidth     = v.textwidth
   17   0.000277   0.000191   let &l:softtabstop   = v.softtabstop
   17   0.000256   0.000166   let &l:conceallevel  = v.conceallevel
   17   0.000280   0.000195   let &l:concealcursor = v.concealcursor
                            
   17              0.000133   if get(g:, 'VM_set_statusline', 2)
   17   0.000271   0.000188     let &l:statusline  = v.statusline
   17              0.000029   endif
                            
   17              0.000294   silent! unlet b:VM_skip_reset_once_on_bufleave

FUNCTION  vm#variables#reset_globals()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/variables.vim:140
Called 17 times
Total time:   0.001460
 Self time:   0.001460

count  total (s)   self (s)
   17              0.001148   let b:VM_Backup = {}
   17              0.000088   let b:VM_Selection = {}
   17              0.000070   let g:Vm.buffer = 0
   17              0.000041   let g:Vm.extend_mode = 0
   17              0.000036   let g:Vm.finding = 0

FUNCTION  <lambda>166()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:24
Called 151 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
                            return s:V.Regions 

FUNCTION  <lambda>167()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:25
Called 45 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
                            return g:Vm.extend_mode 

FUNCTION  <SNR>75_cursor_moved()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm.vim:244
Called 106 times
Total time:   0.028118
 Self time:   0.004560

count  total (s)   self (s)
  106              0.000702     if !s:v.eco
                                    " if currently on a region, set the index to this region
                                    " so that it's possible to select next/previous from it
  106   0.025972   0.002415         let r = s:V.Global.region_at_pos()
  106              0.000879         if !empty(r) | let s:v.index = r.index | endif
  106              0.000084     endif

FUNCTION  <SNR>7_ascii()
    Defined: ~/.local/share/nvim/lazy/42header/plugin/stdheader.vim:53
Called 565 times
Total time:   0.002932
 Self time:   0.002932

count  total (s)   self (s)
  565              0.002364 	return s:asciiart[a:n - 3]

FUNCTION  <SNR>89_cur_char_bytes()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/insert.vim:587
Called 16 times
Total time:   0.000846
 Self time:   0.000846

count  total (s)   self (s)
                                " Bytesize of character under cursor
   16              0.000766     return strlen(matchstr(getline('.'), '\%' . col('.') . 'c.'))

FUNCTION  <SNR>91_move_cursor()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:278
Called 85 times
Total time:   0.034561
 Self time:   0.008749

count  total (s)   self (s)
                                " If not in extend mode, just move the cursors.
                            
   85              0.000601     call cursor(a:r.l, a:r.a)
   85   0.004889   0.000688     call a:r.set_vcol()
   85              0.003122     exe "keepjumps normal! ".s:motion
                            
                                "keep line or column
   85   0.002500   0.001617     if s:vertical()       | call s:keep_vertical_col(a:r)
   85   0.004956   0.001486     elseif !s:v.multiline | call s:keep_line(a:r, line('.'))
   85              0.000080     endif
                            
   85   0.017943   0.000685     call a:r.update_cursor_pos()

FUNCTION  <lambda>170()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:14
Called 988 times
Total time:   0.001388
 Self time:   0.001388

count  total (s)   self (s)
                            return g:Vm.extend_mode 

FUNCTION  <lambda>171()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/autoload/vm/region.vim:15
Called 176 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
                            return s:V.Regions 

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
10501  73.690481  73.564621  <SNR>1_LoadFTPlugin()
10712  29.369198  28.527561  <SNR>54_SynSet()
34812  23.959294             <SNR>25_try()
24426  14.055300  13.535764  <SNR>33_Highlight_Matching_Pair()
10501   9.787473   9.784239  <SNR>2_LoadIndent()
  128   1.961203   0.009518  provider#clipboard#Call()
  110   1.951120             10()
25015   0.532712             <SNR>33_Remove_Matches()
  286   0.436911   0.311044  <SNR>7_update()
   52   0.417462   0.004527  <SNR>74_init()
   28   0.417095   0.000862  <SNR>74_set_extend_mode()
   23   0.364914             54()
   17   0.350094   0.007092  vm#reset()
   17   0.314220   0.026151  vm#init_buffer()
   15   0.277008   0.002498  vm#commands#add_cursor_down()
   17   0.223004   0.001223  vm#maps#init()
  121   0.197039   0.014854  76()
   46   0.188918   0.007712  161()
   13   0.182603   0.001683  vm#commands#add_cursor_up()
   50   0.154510   0.016012  165()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
10501  73.690481  73.564621  <SNR>1_LoadFTPlugin()
10712  29.369198  28.527561  <SNR>54_SynSet()
34812             23.959294  <SNR>25_try()
24426  14.055300  13.535764  <SNR>33_Highlight_Matching_Pair()
10501   9.787473   9.784239  <SNR>2_LoadIndent()
  110              1.951120  10()
25015              0.532712  <SNR>33_Remove_Matches()
   23              0.364914  54()
  286   0.436911   0.311044  <SNR>7_update()
  150   0.096142   0.091968  170()
  984              0.071657  <SNR>18_assign()
  286   0.063527   0.056240  <SNR>7_filetype()
    6   0.138415   0.045466  <SNR>18_build_buffer_maps()
  469   0.063199   0.043612  206()
  428              0.035045  <SNR>34_LocalBrowse()
  577   0.064265   0.034364  <SNR>7_line()
   17              0.031403  6()
  300   0.037694   0.030423  85()
   17   0.028099   0.028047  4()
  635              0.028012  208()

